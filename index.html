<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deki Helper</title>
    <link rel="icon" href="shortcut.png"/>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        html { scroll-behavior: smooth; }
        body { font-family: 'Inter', sans-serif; background-color: #000; }
        .anki-input, .anki-readonly-box, #clipboard-output, textarea.anki-input { background-color: #1e1e1e; border: 1px solid #444; color: #ecf0f1; border-radius: 8px; padding: 12px; width: 100%; font-size: 16px; margin-top: 4px; transition: border-color 0.2s; }
        .anki-input:focus, #clipboard-output:focus, textarea.anki-input:focus { outline: none; border-color: #007acc; }
        .anki-readonly-box { min-height: 48px; display: flex; align-items: center; word-break: break-all; }
        .anki-label { color: #bdc3c7; font-weight: 600; font-size: 14px; }
        .btn { padding: 8px 16px; font-size: 0.875rem; border-radius: 7px; font-weight: 600; cursor: pointer; transition: all 0.2s; border: none; display: inline-flex; align-items: center; justify-content: center; gap: 6px; }
        .btn-sm { padding: 4px 10px; font-size: 0.8rem; }
        .btn-lg { padding: 10px 20px; font-size: 1.125rem; }
        .btn-primary { background-color: #007acc; color: white; } .btn-primary:hover:not(:disabled) { background-color: #005f9e; }
        .btn-secondary { background-color: #555; color: white; } .btn-secondary:hover:not(:disabled) { background-color: #444; }
        .btn-danger { background-color: #c93c3c; color: white; } .btn-danger:hover:not(:disabled) { background-color: #a52828; }
        .btn-success { background-color: #27ae60; color: white; } .btn-success:hover:not(:disabled) { background-color: #229954; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-icon { background: transparent; border: none; color: #777; padding: 4px; border-radius: 50%; } .btn-icon:hover { background-color: #333; color: #eee; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 50;}
        .modal-content { background-color: #1a1a1a; padding: 30px; border-radius: 12px; width: 90%; max-width: 500px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .card-item { background-color: #1e1e1e; border: 1px solid #333; padding: 16px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
        .card-item-content { flex-grow: 1; overflow: hidden; }
        .card-item-front { font-weight: 600; color: #eee; font-size: 1.1em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        .card-item-back { color: #bbb; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        #review-modal { background-color: #000; }
        .review-card { background-color: #1e1e1e; border-radius: 10px; padding: 14px 16px; min-height: 70px; display: flex; justify-content: space-between; align-items: center; text-align: left; }
        .review-content { font-size: 1.05rem; word-break: break-word; flex-grow: 1; }
        .review-copy-btn { background-color: #333; color: #fff; border: none; border-radius: 8px; padding: 12px 16px; cursor: pointer; align-self: center; margin-left: 16px; }
        .review-copy-btn:hover { background-color: #444; }
        .progress-bar-container { background-color: #333; border-radius: 9999px; height: 8px; width: 100%; overflow: hidden;}
        .progress-bar { background-color: #007acc; height: 100%; width: 0%; transition: width 0.3s ease; }
        .copy-highlight { background-color: rgba(0, 122, 204, 0.3); transition: background-color 0.1s ease-in-out; border-radius: 6px;}
        .review-sound-pill { transition: background-color 0.15s ease, box-shadow 0.15s ease; }
        .sound-pill-active { box-shadow: 0 0 0 2px rgba(0, 122, 204, 0.6); background-color: rgba(0, 122, 204, 0.15); }
        .toggle-label .dot { transition: transform 0.2s ease-in-out; }
        #auto-skip-toggle:checked ~ .dot { transform: translateX(100%); background-color: #27ae60; }
        #auto-skip-toggle:checked ~ .block { background-color: #2ecc71; }
        #pause-timer-toggle:checked ~ .dot { transform: translateX(100%); background-color: #c0392b; }
        #pause-timer-toggle:checked ~ .block { background-color: #e74c3c; }
        .duplicates-page { min-height: 100vh; }
        .duplicate-group { background-color: #111; border: 1px solid #333; border-radius: 12px; padding: 18px; }
        .duplicate-field-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: #888; }
        .duplicate-field-value { color: #f0f0f0; font-size: 0.95rem; word-break: break-word; white-space: pre-wrap; line-height: 1.5; }
        .duplicate-card-entry { background-color: #151515; border: 1px solid #2a2a2a; border-radius: 10px; padding: 16px; }
        .duplicate-card-meta { font-size: 0.75rem; color: #b0b0b0; word-break: break-word; }
        .duplicate-card-entry.highlight { border-color: #1d72f3; box-shadow: 0 0 0 1px rgba(29, 114, 243, 0.2); }
        .deleted-page { min-height: 100vh; }
        .deleted-card-entry { background-color: #151515; border: 1px solid #333; border-radius: 12px; padding: 16px; }
        .deleted-card-entry header { display: flex; flex-direction: column; gap: 4px; }
        .deleted-card-entry .meta { font-size: 0.75rem; color: #a0a0a0; display: flex; flex-wrap: wrap; gap: 6px; }
        .deleted-card-entry .field-label { font-size: 0.7rem; text-transform: uppercase; color: #888; letter-spacing: 0.04em; }
        .deleted-card-entry .field-value { font-size: 0.95rem; color: #f0f0f0; white-space: pre-wrap; word-break: break-word; line-height: 1.5; }
        .legacy-page { min-height: 100vh; }
        .legacy-card-entry { background-color: #151515; border: 1px solid #333; border-radius: 12px; padding: 16px; display: grid; gap: 12px; }
        .legacy-card-meta { font-size: 0.75rem; color: #a0a0a0; display: flex; flex-wrap: wrap; gap: 6px; }
        .legacy-field-label { font-size: 0.7rem; text-transform: uppercase; color: #888; letter-spacing: 0.04em; }
        .legacy-field-value { color: #f0f0f0; font-size: 0.95rem; white-space: pre-wrap; word-break: break-word; line-height: 1.5; background-color: #111; border: 1px solid #2a2a2a; border-radius: 8px; padding: 12px; }
        .legacy-code-block { background-color: #111; border: 1px solid #2a2a2a; border-radius: 8px; padding: 12px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.85rem; color: #e0e0e0; overflow-x: auto; white-space: pre-wrap; word-break: break-word; }
        .legacy-preview-box { background-color: #111; border: 1px dashed #444; border-radius: 8px; padding: 12px; display: inline-flex; align-items: center; justify-content: center; min-height: 80px; }
        .legacy-preview-box img { max-width: 100%; max-height: 160px; object-fit: contain; }
        @media (max-width: 640px) {
            #review-modal {
                align-items: flex-start;
                overflow-y: auto;
                overflow-x: hidden;
                padding-bottom: 3rem;
                height: 100%;
            }
            #review-modal > div {
                min-height: 100%;
                width: 100%;
                max-width: 100%;
            }
        }
    </style>
</head>
<body class="text-white">
    <div id="login-view" class="h-screen flex flex-col items-center justify-center text-center p-4 hidden">
        <h1 class="text-4xl font-bold mb-4">Deki Helper</h1>
        <div class="w-full max-w-sm bg-[#1e1e1e] p-8 rounded-lg">
            <h2 id="auth-title" class="text-2xl font-bold mb-6 text-white">Sign In</h2>
            <form id="auth-form" class="space-y-4">
                <input type="email" id="auth-email" placeholder="Email" class="anki-input" required>
                <input type="password" id="auth-password" placeholder="Password" class="anki-input" required>
                <button type="submit" id="auth-submit-btn" class="btn btn-primary btn-lg w-full">Sign In</button>
            </form>
            <p class="text-sm text-gray-400 mt-6">
                <span id="auth-prompt-text">Don't have an account?</span>
                <button id="auth-toggle-btn" class="text-blue-400 hover:underline">Create one</button>
            </p>
        </div>
    </div>

    <div id="main-app" class="container mx-auto max-w-2xl p-4 sm:p-8 hidden">
        <form id="anki-form" class="space-y-6 mb-12">
            <div>
                <label for="folder-select" class="anki-label">Folder</label>
                <div class="flex items-center gap-3">
                    <select id="folder-select" class="anki-input flex-1"></select>
                    <button type="button" id="create-folder-btn" class="btn btn-secondary btn-sm whitespace-nowrap">
                        <i class="fas fa-folder-plus"></i> New Folder
                    </button>
                    <button type="button" id="delete-folder-btn" class="btn btn-danger btn-sm whitespace-nowrap" title="Delete the selected folder" disabled>
                        <i class="fas fa-folder-minus"></i> Delete Folder
                    </button>
                </div>
            </div>
            <div>
                <div class="flex justify-between items-center">
                    <label for="front" class="anki-label">Front</label>
                    <button type="button" id="generate-img-tag-btn" class="text-sm text-blue-400 hover:text-blue-300 cursor-pointer" title="Generate or Cycle Image Tag (t)">
                        <i class="fa-solid fa-wand-magic-sparkles"></i> Generate/Cycle Image
                    </button>
                </div>
                <input type="text" id="front" class="anki-input" autocomplete="off">
            </div>
            <div><label for="back" class="anki-label">Back</label><input type="text" id="back" class="anki-input" autocomplete="off"></div>
            <div><label class="anki-label">Speech</label><div id="speech" class="anki-readonly-box"></div></div>
            <div>
                <label for="beispiel" class="anki-label">Beispiel</label>
                <textarea id="beispiel" class="anki-input" autocomplete="off" rows="3"></textarea>
            </div>
            <div><label class="anki-label">Beispiel (Speech)</label><div id="beispiel-speech" class="anki-readonly-box"></div></div>
            <div>
                <label for="translation" class="anki-label">Translation</label>
                <textarea id="translation" class="anki-input" autocomplete="off" rows="3"></textarea>
                <div class="flex flex-wrap gap-3 mt-3"></div>
            </div>
            <button type="submit" style="display: none;"></button>
        </form>
        <div id="action-bar" class="mt-8 flex flex-col sm:flex-row sm:flex-wrap sm:items-start gap-4 sm:gap-3">
             <p class="text-base font-semibold text-gray-400 flex items-center gap-2">Cards: <span id="session-counter" title="Cards from latest session" class="text-green-400 font-bold">0</span> / <span id="total-counter" title="Total cards" class="text-blue-400 font-bold">0</span></p>
             <div id="default-actions" class="flex flex-col sm:flex-row sm:flex-wrap gap-3 w-full">
                <button id="import-btn" class="btn btn-secondary w-full sm:w-auto"><i class="fas fa-upload"></i> Import</button>
                <input type="file" id="import-file-input" class="hidden" accept=".txt, .tsv, .json, .zip" multiple>
                <button id="review-btn" class="btn btn-secondary w-full sm:w-auto"><i class="fas fa-eye"></i> Review</button>
                <button id="export-btn" class="btn btn-primary w-full sm:w-auto"><i class="fas fa-download"></i> Export</button>
                <button id="fix-legacy-fronts-btn" class="btn btn-secondary w-full sm:w-auto"><i class="fas fa-wrench"></i> Fix Legacy Fronts</button>
                <button id="show-legacy-btn" class="btn btn-secondary w-full sm:w-auto">
                    <i class="fas fa-image"></i> Legacy Fronts
                    <span id="legacy-count-badge" class="hidden text-xs font-semibold bg-orange-500 text-black px-2 py-0.5 rounded-full"></span>
                </button>
                <button id="show-duplicates-btn" class="btn btn-secondary w-full sm:w-auto">
                    <i class="fas fa-clone"></i> Duplicates
                    <span id="duplicate-count-badge" class="hidden text-xs font-semibold bg-red-500 text-white px-2 py-0.5 rounded-full"></span>
                </button>
                <button id="show-deleted-btn" class="btn btn-secondary w-full sm:w-auto">
                    <i class="fas fa-trash-restore"></i> Deleted
                    <span id="deleted-count-badge" class="hidden text-xs font-semibold bg-yellow-500 text-black px-2 py-0.5 rounded-full"></span>
                </button>
                <button id="delete-cards-btn" class="btn btn-danger w-full sm:w-auto"><i class="fas fa-trash-alt"></i> Delete Cards</button>
             </div>
             <div id="edit-actions" class="hidden space-x-4">
                <button id="update-btn" class="btn btn-primary"><i class="fas fa-check"></i> Update</button>
                <button id="cancel-btn" class="btn btn-secondary"><i class="fas fa-times"></i> Cancel</button>
             </div>
        </div>
        <hr class="border-gray-700 my-8">
        <div id="example-match-section" class="mt-10">
            <div class="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-3 mb-3">
                <div>
                    <h2 class="text-2xl font-bold text-gray-300">Example Finder</h2>
                    <p class="text-sm text-gray-400 mt-1">Upload vocab JSON for A1, A2, and B1 separately and add their examples to your cards.</p>
                </div>
                <div class="flex flex-col gap-2">
                    <div class="flex flex-wrap gap-2">
                        <input type="file" id="example-upload-input-A1" class="hidden" accept=".json">
                        <button type="button" id="example-upload-btn-A1" class="btn btn-secondary btn-sm whitespace-nowrap" title="Upload A1 vocab JSON">
                            <i class="fas fa-upload"></i> Upload A1
                        </button>
                        <input type="file" id="example-upload-input-A2" class="hidden" accept=".json">
                        <button type="button" id="example-upload-btn-A2" class="btn btn-secondary btn-sm whitespace-nowrap" title="Upload A2 vocab JSON">
                            <i class="fas fa-upload"></i> Upload A2
                        </button>
                        <input type="file" id="example-upload-input-B1" class="hidden" accept=".json">
                        <button type="button" id="example-upload-btn-B1" class="btn btn-secondary btn-sm whitespace-nowrap" title="Upload B1 vocab JSON">
                            <i class="fas fa-upload"></i> Upload B1
                        </button>
                    </div>
                    <div class="flex flex-wrap gap-2">
                        <button type="button" id="example-download-btn-A1" class="btn btn-secondary btn-sm whitespace-nowrap" title="Download the latest A1 vocab JSON">
                            <i class="fas fa-download"></i> Download A1
                        </button>
                        <button type="button" id="example-download-btn-A2" class="btn btn-secondary btn-sm whitespace-nowrap" title="Download the latest A2 vocab JSON">
                            <i class="fas fa-download"></i> Download A2
                        </button>
                        <button type="button" id="example-download-btn-B1" class="btn btn-secondary btn-sm whitespace-nowrap" title="Download the latest B1 vocab JSON">
                            <i class="fas fa-download"></i> Download B1
                        </button>
                        <button type="button" id="refresh-example-library-btn" class="btn btn-secondary btn-sm whitespace-nowrap">
                            <i class="fas fa-rotate"></i> Reload Library
                        </button>
                        <button type="button" id="find-example-matches-btn" class="btn btn-primary btn-sm whitespace-nowrap">
                            <i class="fas fa-search"></i> Find Matches
                        </button>
                    </div>
                </div>
            </div>
            <div class="flex flex-col sm:flex-row sm:flex-wrap gap-3 mb-3">
                <input type="text" id="example-match-filter" class="anki-input flex-1" placeholder="Filter by word or card text...">
                <select id="example-source-filter" class="anki-input sm:w-60">
                    <option value="__all__">All sources</option>
                </select>
                <select id="example-folder-filter" class="anki-input sm:w-60">
                    <option value="__all_folders__">All folders</option>
                </select>
            </div>
            <p id="example-library-status" class="text-xs text-gray-500 mb-2"></p>
            <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2 mb-3">
                <p id="example-match-summary" class="text-sm text-gray-400"></p>
                <button id="example-match-show-more" class="btn btn-secondary btn-sm whitespace-nowrap hidden">Show more</button>
            </div>
            <div id="example-matches-empty" class="hidden text-gray-500 text-center border border-dashed border-gray-700 rounded-lg p-6">
                No matches yet. Upload A1/A2/B1 JSON and click "Find Matches" to search your cards.
            </div>
            <div id="example-matches-container" class="space-y-3"></div>
        </div>
        <hr class="border-gray-700 my-8">
        <div>
            <h2 class="text-2xl font-bold mb-4 text-gray-300">Saved Cards</h2>
            <div class="mb-4 flex flex-col sm:flex-row gap-3">
                <input type="text" id="search-input" class="anki-input flex-1" placeholder="Search in front, back, beispiel, translation...">
                <select id="view-folder-selector" class="anki-input sm:w-56" title="Filter cards by folder"></select>
            </div>
            <div id="card-list"></div>
        </div>

        <footer class="mt-12 pt-8 border-t border-gray-700 flex justify-between items-center">
            <div id="user-info" class="flex items-center gap-3">
                <span id="user-email" class="font-semibold text-gray-300 text-sm"></span>
            </div>
            <button id="logout-btn" class="btn btn-secondary">Sign Out</button>
        </footer>
    </div>
    <div id="review-modal" class="modal-backdrop hidden fixed inset-0 bg-black p-4 sm:p-8 z-50">
        <div class="w-full max-w-3xl mx-auto flex flex-col h-full">
            <div id="review-setup" class="flex-grow flex flex-col items-center justify-center">
                <h2 class="text-4xl font-bold mb-8">Start Review Session</h2>
                <div class="w-full max-w-xs space-y-4">
                    <div>
                        <label for="review-folder-selector" class="anki-label mb-2 block">Select Folder:</label>
                        <select id="review-folder-selector" class="anki-input"></select>
                    </div>
                    <div>
                        <label for="review-date-selector" class="anki-label mb-2 block">Select Date:</label>
                        <select id="review-date-selector" class="anki-input"></select>
                    </div>
                    <div>
                        <label class="flex items-center space-x-2 text-sm text-gray-300">
                            <input type="checkbox" id="review-missing-only-toggle" class="form-checkbox h-4 w-4 text-blue-500 bg-gray-700 border-gray-600 rounded">
                            <span>Only cards without Beispiel</span>
                        </label>
                        <p class="text-xs text-gray-500 mt-1">Filter the session to cards that do not have example sentences yet.</p>
                    </div>
                    <button id="start-session-btn" class="btn btn-primary btn-lg w-full mt-6">Start Session</button>
                    <button id="close-review-setup-btn" class="btn btn-secondary btn-lg w-full">Close</button>
                </div>
            </div>
            <div id="review-session" class="hidden flex-grow flex flex-col">
                <div class="flex flex-col md:flex-row justify-between items-center mb-2 text-gray-400 gap-4">
                    <div class="flex items-center gap-4">
                        <p id="review-progress-text" class="font-semibold"></p>
                        <p id="review-edited-text" class="font-semibold"></p>
                    </div>
                    <div class="flex flex-wrap items-center justify-center gap-x-4 gap-y-2">
                        <button id="edit-review-card-btn" class="btn btn-secondary"><i class="fas fa-pencil-alt"></i> Edit</button>
                        <button id="save-review-edit-btn" class="btn btn-success hidden"><i class="fas fa-check"></i> Save</button>
                        <button id="cancel-review-edit-btn" class="btn btn-secondary hidden"><i class="fas fa-times"></i> Cancel</button>
                        <button id="mark-edited-btn" class="btn btn-secondary" title="Mark as Edited (M)"><i class="fas fa-check"></i></button>
                        <button id="delete-review-card-btn" class="btn btn-danger"><i class="fas fa-trash-alt"></i></button>
                        <label class="toggle-label flex items-center cursor-pointer">
                            <span class="mr-2 text-sm font-medium">Skip Delay</span>
                            <div class="relative">
                                <input type="checkbox" id="auto-skip-toggle" class="sr-only">
                                <div class="block bg-gray-600 w-10 h-6 rounded-full"></div>
                                <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full"></div>
                            </div>
                        </label>
                         <label class="toggle-label flex items-center cursor-pointer">
                            <span class="mr-2 text-sm font-medium">Pause Timer</span>
                            <div class="relative">
                                <input type="checkbox" id="pause-timer-toggle" class="sr-only">
                                <div class="block bg-gray-600 w-10 h-6 rounded-full"></div>
                                <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full"></div>
                            </div>
                        </label>
                    </div>
                </div>
                <div class="progress-bar-container mb-6">
                    <div id="review-progress-bar" class="progress-bar"></div>
                </div>
                <div class="flex-grow flex flex-col justify-center space-y-2">
                     <div class="mb-4">
                        <input type="text" id="in-review-search-input" class="anki-input text-sm" placeholder="Search in current review session...">
                    </div>
                    <div>
                        <label class="anki-label ml-2 flex justify-between"><span>Front</span> <span class="text-gray-500">Shortcut: F</span></label>
                        <div class="review-card">
                            <span id="review-front" class="review-content"></span>
                            <button class="review-copy-btn" data-target="review-front" title="Copy Front (F)"><i class="fas fa-copy fa-lg"></i></button>
                        </div>
                    </div>
                    <div>
                        <label class="anki-label ml-2 flex justify-between"><span>Back</span> <span class="text-gray-500">Shortcut: B</span></label>
                        <div class="review-card">
                            <span id="review-back" class="review-content"></span>
                            <button class="review-copy-btn" data-target="review-back" title="Copy Back (B)"><i class="fas fa-copy fa-lg"></i></button>
                        </div>
                    </div>
                    <div>
                        <label class="anki-label ml-2 flex justify-between"><span>Beispiel</span> <span class="text-gray-500">Shortcut: E</span></label>
                        <div class="review-card">
                            <div id="review-beispiel" class="review-content flex-grow flex flex-col justify-center py-2 space-y-2"></div>
                            <textarea id="edit-beispiel" class="anki-input hidden" rows="4"></textarea>
                        </div>
                    </div>
                    <div>
                        <label class="anki-label ml-2 flex justify-between"><span>Beispiel Speech</span> <span class="text-gray-500">Shortcut: S</span></label>
                        <div class="review-card">
                            <div id="review-beispiel-speech" class="review-content flex-grow flex flex-wrap items-center gap-2 py-2"></div>
                            <button class="review-copy-btn" data-target="review-beispiel-speech" data-copy-type="beispiel-speech" title="Copy Beispiel Speech (S)"><i class="fas fa-copy fa-lg"></i></button>
                        </div>
                    </div>
                    <div>
                        <label class="anki-label ml-2 flex justify-between"><span>Translation</span></label>
                        <div class="review-card">
                            <div id="review-translation" class="review-content flex-grow flex flex-col justify-center py-2 space-y-2"></div>
                            <textarea id="edit-translation" class="anki-input hidden" rows="4"></textarea>
                        </div>
                    </div>
                </div>
                <div class="flex justify-between items-center mt-6">
                    <button id="prev-card-btn" class="btn btn-secondary btn-lg"><i class="fas fa-arrow-left"></i> Previous</button>
                    <button id="end-review-btn" class="btn btn-danger btn-lg">End Review</button>
                    <button id="next-card-btn" class="btn btn-secondary btn-lg">Next <i class="fas fa-arrow-right"></i></button>
                </div>
            </div>
        </div>
    </div>
    <div id="delete-modal" class="modal-backdrop hidden">
         <div class="modal-content text-center">
             <h2 class="text-2xl font-bold mb-4">Confirm Deletion</h2>
             <p class="text-gray-300 mb-6">Are you sure you want to delete this card?</p>
             <div class="flex justify-center items-center space-x-4">
                <button id="confirm-delete-btn" class="btn btn-danger">Yes, Delete</button>
                <button id="cancel-delete-btn" class="btn btn-secondary">Cancel</button>
             </div>
        </div>
    </div>
    <div id="duplicates-view" class="duplicates-page hidden container mx-auto max-w-5xl p-4 sm:p-8">
        <div class="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4 mb-6">
            <div>
                <h1 class="text-3xl font-bold">Duplicate Cards</h1>
                <p id="duplicates-summary" class="text-sm text-gray-400 mt-2"></p>
            </div>
            <div class="flex flex-wrap gap-2">
                <button id="duplicates-export-btn" class="btn btn-secondary btn-sm">
                    <i class="fas fa-download"></i> Export Visible
                </button>
                <button id="duplicates-back-btn" class="btn btn-secondary btn-sm">
                    <i class="fas fa-arrow-left"></i> Back to Cards
                </button>
            </div>
        </div>
        <div class="flex flex-col md:flex-row md:items-center gap-4 mb-6">
            <input id="duplicates-search-input" class="anki-input flex-1" placeholder="Search in front, back, translation, beispiel...">
            <select id="duplicates-folder-filter" class="anki-input md:w-56">
                <option value="__all__">All folders</option>
                <option value="__none__">No folder</option>
            </select>
            <button id="duplicates-refresh-btn" class="btn btn-secondary btn-sm md:whitespace-nowrap">
                <i class="fas fa-arrows-rotate"></i> Refresh
            </button>
        </div>
        <div id="duplicates-empty-state" class="hidden text-gray-500 text-center border border-dashed border-gray-700 rounded-lg p-10">
            No duplicate cards found.
        </div>
        <div id="duplicates-container" class="space-y-6"></div>
    </div>
    <div id="legacy-view" class="legacy-page hidden container mx-auto max-w-4xl p-4 sm:p-8">
        <div class="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4 mb-6">
            <div>
                <h1 class="text-3xl font-bold">Legacy Image Fronts</h1>
                <p id="legacy-summary" class="text-sm text-gray-400 mt-2"></p>
            </div>
            <div class="flex flex-wrap gap-2">
                <button type="button" id="legacy-fix-all-btn" class="btn btn-primary btn-sm">
                    <i class="fas fa-wrench"></i> Fix All
                </button>
                <button type="button" id="legacy-back-btn" class="btn btn-secondary btn-sm">
                    <i class="fas fa-arrow-left"></i> Back to Cards
                </button>
            </div>
        </div>
        <p class="text-gray-400 text-sm mb-6">Preview the cards that still use legacy encoded image fronts. You can fix cards one by one or all at once.</p>
        <div id="legacy-empty-state" class="hidden text-gray-500 text-center border border-dashed border-gray-700 rounded-lg p-10">
            No legacy image fronts detected.
        </div>
        <div id="legacy-container" class="space-y-4"></div>
    </div>
    <div id="deleted-view" class="deleted-page hidden container mx-auto max-w-4xl p-4 sm:p-8">
        <div class="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4 mb-6">
            <div>
                <h1 class="text-3xl font-bold">Recently Deleted</h1>
                <p id="deleted-summary" class="text-sm text-gray-400 mt-2"></p>
            </div>
            <div class="flex flex-wrap gap-2">
                <button id="deleted-back-btn" class="btn btn-secondary btn-sm">
                    <i class="fas fa-arrow-left"></i> Back to Cards
                </button>
            </div>
        </div>
        <div id="deleted-empty-state" class="hidden text-gray-500 text-center border border-dashed border-gray-700 rounded-lg p-10">
            No deleted cards in history.
        </div>
        <div id="deleted-container" class="space-y-4"></div>
    </div>
    <div id="export-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-6">Export Options</h2>
            <div class="space-y-4">
                <div>
                    <h3 class="anki-label mb-2">Format</h3>
                    <div class="flex flex-col space-y-2">
                        <label class="flex items-center space-x-2">
                            <input type="radio" name="export-format" value="txt" class="form-radio" checked>
                            <span>TXT (for Anki)</span>
                        </label>
                        <label class="flex items-center space-x-2">
                            <input type="radio" name="export-format" value="json" class="form-radio">
                            <span>JSON</span>
                        </label>
                        <label class="flex items-center space-x-2">
                            <input type="radio" name="export-format" value="category-zip" class="form-radio">
                            <span>Category Folder (.zip)</span>
                        </label>
                        <label class="flex items-center space-x-2">
                            <input type="radio" name="export-format" value="clipboard" class="form-radio">
                            <span>Copy to Clipboard (Back & Front)</span>
                        </label>
                        <label class="flex items-center space-x-2">
                            <input type="radio" name="export-format" value="clipboard-back-only" class="form-radio">
                            <span>Copy to Clipboard (Back only)</span>
                        </label>
                        <label class="flex items-center space-x-2">
                            <input type="radio" name="export-format" value="beispiel-speech" class="form-radio">
                            <span>Copy to Clipboard (Beispiel Speech)</span>
                        </label>
                    </div>
                </div>
                <hr class="border-gray-700 !my-6">
                <div>
                    <h3 class="anki-label mb-2">Cards to Export</h3>
                    <label class="flex items-center space-x-2">
                        <input type="radio" id="export-all-radio" name="export-range" value="all" class="form-radio" checked>
                        <span>All cards</span>
                    </label>
                    <label class="flex items-center space-x-2 mt-2">
                        <input type="radio" id="export-date-radio" name="export-range" value="date" class="form-radio">
                        <span>Cards from selected dates</span>
                    </label>
                    <div id="export-date-selection" class="hidden pl-6 pt-2 mt-2 max-h-32 overflow-y-auto border-l-2 border-gray-700">
                        <!-- Date checkboxes will be inserted here by JS -->
                    </div>
                    <label class="flex items-center space-x-2 mt-2">
                        <input type="radio" id="export-folder-radio" name="export-range" value="folder" class="form-radio">
                        <span>Cards from selected folders</span>
                    </label>
                    <div id="export-folder-selection" class="hidden pl-6 pt-2 mt-2 max-h-32 overflow-y-auto border-l-2 border-gray-700">
                        <!-- Folder checkboxes inserted by JS -->
                    </div>
                </div>
                <div id="clipboard-output-container" class="hidden mt-6">
                    <label for="clipboard-output" class="anki-label mb-2">Formatted Text</label>
                    <div class="flex items-center gap-2">
                        <textarea id="clipboard-output" readonly class="text-sm flex-grow" rows="8"></textarea>
                        <button id="copy-clipboard-btn" class="btn btn-secondary self-start" title="Copy Text"><i class="fas fa-copy"></i></button>
                    </div>
                </div>
            </div>
            <div class="flex justify-end items-center space-x-4 mt-8">
               <button id="cancel-export-btn" class="btn btn-secondary">Cancel</button>
               <button id="confirm-export-btn" class="btn btn-primary">Export</button>
            </div>
       </div>
   </div>
    <div id="notification" class="fixed top-5 right-5 bg-red-600 text-white py-2 px-4 rounded-lg shadow-lg hidden z-50"><p id="notification-message"></p></div>
    <div id="delete-cards-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-6">Delete Cards</h2>
            <div class="space-y-6">
                <div>
                    <h3 class="anki-label mb-2">Choose what to delete</h3>
                    <label class="flex items-center space-x-2">
                        <input type="radio" id="delete-date-radio" name="delete-mode" value="date" class="form-radio" checked>
                        <span>Cards from selected dates</span>
                    </label>
                    <div id="delete-date-selection" class="pl-6 pt-2 mt-2 max-h-32 overflow-y-auto border-l-2 border-gray-700">
                        <!-- Date checkboxes will be inserted here by JS -->
                    </div>
                    <label class="flex items-center space-x-2 mt-4">
                        <input type="radio" id="delete-folder-radio" name="delete-mode" value="folder" class="form-radio">
                        <span>Cards from selected folders</span>
                    </label>
                    <div id="delete-folder-selection" class="hidden pl-6 pt-2 mt-2 max-h-32 overflow-y-auto border-l-2 border-gray-700">
                        <!-- Folder checkboxes will be inserted here by JS -->
                    </div>
                </div>
                <p class="text-sm text-gray-400">Deleted cards move to the Deleted section, where you can restore them later.</p>
            </div>
            <div class="flex justify-end items-center space-x-4 mt-8">
                <button id="cancel-delete-cards-btn" class="btn btn-secondary">Cancel</button>
                <button id="confirm-delete-cards-btn" class="btn btn-danger">Delete Selected</button>
            </div>
        </div>
    </div>

    <div id="folder-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-4">Create Folder</h2>
            <div class="space-y-4">
                <div>
                    <label for="folder-name-input" class="anki-label mb-2 block">Folder Name</label>
                    <input type="text" id="folder-name-input" class="anki-input" placeholder="e.g. Grammar">
                </div>
            </div>
            <div class="flex justify-end items-center space-x-4 mt-8">
                <button id="cancel-folder-btn" class="btn btn-secondary">Cancel</button>
                <button id="save-folder-btn" class="btn btn-primary">Create</button>
            </div>
        </div>
    </div>

    <div id="delete-folder-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-4">Delete Folder</h2>
            <p id="delete-folder-summary" class="text-gray-300 text-sm leading-6"></p>
            <div class="flex justify-end items-center space-x-4 mt-8">
                <button id="cancel-delete-folder-btn" class="btn btn-secondary">Cancel</button>
                <button id="confirm-delete-folder-btn" class="btn btn-danger">Delete Folder</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, getDocs, query, doc, deleteDoc, setDoc, writeBatch, updateDoc, getDoc, orderBy, limit, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import JSZip from "https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm";

        const firebaseConfig = { apiKey: "AIzaSyD6zpZUM_ABNngOX-RKFxwNoTqePDivrGE", authDomain: "deki-helper.firebaseapp.com", projectId: "deki-helper", storageBucket: "deki-helper.appspot.com", messagingSenderId: "612229919023", appId: "1:612229919023:web:c6507af0e5a2ddd84731da" };
        const appId = 'anki-card-generator-default';
        const NO_FOLDER_VALUE = '__none__';
        const ALL_FOLDERS_VALUE = '__all_folders__';
        const EXPORT_SELECT_ALL_ID = 'export-folder-select-all-checkbox';
        const FOLDER_STORAGE_KEY = 'deki-helper-current-folder';
        const FIREBASE_FUNCTIONS_REGION = 'us-central1';
        const EXAMPLE_SOURCE_SLOTS = [
            { id: 'A1', label: 'A1', defaultFileName: 'A1.json' },
            { id: 'A2', label: 'A2', defaultFileName: 'A2.json' },
            { id: 'B1', label: 'B1', defaultFileName: 'B1.json' }
        ];
        const EXAMPLE_MATCH_PAGE_SIZE = 10;

        
        let app, auth, db, userId, cardsCollectionRef, unsubscribe;
        let foldersCollectionRef, foldersUnsubscribe;
        let deletedCardsCollectionRef, deletedCardsUnsubscribe;
        let currentEditId = null, cardToDeleteId = null, allCards = [];
        let deletedCards = [];
        let folders = [];
        let currentFolderId = null;
        let pendingFolderDeleteId = null;
        let pendingFolderDeleteName = '';
        let pendingFolderDeleteCount = 0;
        let reviewSession = { cards: [], currentIndex: -1, autoSkipTimer: null, beispielCopyIndex: 0, beispielSpeechCopyIndex: 0, editedCardIds: new Set(), originalCards: [] };
        let currentReviewFolderId = ALL_FOLDERS_VALUE;
        let currentReviewSessionId = null;
        let currentViewFolderId = ALL_FOLDERS_VALUE;
        let currentExampleFolderId = ALL_FOLDERS_VALUE;
        let isSignUpMode = false;
        let isReviewEditing = false;
        let currentReviewDate = "all";
        let deleteShortcutState = { pending: false, timeoutId: null };
        let hasRestoredFolderPreference = false;
        let isBulkTranslating = false;
        let isFixingLegacyFronts = false;
        let exampleWordMap = new Map();
        let exampleLibrarySources = [];
        let exampleSourcesLoaded = [];
        let exampleLibraryDocRef = null;
        let exampleLibraryUnsubscribe = null;
        let exampleLibraryLoadedAt = null;
        let isLoadingExampleLibrary = false;
        let currentExampleMatches = [];
        let exampleMatchesVisibleCount = EXAMPLE_MATCH_PAGE_SIZE;
        
        function showNotification(message, level = 'error', duration = 3000) {
            const notification = document.getElementById('notification');
            const notificationMessage = document.getElementById('notification-message');
            notificationMessage.innerHTML = message;
            notification.className = `fixed top-5 right-5 text-white py-2 px-4 rounded-lg shadow-lg ${level === 'error' ? 'bg-red-600' : 'bg-green-600'}`;
            notification.classList.remove('hidden');
            setTimeout(() => { notification.classList.add('hidden'); }, duration);
        }

        function setButtonLoading(button, isLoading, loadingText = 'Processing...') {
            if (!button) return;
            if (isLoading) {
                if (!button.dataset.originalContent) {
                    button.dataset.originalContent = button.innerHTML;
                }
                button.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${loadingText}`;
                button.disabled = true;
            } else {
                if (button.dataset.originalContent) {
                    button.innerHTML = button.dataset.originalContent;
                    delete button.dataset.originalContent;
                }
                button.disabled = false;
            }
        }

        function copyPlainTextToClipboard(text) {
            const tempInput = document.createElement('textarea');
            tempInput.value = text;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function normalizeSentencesFromBeispiel(value) {
            if (!value) return [];
            let raw = typeof value === 'string' ? value : String(value ?? '');
            if (raw.includes('<br')) {
                raw = unformatMultiLine(raw);
            }
            raw = raw.replace(/&nbsp;/gi, ' ');
            return raw
                .split(/\r?\n/)
                .map(line => line.trim())
                .filter(line => line.length > 0);
        }

        function cardHasBeispiel(card) {
            if (!card) return false;
            return normalizeSentencesFromBeispiel(card.beispiel).length > 0;
        }

        function isReviewMissingOnly() {
            const toggle = document.getElementById('review-missing-only-toggle');
            return !!(toggle && toggle.checked);
        }

        function clearAutoSkipTimer() {
            if (reviewSession.autoSkipTimer) {
                clearTimeout(reviewSession.autoSkipTimer);
                reviewSession.autoSkipTimer = null;
            }
        }

        function resetDeleteShortcut() {
            if (deleteShortcutState.timeoutId) {
                clearTimeout(deleteShortcutState.timeoutId);
                deleteShortcutState.timeoutId = null;
            }
            deleteShortcutState.pending = false;
        }

        function getSourceSlotMeta(sourceId) {
            if (!sourceId) return null;
            return EXAMPLE_SOURCE_SLOTS.find(slot => slot.id === sourceId) || null;
        }

        function normalizeWordForLookup(value) {
            if (!value) return '';
            return String(value)
                .toLowerCase()
                .replace(/<[^>]*>/g, ' ')
                .replace(/[^\p{L}\p{N}\s-]/gu, ' ')
                .replace(/\s+/g, ' ')
                .trim();
        }

        function normalizeWordVariants(value) {
            const variants = new Set();
            const base = normalizeWordForLookup(value);
            if (base) variants.add(base); // exact-only: no article stripping
            return Array.from(variants);
        }

        function resolveSourceLabel(source) {
            if (!source) return 'Unknown source';
            const sourceId = typeof source === 'string' ? source : (source.id || '');
            const slotMeta = getSourceSlotMeta(sourceId);
            const slotLabel = slotMeta ? slotMeta.label : null;
            if (typeof source === 'string') return slotLabel || source;
            return source.label || slotLabel || source.fileName || source.id || 'Unknown source';
        }

        function generateExampleSourceId(fileName) {
            const base = (fileName || 'source').replace(/\.[^.]+$/, '').trim();
            const slug = base.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') || 'source';
            const existing = new Set(exampleLibrarySources.map(src => src.id));
            let candidate = slug || 'source';
            let counter = 1;
            while (existing.has(candidate)) {
                candidate = `${slug}-${counter}`;
                counter += 1;
            }
            return candidate;
        }

        function decorateExampleEntries(entries, sourceId) {
            if (!Array.isArray(entries)) return [];
            return entries.map((entry, index) => {
                const clone = entry && typeof entry === 'object' ? { ...entry } : {};
                const metaId = `${sourceId || 'src'}__${index}__${Date.now()}__${Math.random().toString(16).slice(2)}`;
                Object.defineProperty(clone, '__metaId', { value: metaId, enumerable: false, writable: true });
                return clone;
            });
        }

        function stripExampleMetadata(entry) {
            if (!entry || typeof entry !== 'object') return entry;
            const clone = {};
            Object.keys(entry).forEach(key => {
                clone[key] = entry[key];
            });
            return clone;
        }

        function normalizeExampleSources(rawSources = []) {
            if (!Array.isArray(rawSources)) return [];
            return rawSources.map((src, index) => {
                const id = src.id || generateExampleSourceId(`upload-${index + 1}`);
                const slot = getSourceSlotMeta(id);
                const label = src.label || (slot ? slot.label : (src.fileName ? src.fileName.replace(/\.json$/i, '') : id));
                const fileName = src.fileName || (slot ? slot.defaultFileName : `${label}.json`);
                const entries = decorateExampleEntries(src.entries || [], id);
                return { id, label, fileName, entries };
            });
        }

        async function persistExampleLibrary() {
            const payload = {
                sources: exampleLibrarySources.map(src => ({
                    id: src.id,
                    label: src.label,
                    fileName: src.fileName,
                    entries: (src.entries || []).map(stripExampleMetadata)
                }))
            };
            if (!userId || !db || !exampleLibraryDocRef) return;
            try {
                await setDoc(exampleLibraryDocRef, payload, { merge: true });
            } catch (error) {
                console.warn('Failed to persist example library to Firestore', error);
            }
        }

        function applyRemoteExampleLibrary(sources = []) {
            exampleLibrarySources = normalizeExampleSources(sources);
            exampleWordMap = new Map();
            exampleSourcesLoaded = [];
            populateExampleSourceFilter();
            refreshExampleMatches({ forceReloadLibrary: true });
            const count = exampleLibrarySources.length;
            setExampleLibraryStatus(count > 0
                ? `Loaded ${count} source${count === 1 ? '' : 's'} from cloud. Click Find Matches to search.`
                : 'Upload A1/A2/B1 JSON to search for Beispiele. Files sync to your account.');
        }

        function getExampleSourceLabel(sourceId) {
            if (!sourceId) return 'Unknown source';
            const match = exampleSourcesLoaded.find(src => src.id === sourceId) || exampleLibrarySources.find(src => src.id === sourceId);
            return resolveSourceLabel(match) || sourceId;
        }

        function setExampleLibraryStatus(message) {
            const statusEl = document.getElementById('example-library-status');
            if (statusEl) statusEl.textContent = message || '';
        }

        function collectExamplesFromEntry(entry) {
            if (!entry || typeof entry !== 'object') return [];
            const examples = [];
            Object.keys(entry).forEach(key => {
                if (!/^example\d*$/i.test(key)) return;
                const value = entry[key];
                if (value && String(value).trim().length > 0) {
                    examples.push(String(value).trim());
                }
            });
            return examples;
        }

        async function loadExampleLibrary(forceReload = false) {
            if (!forceReload && exampleSourcesLoaded.length > 0 && exampleWordMap.size > 0) {
                return { loaded: true, sources: exampleSourcesLoaded };
            }
            if (isLoadingExampleLibrary) return { loaded: false, sources: exampleSourcesLoaded };

            if (!exampleLibrarySources.length) {
                exampleWordMap = new Map();
                exampleSourcesLoaded = [];
                populateExampleSourceFilter();
                setExampleLibraryStatus('Upload A1/A2/B1 JSON to search for Beispiele. Files sync to your account.');
                return { loaded: false, sources: [] };
            }

            isLoadingExampleLibrary = true;
            exampleWordMap = new Map();
            exampleSourcesLoaded = [];
            setExampleLibraryStatus('Indexing uploaded vocab files...');

            exampleLibrarySources.forEach((source, sourceIndex) => {
                const entries = Array.isArray(source.entries) ? source.entries : [];
                let added = 0;
                entries.forEach((entry, entryIndex) => {
                    if (!entry || !entry.word) return;
                    if (!entry.__metaId) {
                        const metaId = `${source.id || sourceIndex}__${entryIndex}__${Date.now()}__${Math.random().toString(16).slice(2)}`;
                        Object.defineProperty(entry, '__metaId', { value: metaId, enumerable: false, writable: true });
                    }
                    const variants = normalizeWordVariants(entry.word);
                    if (!variants.length) return;
                    const examples = collectExamplesFromEntry(entry);
                    if (!examples.length) return;
                    variants.forEach(normalizedWord => {
                        if (!exampleWordMap.has(normalizedWord)) {
                            exampleWordMap.set(normalizedWord, []);
                        }
                        exampleWordMap.get(normalizedWord).push({
                            word: entry.word,
                            sourceId: source.id,
                            examples: [...examples],
                            entryId: entry.__metaId
                        });
                    });
                    added += 1;
                });
                exampleSourcesLoaded.push({ ...source, count: added });
            });

            isLoadingExampleLibrary = false;
            exampleLibraryLoadedAt = new Date();
            populateExampleSourceFilter();

            const totalWords = exampleSourcesLoaded.reduce((sum, src) => sum + (src.count || 0), 0);
            const loadedSources = exampleSourcesLoaded.length
                ? exampleSourcesLoaded.map(s => `${resolveSourceLabel(s)} (${s.count || 0})`).join(', ')
                : 'none';
            setExampleLibraryStatus(`Loaded ${totalWords} vocab entries from ${exampleSourcesLoaded.length} uploaded source${exampleSourcesLoaded.length === 1 ? '' : 's'}: ${loadedSources}`);

            return { loaded: totalWords > 0, sources: exampleSourcesLoaded };
        }

        function populateExampleSourceFilter() {
            const select = document.getElementById('example-source-filter');
            if (!select) return;
            const previousValue = select.value || '__all__';
            select.innerHTML = '<option value="__all__">All sources</option>';
            exampleSourcesLoaded.forEach(src => {
                const option = document.createElement('option');
                option.value = src.id;
                option.textContent = `${resolveSourceLabel(src)} (${src.count || 0})`;
                select.appendChild(option);
            });
            const availableValues = Array.from(select.options).map(opt => opt.value);
            select.value = availableValues.includes(previousValue) ? previousValue : '__all__';
        }

        function buildExampleMatches({ filterTerm = '', sourceFilter = '__all__', folderFilter = ALL_FOLDERS_VALUE } = {}) {
            if (!exampleWordMap || exampleWordMap.size === 0) return [];
            const normalizedFilter = filterTerm.toLowerCase().trim();
            const matches = [];
            const seen = new Set();

            allCards.forEach(card => {
                if (!cardMatchesFolder(card, folderFilter)) return;
                const candidateSet = new Set([
                    ...normalizeWordVariants(card.back),
                    ...normalizeWordVariants(card.front)
                ].filter(Boolean));
                const candidates = Array.from(candidateSet);

                candidates.forEach(candidate => {
                    const entries = exampleWordMap.get(candidate);
                    if (!entries || entries.length === 0) return;
                    entries.forEach(entry => {
                        if (sourceFilter !== '__all__' && entry.sourceId !== sourceFilter) return;
                        const wordKey = entry.word ? entry.word.toLowerCase() : '';
                        const dedupeKey = `${card.id}__${entry.sourceId}__${entry.entryId || wordKey}`;
                        if (seen.has(dedupeKey)) return;
                        seen.add(dedupeKey);
                        const matchesFilter = !normalizedFilter || [
                            card.front || '',
                            card.back || '',
                            entry.word || ''
                        ].some(value => value.toLowerCase().includes(normalizedFilter));
                        if (!matchesFilter) return;
                        matches.push({
                            card,
                            word: entry.word,
                            sourceId: entry.sourceId,
                            entryId: entry.entryId,
                            examples: [...entry.examples]
                        });
                    });
                });
            });

            matches.sort((a, b) => getCreatedAtTime(b.card.createdAt) - getCreatedAtTime(a.card.createdAt));
            return matches;
        }

        function renderExampleMatches(matches, { resetVisibleCount = true } = {}) {
            currentExampleMatches = matches || [];
            const container = document.getElementById('example-matches-container');
            const emptyState = document.getElementById('example-matches-empty');
            const summary = document.getElementById('example-match-summary');
            const showMoreBtn = document.getElementById('example-match-show-more');
            if (!container || !emptyState || !summary) return;

            if (resetVisibleCount) {
                exampleMatchesVisibleCount = EXAMPLE_MATCH_PAGE_SIZE;
            }

            container.innerHTML = '';
            if (!currentExampleMatches || currentExampleMatches.length === 0) {
                emptyState.classList.remove('hidden');
                summary.textContent = '';
                if (showMoreBtn) showMoreBtn.classList.add('hidden');
                return;
            }

            emptyState.classList.add('hidden');
            const totalMatches = currentExampleMatches.length;
            exampleMatchesVisibleCount = Math.min(exampleMatchesVisibleCount, totalMatches);
            const visibleMatches = currentExampleMatches.slice(0, exampleMatchesVisibleCount);
            const uniqueCards = new Set(currentExampleMatches.map(m => m.card.id)).size;
            const uniqueSources = new Set(currentExampleMatches.map(m => m.sourceId)).size;
            const hiddenCount = Math.max(totalMatches - visibleMatches.length, 0);
            summary.textContent = `Found ${totalMatches} match${totalMatches === 1 ? '' : 'es'} across ${uniqueCards} card${uniqueCards === 1 ? '' : 's'} from ${uniqueSources} source${uniqueSources === 1 ? '' : 's'}.`;
            if (hiddenCount > 0) {
                summary.textContent += ` Showing ${visibleMatches.length} of ${totalMatches}.`;
            }

            visibleMatches.forEach(match => {
                const existingSentences = normalizeSentencesFromBeispiel(match.card.beispiel);
                const existingPreview = existingSentences.length
                    ? `Existing Beispiel: ${escapeHtml(existingSentences.slice(0, 2).join('  '))}${existingSentences.length > 2 ? ' ...' : ''}`
                    : 'No Beispiel on this card yet.';
                const folderMeta = match.card.folderId ? folders.find(f => f.id === match.card.folderId) : null;
                const folderLabel = folderMeta && folderMeta.name ? folderMeta.name : 'No Folder';
                const frontPreview = formatDuplicateDisplayValue(match.card.front);
                const backPreview = formatDuplicateDisplayValue(match.card.back);
                const frontLabel = frontPreview !== '' ? frontPreview : 'No front';
                const backLabel = backPreview !== '' ? backPreview : 'No back';
                const item = document.createElement('div');
                item.className = 'bg-[#0f0f0f] border border-gray-800 rounded-lg p-4';
                item.innerHTML = `
                    <div class="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-3">
                        <div class="flex-1">
                            <div class="flex items-center gap-2 example-word-row">
                                <span class="font-semibold text-lg text-white example-copyable cursor-pointer" data-text="${escapeHtml(match.word)}" data-copy-type="word">${escapeHtml(match.word)}</span>
                                <button class="example-copy-btn text-gray-400 hover:text-white mt-0.5" title="Copy word" data-text="${escapeHtml(match.word)}" data-copy-type="word"><i class="fas fa-copy"></i></button>
                            </div>
                            <p class="text-xs text-gray-400 mt-1">Front: ${escapeHtml(frontLabel)}</p>
                            <p class="text-xs text-gray-500 mt-1">Back: ${escapeHtml(backLabel)}  Source: ${escapeHtml(getExampleSourceLabel(match.sourceId))}  Folder: ${escapeHtml(folderLabel)}</p>
                            <p class="text-xs text-gray-500 mt-1">${existingPreview}</p>
                        </div>
                        <div class="flex items-center gap-2">
                            <button class="btn btn-success btn-sm example-apply-btn" data-card-id="${match.card.id}" data-word="${encodeURIComponent(match.word)}" data-source-id="${match.sourceId}" data-entry-id="${escapeHtml(match.entryId || '')}">
                                <i class="fas fa-plus"></i> Add Beispiele
                            </button>
                        </div>
                    </div>
                    <div class="mt-3 space-y-1 text-sm text-gray-200">
                        ${match.examples.map(line => `
                            <div class="flex items-start gap-2 example-line" data-text="${escapeHtml(line)}">
                                <button class="example-copy-btn text-gray-400 hover:text-white mt-0.5" title="Copy sentence" data-text="${escapeHtml(line)}"><i class="fas fa-copy"></i></button>
                                <span class="leading-6 flex-1 example-copyable cursor-pointer" data-text="${escapeHtml(line)}">${escapeHtml(line)}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
                container.appendChild(item);
            });

            if (showMoreBtn) {
                if (hiddenCount > 0) {
                    showMoreBtn.textContent = `Show more (${hiddenCount} left)`;
                    showMoreBtn.classList.remove('hidden');
                    showMoreBtn.disabled = false;
                } else {
                    showMoreBtn.classList.add('hidden');
                }
            }
        }

        function handleShowMoreExampleMatches() {
            if (!currentExampleMatches || currentExampleMatches.length === 0) return;
            exampleMatchesVisibleCount = Math.min(
                currentExampleMatches.length,
                exampleMatchesVisibleCount + EXAMPLE_MATCH_PAGE_SIZE
            );
            renderExampleMatches(currentExampleMatches, { resetVisibleCount: false });
        }

        async function refreshExampleMatches({ forceReloadLibrary = false } = {}) {
            const filterInput = document.getElementById('example-match-filter');
            const sourceFilterSelect = document.getElementById('example-source-filter');
            const folderFilterSelect = document.getElementById('example-folder-filter');
            const filterTerm = filterInput ? filterInput.value : '';
            const sourceFilter = sourceFilterSelect ? sourceFilterSelect.value : '__all__';
            const folderFilterRaw = folderFilterSelect ? folderFilterSelect.value : currentExampleFolderId;
            const folderFilter = folderFilterRaw || ALL_FOLDERS_VALUE;
            currentExampleFolderId = folderFilter;

            const { loaded } = await loadExampleLibrary(forceReloadLibrary);
            if (!loaded) {
                renderExampleMatches([]);
                return;
            }

            const matches = buildExampleMatches({ filterTerm, sourceFilter, folderFilter });
            renderExampleMatches(matches);
        }

        async function handleApplyExamplesToCard(cardId, encodedWord, sourceId, entryId = null) {
            if (!userId || !cardsCollectionRef) {
                showNotification('Sign in to add Beispiele.', 'error');
                return;
            }
            const decodedWord = decodeURIComponent(encodedWord || '');
            const normalizedKey = normalizeWordForLookup(decodedWord);
            if (!normalizedKey) {
                showNotification('Missing word for Beispiele.', 'error');
                return;
            }
            const card = allCards.find(c => c.id === cardId);
            if (!card) {
                showNotification('Card not found.', 'error');
                return;
            }
            const entries = exampleWordMap.get(normalizedKey) || [];
            const match = entries.find(entry => entry.entryId === entryId) || entries.find(entry => entry.sourceId === sourceId) || entries[0];
            if (!match) {
                showNotification('No Beispiele found for this word.', 'error');
                return;
            }

            const existingSentences = normalizeSentencesFromBeispiel(card.beispiel);
            const incoming = match.examples || [];
            const combined = [...existingSentences];
            incoming.forEach(sentence => {
                const normalized = sentence.trim().toLowerCase();
                const alreadyExists = combined.some(s => s.trim().toLowerCase() === normalized);
                if (!alreadyExists) combined.push(sentence);
            });

            if (combined.length === existingSentences.length) {
                const wordToCopy = match.word || decodedWord || '';
                if (wordToCopy) {
                    copyPlainTextToClipboard(wordToCopy);
                }
                showNotification('Card already contains these Beispiele. Word copied.', 'success');
                return;
            }

            const newBeispiel = formatMultiLine(combined.join('\n'));
            const baseForSpeech = card.back || card.front || '';
            const newBeispielSpeech = resolveBeispielSpeechValue(baseForSpeech, newBeispiel, card.beispielSpeech);

            try {
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/cards`, cardId);
                await updateDoc(docRef, { beispiel: newBeispiel, beispielSpeech: newBeispielSpeech });
                card.beispiel = newBeispiel;
                card.beispielSpeech = newBeispielSpeech;
                const wordToCopy = match.word || decodedWord || '';
                if (wordToCopy) {
                    copyPlainTextToClipboard(wordToCopy);
                }
                showNotification('Beispiele added to card and removed from library. Word copied.', 'success');
                await consumeExamplesFromLibrary({ sourceId, entryId: match.entryId, word: match.word }, incoming);
                await removeWordFromAllExampleSources(normalizedKey);
                filterAndRenderCards();
                await refreshExampleMatches({ forceReloadLibrary: true });
            } catch (error) {
                console.error('Failed to add Beispiele to card:', error);
                showNotification('Failed to update card with Beispiele.', 'error');
            }
        }

        async function consumeExamplesFromLibrary(matchMeta, usedExamples = []) {
            if (!matchMeta || !matchMeta.sourceId) return;
            const source = exampleLibrarySources.find(src => src.id === matchMeta.sourceId);
            if (!source || !Array.isArray(source.entries)) return;
            const normalizedUsed = new Set((usedExamples || []).map(val => String(val).trim().toLowerCase()));
            const targetIndex = source.entries.findIndex(entry => {
                if (!entry) return false;
                if (entry.__metaId && matchMeta.entryId && entry.__metaId === matchMeta.entryId) return true;
                if (matchMeta.entryId) return false;
                return (entry.word || '').trim().toLowerCase() === (matchMeta.word || '').trim().toLowerCase();
            });
            if (targetIndex === -1) return;
            const target = source.entries[targetIndex];
            const preservedKeys = Object.keys(target).filter(key => !/^example\d*$/i.test(key));
            const remainingExamples = collectExamplesFromEntry(target).filter(sentence => !normalizedUsed.has(sentence.trim().toLowerCase()));
            const metaId = target.__metaId;
            const rebuilt = {};
            preservedKeys.forEach(key => {
                rebuilt[key] = target[key];
            });
            remainingExamples.forEach((sentence, idx) => {
                const field = idx === 0 ? 'example' : `example${idx + 1}`;
                rebuilt[field] = sentence;
            });
            Object.keys(target).forEach(key => { delete target[key]; });
            Object.assign(target, rebuilt);
            if (metaId) {
                Object.defineProperty(target, '__metaId', { value: metaId, enumerable: false, writable: true });
            }
            if (remainingExamples.length === 0) {
                source.entries.splice(targetIndex, 1);
            }
            await persistExampleLibrary();
        }

        async function removeWordFromAllExampleSources(normalizedWord) {
            if (!normalizedWord) return;
            let changed = false;
            exampleLibrarySources.forEach(source => {
                if (!Array.isArray(source.entries)) return;
                const filtered = source.entries.filter(entry => normalizeWordForLookup(entry.word) !== normalizedWord);
                if (filtered.length !== source.entries.length) {
                    source.entries = filtered;
                    changed = true;
                }
            });
            if (changed) {
                await persistExampleLibrary();
            }
        }

        async function handleExampleUpload(event, sourceId) {
            const input = event?.target;
            const file = (input?.files || [])[0];
            if (!file) return;
            if (!userId || !db || !exampleLibraryDocRef) {
                showNotification('Sign in to upload vocab JSON to your account.', 'error', 3000);
                if (input) input.value = '';
                return;
            }
            const slot = getSourceSlotMeta(sourceId);
            const label = slot ? slot.label : (sourceId || 'vocab');
            const id = sourceId || generateExampleSourceId(file.name);

            setExampleLibraryStatus(`Reading ${label} JSON...`);

            try {
                const text = await file.text();
                const payload = JSON.parse(text);
                if (!Array.isArray(payload)) {
                    showNotification(`${file.name} is not a JSON array.`, 'error', 4000);
                    setExampleLibraryStatus(`Upload failed for ${label}. File must be a JSON array.`);
                    if (input) input.value = '';
                    return;
                }
                const entries = decorateExampleEntries(payload, id);
                const fileName = file.name || (slot ? slot.defaultFileName : `${label}.json`);
                const newSource = { id, label, fileName, entries };
                const existingIndex = exampleLibrarySources.findIndex(item => item.id === id);
                if (existingIndex > -1) {
                    exampleLibrarySources[existingIndex] = newSource;
                } else {
                    exampleLibrarySources.push(newSource);
                }
                await persistExampleLibrary();
                await loadExampleLibrary(true);
                await refreshExampleMatches({ forceReloadLibrary: false });
                showNotification(`Loaded ${label} vocab JSON.`, 'success', 2000);
                setExampleLibraryStatus(`Loaded ${label}. Click Find Matches to search.`);
            } catch (error) {
                console.error(`Failed to read ${file.name}`, error);
                showNotification(`Could not read ${file.name}.`, 'error', 3500);
                setExampleLibraryStatus(`Upload failed for ${label}.`);
            } finally {
                if (input) input.value = '';
            }
        }

        async function handleDownloadExampleLibrary(sourceId = null) {
            const sourcesToDownload = sourceId
                ? exampleLibrarySources.filter(src => src.id === sourceId)
                : exampleLibrarySources;
            if (!sourcesToDownload.length) {
                const label = sourceId ? resolveSourceLabel(sourceId) : 'vocab';
                showNotification(`Upload ${label} JSON first.`, 'error', 2200);
                return;
            }
            const sources = sourcesToDownload.map(src => {
                const baseName = resolveSourceLabel(src) || 'examples';
                const safeBase = baseName.replace(/[^a-z0-9._-]+/gi, '_');
                const resolvedName = (src.fileName && src.fileName.endsWith('.json')) ? src.fileName : `${safeBase}.json`;
                return {
                    fileName: resolvedName,
                    label: resolveSourceLabel(src),
                    entries: (src.entries || []).map(stripExampleMetadata)
                };
            });

            if (sources.length === 1) {
                const src = sources[0];
                const content = JSON.stringify(src.entries, null, 2);
                const normalizedContent = content.endsWith('\n') ? content : `${content}\n`;
                const blob = new Blob([normalizedContent], { type: 'application/json;charset=utf-8' });
                triggerBlobDownload(blob, src.fileName);
                showNotification(`Downloaded updated ${src.label} JSON.`, 'success', 1800);
                return;
            }

            const zip = new JSZip();
            sources.forEach(src => {
                const content = JSON.stringify(src.entries, null, 2);
                const normalizedContent = content.endsWith('\n') ? content : `${content}\n`;
                zip.file(src.fileName, normalizedContent);
            });
            const blob = await zip.generateAsync({ type: 'blob' });
            triggerBlobDownload(blob, 'example-library.zip');
            showNotification('Downloaded updated vocab library (.zip).', 'success', 1800);
        }



        function restoreFolderPreference() {
            if (hasRestoredFolderPreference) return;
            hasRestoredFolderPreference = true;
            try {
                const storedValue = localStorage.getItem(FOLDER_STORAGE_KEY);
                if (!storedValue) return;
                if (storedValue === NO_FOLDER_VALUE) {
                    currentFolderId = null;
                    return;
                }
                const exists = folders.some(folder => folder.id === storedValue);
                currentFolderId = exists ? storedValue : null;
            } catch (error) {
                console.warn('Failed to restore folder preference:', error);
            }
        }

        function persistFolderPreference() {
            try {
                localStorage.setItem(FOLDER_STORAGE_KEY, currentFolderId || NO_FOLDER_VALUE);
            } catch (error) {
                console.warn('Failed to persist folder preference:', error);
            }
        }

        function ensureCurrentFolderIsValid() {
            if (!currentFolderId) return;
            const exists = folders.some(folder => folder.id === currentFolderId);
            if (!exists) {
                currentFolderId = null;
                persistFolderPreference();
            }
        }

        function updateFolderSelection(value, { persist = true, updateSelect = true } = {}) {
            const normalized = value === NO_FOLDER_VALUE ? null : value;
            const previous = currentFolderId;
            currentFolderId = normalized;
            const changed = previous !== currentFolderId;
            if (persist && changed) persistFolderPreference();
            if (updateSelect) {
                const folderSelect = document.getElementById('folder-select');
                if (folderSelect) {
                    const targetValue = normalized != null ? normalized : NO_FOLDER_VALUE;
                    if (folderSelect.value !== targetValue) {
                        folderSelect.value = targetValue;
                    }
                }
            }
            updateFolderDeleteButtonState();
            return changed;
        }

        function getCurrentFolderMeta() {
            if (!currentFolderId) return null;
            return folders.find(folder => folder.id === currentFolderId) || null;
        }

        function getSelectedFolderDetails() {
            const meta = getCurrentFolderMeta();
            if (meta) {
                return { id: meta.id, name: meta.name || null };
            }
            if (!currentFolderId) {
                return { id: null, name: null };
            }
            const folderSelect = document.getElementById('folder-select');
            if (folderSelect) {
                const option = Array.from(folderSelect.options).find(opt => opt.value === currentFolderId);
                if (option) {
                    const baseName = option.dataset && option.dataset.folderName
                        ? option.dataset.folderName
                        : (option.textContent || null);
                    return { id: currentFolderId, name: baseName };
                }
            }
            return { id: currentFolderId, name: null };
        }

        function updateFolderDeleteButtonState() {
            const deleteBtn = document.getElementById('delete-folder-btn');
            if (!deleteBtn) return;
            const details = getSelectedFolderDetails();
            const hasFolder = details && details.id;
            deleteBtn.disabled = !hasFolder;
        }

        function resetPendingFolderDeletion() {
            pendingFolderDeleteId = null;
            pendingFolderDeleteName = '';
            pendingFolderDeleteCount = 0;
        }

        function openDeleteFolderModal() {
            const details = getSelectedFolderDetails();
            if (!details || !details.id) {
                showNotification('Select a folder to delete.', 'error');
                return;
            }

            const counts = getFolderCardCounts();
            pendingFolderDeleteId = details.id;
            pendingFolderDeleteName = (details.name && details.name.trim()) ? details.name.trim() : 'Untitled Folder';
            pendingFolderDeleteCount = Number.isFinite(counts[details.id]) ? counts[details.id] : 0;

            const summary = document.getElementById('delete-folder-summary');
            if (summary) {
                const folderLabel = pendingFolderDeleteName;
                if (pendingFolderDeleteCount > 0) {
                    const cardLabel = pendingFolderDeleteCount === 1 ? '1 card' : `${pendingFolderDeleteCount} cards`;
                    summary.textContent = `Deleting "${folderLabel}" removes the folder and moves ${cardLabel} to the Deleted section so you can restore them later.`;
                } else {
                    summary.textContent = `Deleting "${folderLabel}" removes the folder. No cards are currently assigned to it.`;
                }
            }

            const modal = document.getElementById('delete-folder-modal');
            if (modal) modal.classList.remove('hidden');
        }

        function closeDeleteFolderModal() {
            const modal = document.getElementById('delete-folder-modal');
            if (modal) modal.classList.add('hidden');
            resetPendingFolderDeletion();
        }

        function createSelectionCheckbox(container, text, value, { disabled = false } = {}) {
            if (!container) return;
            const label = document.createElement('label');
            label.className = 'flex items-center space-x-2 text-gray-300 py-1';
            if (disabled) {
                label.classList.add('opacity-50', 'cursor-not-allowed');
            }
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.value = value;
            input.disabled = disabled;
            input.className = 'form-checkbox h-4 w-4 text-blue-500 bg-gray-700 border-gray-600 rounded';
            const span = document.createElement('span');
            span.textContent = text;
            label.appendChild(input);
            label.appendChild(span);
            container.appendChild(label);
        }

        function renderFolderOptions() {
            const folderSelect = document.getElementById('folder-select');
            if (!folderSelect) return;

            const selectedValue = (currentFolderId != null ? currentFolderId : NO_FOLDER_VALUE);
            folderSelect.innerHTML = '';
            const counts = getFolderCardCounts();

            const noFolderOption = document.createElement('option');
            noFolderOption.value = NO_FOLDER_VALUE;
            noFolderOption.dataset.folderName = '';
            noFolderOption.textContent = formatFolderLabel('No Folder', counts[NO_FOLDER_VALUE]);
            folderSelect.appendChild(noFolderOption);

            const sortedFolders = [...folders].sort((a, b) => {
                const createdAtDiff = getCreatedAtTime(b.createdAt) - getCreatedAtTime(a.createdAt);
                if (createdAtDiff !== 0) {
                    return createdAtDiff;
                }
                const nameA = (a.name || '').toLowerCase();
                const nameB = (b.name || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });

            sortedFolders.forEach(folder => {
                const option = document.createElement('option');
                option.value = folder.id;
                const baseName = folder.name || 'Untitled Folder';
                option.dataset.folderName = baseName;
                option.textContent = formatFolderLabel(baseName, counts[folder.id]);
                folderSelect.appendChild(option);
            });

            if (currentFolderId && !sortedFolders.some(folder => folder.id === currentFolderId)) {
                updateFolderSelection(NO_FOLDER_VALUE, { updateSelect: false });
            }

            folderSelect.value = (currentFolderId != null ? currentFolderId : NO_FOLDER_VALUE);
            const previousViewFolder = currentViewFolderId;
            const previousExampleFolder = currentExampleFolderId;
            renderViewFolderOptions();
            renderReviewFolderOptions();
            renderExampleFolderOptions();
            if (currentViewFolderId !== previousViewFolder) {
                filterAndRenderCards();
            }
            if (currentExampleFolderId !== previousExampleFolder) {
                refreshExampleMatches({ forceReloadLibrary: false });
            }
            updateReviewDateSelector();
            populateDuplicatesFolderFilter();
            updateFolderDeleteButtonState();
        }

        function openFolderModal() {
            const modal = document.getElementById('folder-modal');
            const input = document.getElementById('folder-name-input');
            if (!modal || !input) return;

            input.value = '';
            modal.classList.remove('hidden');
            setTimeout(() => input.focus(), 0);
        }

        function closeFolderModal() {
            const modal = document.getElementById('folder-modal');
            if (!modal) return;
            modal.classList.add('hidden');
        }

        async function handleCreateFolder() {
            const input = document.getElementById('folder-name-input');
            if (!input) return;

            const name = input.value.trim();
            if (!name) {
                showNotification('Please enter a folder name.');
                return;
            }
            if (!userId || !foldersCollectionRef) {
                showNotification('Not connected.');
                return;
            }

            const duplicate = folders.some(folder => (folder.name || '').toLowerCase() === name.toLowerCase());
            if (duplicate) {
                showNotification('A folder with this name already exists.');
                return;
            }

            try {
                const docRef = await addDoc(foldersCollectionRef, {
                    name,
                    createdAt: new Date().toISOString()
                });
                const selectionChanged = updateFolderSelection(docRef.id, { updateSelect: false });
                const folderSelect = document.getElementById('folder-select');
                if (folderSelect) {
                    let option = Array.from(folderSelect.options).find(opt => opt.value === docRef.id);
                    const optionLabel = formatFolderLabel(name, 0);
                    if (!option) {
                        option = document.createElement('option');
                        option.value = docRef.id;
                        option.dataset.folderName = name;
                        option.textContent = optionLabel;
                        folderSelect.appendChild(option);
                    } else {
                        option.dataset.folderName = name;
                        option.textContent = optionLabel;
                    }
                    folderSelect.value = docRef.id;
                }
                if (selectionChanged) {
                    filterAndRenderCards();
                }
                closeFolderModal();
                showNotification('Folder created successfully.', 'success');
            } catch (error) {
                console.error('Failed to create folder:', error);
                showNotification('Could not create folder.');
            }
        }

        function cardMatchesFolder(card, folderValue) {
            if (folderValue === ALL_FOLDERS_VALUE) return true;
            if (!folderValue || folderValue === NO_FOLDER_VALUE) {
                return !card.folderId;
            }
            return card.folderId === folderValue;
        }

        function formatFolderLabel(baseName, count) {
            const safeName = baseName && baseName.trim().length > 0 ? baseName : 'Untitled Folder';
            const cardCount = Number.isFinite(count) ? count : 0;
            return `${safeName} (${cardCount})`;
        }

        function getFolderCardCounts() {
            const counts = {
                [ALL_FOLDERS_VALUE]: allCards.length,
                [NO_FOLDER_VALUE]: 0
            };
            folders.forEach(folder => {
                counts[folder.id] = 0;
            });
            allCards.forEach(card => {
                const folderKey = card.folderId ? card.folderId : NO_FOLDER_VALUE;
                if (!Number.isFinite(counts[folderKey])) {
                    counts[folderKey] = 0;
                }
                counts[folderKey] += 1;
            });
            return counts;
        }

        function buildFolderSelectOptions() {
            const counts = getFolderCardCounts();
            const options = [
                { value: ALL_FOLDERS_VALUE, label: formatFolderLabel('All Folders', counts[ALL_FOLDERS_VALUE]) },
                { value: NO_FOLDER_VALUE, label: formatFolderLabel('No Folder', counts[NO_FOLDER_VALUE]) }
            ];
            const sortedFolders = [...folders].sort((a, b) => {
                const createdAtDiff = getCreatedAtTime(b.createdAt) - getCreatedAtTime(a.createdAt);
                if (createdAtDiff !== 0) {
                    return createdAtDiff;
                }
                const nameA = (a.name || '').toLowerCase();
                const nameB = (b.name || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });
            sortedFolders.forEach(folder => {
                options.push({ value: folder.id, label: formatFolderLabel(folder.name || 'Untitled Folder', counts[folder.id]) });
            });
            return options;
        }

        function populateFolderSelect(selectElement, currentValue) {
            if (!selectElement) return currentValue || ALL_FOLDERS_VALUE;
            const options = buildFolderSelectOptions();
            const fragment = document.createDocumentFragment();
            let hasCurrentValue = false;
            options.forEach(option => {
                const optionEl = document.createElement('option');
                optionEl.value = option.value;
                optionEl.textContent = option.label;
                fragment.appendChild(optionEl);
                if (option.value === currentValue) {
                    hasCurrentValue = true;
                }
            });
            selectElement.innerHTML = '';
            selectElement.appendChild(fragment);
            const valueToApply = hasCurrentValue ? currentValue : ALL_FOLDERS_VALUE;
            selectElement.value = valueToApply;
            return valueToApply;
        }

        function renderReviewFolderOptions() {
            const selector = document.getElementById('review-folder-selector');
            currentReviewFolderId = populateFolderSelect(selector, currentReviewFolderId);
        }

        function renderViewFolderOptions() {
            const selector = document.getElementById('view-folder-selector');
            currentViewFolderId = populateFolderSelect(selector, currentViewFolderId);
        }

        function renderExampleFolderOptions() {
            const selector = document.getElementById('example-folder-filter');
            currentExampleFolderId = populateFolderSelect(selector, currentExampleFolderId);
        }

        function buildReviewSessionId(selectedDate, folderValue, missingOnly = false) {
            const datePart = selectedDate === 'all' ? 'date_all' : `date_${selectedDate}`;
            let folderPart = 'folder_none';
            if (folderValue === ALL_FOLDERS_VALUE) {
                folderPart = 'folder_all';
            } else if (folderValue && folderValue !== NO_FOLDER_VALUE) {
                folderPart = `folder_${folderValue}`;
            }
            const missingPart = missingOnly ? '__missing_beispiel' : '';
            return `${datePart}__${folderPart}${missingPart}`;
        }

        function parseTsvLine(line) {
            if (!line) return [''];

            const fields = [];
            let current = '';
            let i = 0;
            let inQuotes = false;

            while (i < line.length) {
                const char = line[i];

                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        current += '"';
                        i += 2;
                        continue;
                    }
                    inQuotes = !inQuotes;
                    i += 1;
                    continue;
                }

                if (char === '\t' && !inQuotes) {
                    fields.push(current);
                    current = '';
                    i += 1;
                    continue;
                }

                current += char;
                i += 1;
            }

            fields.push(current);
            return fields;
        }

        function decodeLegacyImageFront(value) {
            if (typeof value !== 'string') return null;
            const trimmed = value.trim();
            if (!trimmed) return null;

            if (/^<img\s+[^>]*>$/.test(trimmed)) {
                return trimmed;
            }

            const candidates = new Set();
            const enqueue = (input) => {
                if (typeof input !== 'string') return;
                const normalized = input.trim();
                if (!normalized) return;
                candidates.add(normalized);
            };

            const stripOuterQuotes = (input) => {
                if ((input.startsWith('"') && input.endsWith('"')) || (input.startsWith("'") && input.endsWith("'"))) {
                    return input.slice(1, -1);
                }
                return input;
            };

            const attemptJsonParse = (input) => {
                if (typeof input !== 'string') return;
                try {
                    const parsed = JSON.parse(input);
                    if (typeof parsed === 'string') {
                        enqueue(parsed);
                    }
                } catch (error) {
                    if (input.startsWith("'") && input.endsWith("'")) {
                        try {
                            const converted = `"${input.slice(1, -1).replace(/"/g, '\\"')}"`;
                            const parsed = JSON.parse(converted);
                            if (typeof parsed === 'string') {
                                enqueue(parsed);
                            }
                        } catch (innerError) { /* ignore */ }
                    }
                }
            };

            enqueue(trimmed);
            const withoutOuterQuotes = stripOuterQuotes(trimmed);
            enqueue(withoutOuterQuotes);
            attemptJsonParse(trimmed);
            attemptJsonParse(withoutOuterQuotes);

            const existingCandidates = Array.from(candidates);
            existingCandidates.forEach(candidate => {
                const unescaped = candidate
                    .replace(/""/g, '"')
                    .replace(/\\"/g, '"')
                    .replace(/\\'/g, "'");
                enqueue(unescaped);
            });

            if (typeof document !== 'undefined') {
                const decoder = document.createElement('textarea');
                Array.from(candidates).forEach(candidate => {
                    decoder.innerHTML = candidate;
                    const decoded = decoder.value.trim();
                    if (decoded && decoded !== candidate) {
                        enqueue(decoded);
                    }
                });
            }

            for (const candidate of candidates) {
                if (/^<img\s+[^>]*>$/.test(candidate)) {
                    let normalized = candidate;
                    if (normalized.includes('""')) {
                        normalized = normalized.replace(/""/g, '"');
                    }
                    normalized = normalized.replace(/\s+\/>$/, '>');
                    if (typeof document !== 'undefined') {
                        const wrapper = document.createElement('div');
                        wrapper.innerHTML = normalized;
                        const imgEl = wrapper.querySelector('img');
                        if (imgEl) {
                            normalized = imgEl.outerHTML.replace(/\s+\/>$/, '>');
                        }
                    }
                    return normalized;
                }
            }

            return null;
        }

        function getLegacyFrontCandidates() {
            return allCards
                .map(card => {
                    const decoded = decodeLegacyImageFront(card.front);
                    return decoded && decoded !== card.front ? { card, decoded } : null;
                })
                .filter(Boolean);
        }

        function buildLegacyCardEntry(card, decodedFront) {
            const entry = document.createElement('article');
            entry.className = 'legacy-card-entry';

            const meta = document.createElement('div');
            meta.className = 'legacy-card-meta';
            const folderName = resolveFolderName(card) || 'No folder';
            const createdAtLabel = card.createdAt ? formatDuplicateTimestamp(card.createdAt) : 'Unknown date';
            meta.innerHTML = `
                <span>ID: ${escapeHtml(card.id)}</span>
                <span>Folder: ${escapeHtml(folderName)}</span>
                <span>${escapeHtml(createdAtLabel)}</span>
            `;
            entry.appendChild(meta);

            const storedBlock = document.createElement('div');
            storedBlock.innerHTML = `
                <p class="legacy-field-label mb-2">Stored Front</p>
                <pre class="legacy-code-block">${escapeHtml(card.front || '')}</pre>
            `;
            entry.appendChild(storedBlock);

            const previewWrapper = document.createElement('div');
            previewWrapper.innerHTML = `<p class="legacy-field-label mb-2">Fixed Preview</p>`;
            const previewBox = document.createElement('div');
            previewBox.className = 'legacy-preview-box';
            previewBox.innerHTML = decodedFront;
            previewWrapper.appendChild(previewBox);
            entry.appendChild(previewWrapper);

            if (card.back) {
                const backBlock = document.createElement('div');
                backBlock.innerHTML = `
                    <p class="legacy-field-label mb-2">Back</p>
                    <div class="legacy-field-value">${escapeHtml(card.back)}</div>
                `;
                entry.appendChild(backBlock);
            }

            if (card.translation) {
                const translationBlock = document.createElement('div');
                translationBlock.innerHTML = `
                    <p class="legacy-field-label mb-2">Translation</p>
                    <div class="legacy-field-value">${escapeHtml(card.translation)}</div>
                `;
                entry.appendChild(translationBlock);
            }

            const actions = document.createElement('div');
            actions.className = 'flex flex-wrap gap-2';
            const fixBtn = document.createElement('button');
            fixBtn.className = 'btn btn-primary btn-sm legacy-fix-btn';
            fixBtn.dataset.cardId = card.id;
            fixBtn.type = 'button';
            fixBtn.innerHTML = '<i class="fas fa-wrench"></i> Fix Card';
            actions.appendChild(fixBtn);
            entry.appendChild(actions);

            return entry;
        }

        function renderLegacyFrontsView() {
            const container = document.getElementById('legacy-container');
            const summary = document.getElementById('legacy-summary');
            const emptyState = document.getElementById('legacy-empty-state');
            const fixAllBtn = document.getElementById('legacy-fix-all-btn');
            if (!container || !summary || !emptyState || !fixAllBtn) return;

            container.innerHTML = '';
            const candidates = getLegacyFrontCandidates();
            const count = candidates.length;

            if (count === 0) {
                summary.textContent = 'All cards are using the updated front format.';
                emptyState.classList.remove('hidden');
                fixAllBtn.disabled = true;
                return;
            }

            summary.textContent = `Found ${count} card${count === 1 ? '' : 's'} with legacy image fronts.`;
            emptyState.classList.add('hidden');
            fixAllBtn.disabled = isFixingLegacyFronts;

            const sorted = [...candidates].sort((a, b) => {
                return getCreatedAtTime(b.card.createdAt) - getCreatedAtTime(a.card.createdAt);
            });
            sorted.forEach(({ card, decoded }) => {
                container.appendChild(buildLegacyCardEntry(card, decoded));
            });
        }

        function updateLegacyBadge() {
            const badge = document.getElementById('legacy-count-badge');
            if (!badge) return;
            const count = getLegacyFrontCandidates().length;
            if (count > 0) {
                badge.textContent = count > 99 ? '99+' : String(count);
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
                badge.textContent = '';
            }
            const fixAllBtn = document.getElementById('legacy-fix-all-btn');
            if (fixAllBtn) {
                fixAllBtn.disabled = count === 0 || isFixingLegacyFronts;
            }
        }

        function prepareForSoundTag(text) { 
            if (!text) return ''; 
            return text.trim(); 
        }

        function escapeHtml(value) {
            if (value === null || value === undefined) return '';
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function sanitizeFileName(name, fallback = 'folder') {
            const base = (name || '').toString().trim().replace(/[\\/:*?"<>|]/g, '_');
            const cleaned = base.replace(/\s+/g, ' ').trim();
            return cleaned || fallback;
        }

        function ensureUniqueName(baseName, usedSet) {
            const used = usedSet || new Set();
            let candidate = baseName;
            let counter = 2;
            while (used.has(candidate)) {
                candidate = `${baseName}-${counter}`;
                counter += 1;
            }
            used.add(candidate);
            return candidate;
        }
        
        function formatMultiLine(text) {
            if (!text) return '';
            return text
                .split(/\r?\n/)
                .map(line => line.trim())
                .filter(line => line.length > 0)
                .join('<br>');
        }

        function unformatMultiLine(text) {
            return text.replace(/\s*<br\s*\/?>\s*/gi, '\n').trim();
        }

        function buildBeispielSpeech(backText, beispielText) {
            const tagBase = prepareForSoundTag(backText);
            if (!tagBase) return '';

            const normalizedBeispiel = unformatMultiLine(beispielText || '');
            const sentences = normalizedBeispiel
                ? normalizedBeispiel.split(/\r?\n/).map(line => line.trim()).filter(line => line.length > 0)
                : [];

            if (sentences.length <= 1) {
                return `[sound:s_${tagBase}.mp3]`;
            }

            const soundTags = sentences.map((_, index) => {
                const suffix = index === 0 ? '' : index + 1;
                return `[sound:s_${tagBase}${suffix}.mp3]`;
            });

            return ` <br> ${soundTags.join('')}`;
        }

        function resolveBeispielSpeechValue(backText, beispielText, storedValue) {
            const fallback = buildBeispielSpeech(backText, beispielText);
            const normalizedSentences = normalizeSentencesFromBeispiel(beispielText);
            const requiresBreak = normalizedSentences.length > 1;

            if (isBlank(storedValue)) {
                return fallback;
            }

            const currentValue = String(storedValue);
            const hasLeadingBreak = /^\s*<br\s*\/?>/i.test(currentValue);

            if (requiresBreak && !hasLeadingBreak) {
                return fallback;
            }

            return currentValue;
        }

        function extractSoundTagsFromBeispielSpeech(value) {
            if (!value) return [];
            const normalized = String(value).replace(/\s*<br\s*\/?>\s*/gi, ' ');
            const matches = normalized.match(/\[sound:[^\]]+\]/gi);
            if (!matches) return [];
            return matches.map(tag => tag.trim()).filter(Boolean);
        }

        function normalizeSoundIdentifier(tag) {
            if (!tag) return '';
            const match = /\[sound:([^\]]+)\]/i.exec(tag);
            const inner = match ? match[1] : String(tag);
            return inner.replace(/\.[^.]+$/, '');
        }

        function setBeispielSpeechBoxValue(element, rawValue) {
            if (!element) return;
            const safeValue = rawValue || '';
            element.dataset.raw = safeValue;
            element.textContent = safeValue;
        }

        function getSpeechRawValue(element) {
            if (!element) return '';
            if (element.dataset && element.dataset.raw !== undefined) {
                return element.dataset.raw;
            }
            return element.textContent || '';
        }

        function isBlank(value) {
            if (value == null) return true;
            if (typeof value === 'string') return value.trim() === '';
            return String(value).trim() === '';
        }

        function sanitizeForExport(value, fallback = '', options = {}) {
            const settings = (options && typeof options === 'object') ? options : {};
            const {
                preserveLeadingBr = false,
                preserveSpacingAroundBr = false,
                keepOuterWhitespace = false
            } = settings;

            let text = isBlank(value) ? (fallback != null ? fallback : '') : value;
            if (text == null) text = '';

            let sanitized = String(text).replace(/[\r\n]+/g, '<br>');
            if (preserveSpacingAroundBr) {
                sanitized = sanitized.replace(/<br\s*\/?>/gi, '<br>');
            } else {
                sanitized = sanitized.replace(/\s*(<br\s*\/?>)\s*/gi, '<br>');
            }

            if (!preserveLeadingBr) {
                sanitized = sanitized.replace(/^(<br>)+/, '');
            }
            sanitized = sanitized.replace(/(<br>)+$/, '');
            sanitized = sanitized.replace(/\t/g, ' ');

            return keepOuterWhitespace ? sanitized : sanitized.trim();
        }

        function getCreatedAtTime(value) {
            if (!value) return 0;
            if (typeof value === 'object' && typeof value.seconds === 'number') {
                const millis = value.seconds * 1000;
                const extra = value.nanoseconds ? Math.floor(value.nanoseconds / 1e6) : 0;
                return millis + extra;
            }
            const time = new Date(value).getTime();
            return Number.isFinite(time) ? time : 0;
        }

        function normalizeDuplicateValue(value) {
            if (!value) return '';
            return String(value)
                .replace(/<br\s*\/?>/gi, ' ')
                .replace(/\s+/g, ' ')
                .trim()
                .toLowerCase();
        }

        function createDuplicateKey(card) {
            if (!card) return '';
            const frontKey = normalizeDuplicateValue(card.front);
            const backKey = normalizeDuplicateValue(card.back);
            if (!frontKey && !backKey) return '';
            return `${frontKey}|||${backKey}`;
        }

        function findDuplicateGroups(cards) {
            const groups = new Map();
            cards.forEach(card => {
                const key = createDuplicateKey(card);
                if (!key) return;
                if (!groups.has(key)) {
                    groups.set(key, []);
                }
                groups.get(key).push(card);
            });
            return Array.from(groups.values()).filter(group => group.length > 1);
        }

        function formatDuplicateField(value) {
            if (!value) return '';
            const cleaned = String(value)
                .replace(/<br\s*\/?>/gi, ' ')
                .replace(/\s+/g, ' ')
                .trim();
            return cleaned || '';
        }

        function formatDuplicateTimestamp(value) {
            const time = getCreatedAtTime(value);
            if (!time) return 'Unknown';
            const date = new Date(time);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day} ${hours}:${minutes}`;
        }

        function resolveFolderName(card) {
            if (!card) return 'No folder';
            if (!card.folderId) return 'No folder';
            const folderMeta = folders.find(folder => folder.id === card.folderId);
            if (folderMeta && folderMeta.name) return folderMeta.name;
            if (card.folderName) return card.folderName;
            return `Folder ID: ${card.folderId}`;
        }

        function formatDuplicateDisplayValue(value) {
            if (!value) return '';
            const normalized = unformatMultiLine(String(value));
            return normalized && normalized.trim() ? normalized : '';
        }

        function createDuplicateFieldElement(label, value) {
            const wrapper = document.createElement('div');
            wrapper.className = 'space-y-1';
            const labelEl = document.createElement('p');
            labelEl.className = 'duplicate-field-label';
            labelEl.textContent = label;
            const valueEl = document.createElement('div');
            valueEl.className = 'duplicate-field-value';
            valueEl.textContent = formatDuplicateDisplayValue(value);
            wrapper.append(labelEl, valueEl);
            return wrapper;
        }

        function isDuplicatesViewActive() {
            const view = document.getElementById('duplicates-view');
            return view ? !view.classList.contains('hidden') : false;
        }

        function populateDuplicatesFolderFilter() {
            const filterSelect = document.getElementById('duplicates-folder-filter');
            if (!filterSelect) return;

            const previousValue = filterSelect.value || '__all__';
            filterSelect.innerHTML = '';

            const baseOptions = [
                { value: '__all__', label: 'All folders' },
                { value: '__none__', label: 'No folder' }
            ];
            baseOptions.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.value;
                option.textContent = opt.label;
                filterSelect.appendChild(option);
            });

            const sortedFolders = [...folders].sort((a, b) => {
                const nameA = (a.name || '').toLowerCase();
                const nameB = (b.name || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });
            sortedFolders.forEach(folder => {
                const option = document.createElement('option');
                option.value = folder.id;
                option.textContent = folder.name || 'Untitled Folder';
                filterSelect.appendChild(option);
            });

            const availableValues = Array.from(filterSelect.options).map(opt => opt.value);
            filterSelect.value = availableValues.includes(previousValue) ? previousValue : '__all__';
        }

        function buildDuplicateViewModel({ searchTerm = '', folderFilter = '__all__' } = {}) {
            const baseGroups = findDuplicateGroups(allCards);
            const totalDuplicateCards = baseGroups.reduce((sum, group) => sum + group.length, 0);
            let filteredGroups = baseGroups;

            if (folderFilter === '__none__') {
                filteredGroups = filteredGroups.filter(group => group.some(card => !card.folderId));
            } else if (folderFilter && folderFilter !== '__all__') {
                filteredGroups = filteredGroups.filter(group => group.some(card => card.folderId === folderFilter));
            }

            const normalizedSearch = searchTerm.toLowerCase();
            if (normalizedSearch) {
                filteredGroups = filteredGroups.filter(group => {
                    return group.some(card => {
                        const folderName = resolveFolderName(card).toLowerCase();
                        if (folderName.includes(normalizedSearch)) return true;
                        if ((card.id || '').toLowerCase().includes(normalizedSearch)) return true;
                        return [card.front, card.back, card.translation, card.beispiel, card.speech, card.beispielSpeech]
                            .some(field => (field || '').toLowerCase().includes(normalizedSearch));
                    });
                });
            }

            const filteredCardCount = filteredGroups.reduce((sum, group) => sum + group.length, 0);

            return {
                baseGroups,
                filteredGroups,
                totalDuplicateCards,
                filteredCardCount
            };
        }

        function updateDuplicateBadge() {
            const badge = document.getElementById('duplicate-count-badge');
            if (!badge) return;
            const duplicateGroups = findDuplicateGroups(allCards);
            if (duplicateGroups.length === 0) {
                badge.classList.add('hidden');
                badge.textContent = '';
            } else {
                badge.textContent = duplicateGroups.length.toString();
                badge.classList.remove('hidden');
            }
            if (isDuplicatesViewActive()) {
                renderDuplicatesView();
            }
        }

        function renderDuplicatesView() {
            const container = document.getElementById('duplicates-container');
            const summary = document.getElementById('duplicates-summary');
            const emptyState = document.getElementById('duplicates-empty-state');
            const searchInput = document.getElementById('duplicates-search-input');
            const folderFilterSelect = document.getElementById('duplicates-folder-filter');
            if (!container || !summary || !emptyState) return;

            populateDuplicatesFolderFilter();

            const searchTerm = (searchInput ? searchInput.value : '').trim();
            const folderFilter = folderFilterSelect ? folderFilterSelect.value : '__all__';

            const { baseGroups, filteredGroups, totalDuplicateCards } = buildDuplicateViewModel({ searchTerm, folderFilter });

            if (baseGroups.length === 0) {
                summary.textContent = 'No duplicate cards detected.';
            } else {
                summary.textContent = `${baseGroups.length} duplicate group${baseGroups.length > 1 ? 's' : ''} covering ${totalDuplicateCards} card${totalDuplicateCards > 1 ? 's' : ''}.`;
            }

            container.innerHTML = '';

            if (filteredGroups.length === 0) {
                emptyState.classList.remove('hidden');
                return;
            }
            emptyState.classList.add('hidden');

            filteredGroups
                .slice()
                .sort((a, b) => {
                    if (b.length !== a.length) return b.length - a.length;
                    const newestB = b.reduce((max, card) => Math.max(max, getCreatedAtTime(card.createdAt)), 0);
                    const newestA = a.reduce((max, card) => Math.max(max, getCreatedAtTime(card.createdAt)), 0);
                    if (newestB !== newestA) return newestB - newestA;
                    const frontB = formatDuplicateField(b[0].front);
                    const frontA = formatDuplicateField(a[0].front);
                    return frontA.localeCompare(frontB);
                })
                .forEach(group => {
                    const groupCard = document.createElement('div');
                    groupCard.className = 'duplicate-group space-y-5';

                    const header = document.createElement('div');
                    header.className = 'flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3';

                    const title = document.createElement('div');
                    const groupFront = formatDuplicateField(group[0].front);
                    const groupBack = formatDuplicateField(group[0].back);
                    const titleFront = document.createElement('p');
                    titleFront.className = 'text-lg font-semibold text-gray-100';
                    titleFront.textContent = groupFront !== '' ? groupFront : 'No Front';
                    const titleBack = document.createElement('p');
                    titleBack.className = 'text-sm text-gray-400';
                    titleBack.textContent = groupBack !== '' ? groupBack : 'No Back';
                    title.append(titleFront, titleBack);
                    header.appendChild(title);

                    const badgeWrapper = document.createElement('div');
                    badgeWrapper.className = 'flex flex-wrap gap-2 items-center';

                    const countPill = document.createElement('span');
                    countPill.className = 'text-xs font-semibold text-gray-300 bg-gray-800 px-2 py-1 rounded-full';
                    countPill.textContent = `${group.length} card${group.length > 1 ? 's' : ''}`;
                    badgeWrapper.appendChild(countPill);

                    const folderPill = document.createElement('span');
                    folderPill.className = 'text-xs text-gray-400';
                    const uniqueFolders = Array.from(new Set(group.map(card => resolveFolderName(card))));
                    folderPill.textContent = `Folders: ${uniqueFolders.join(', ')}`;
                    badgeWrapper.appendChild(folderPill);

                    header.appendChild(badgeWrapper);
                    groupCard.appendChild(header);

                    const groupCardsWrapper = document.createElement('div');
                    groupCardsWrapper.className = 'space-y-4';

                    const cardsForRender = group.slice().sort((a, b) => getCreatedAtTime(a.createdAt) - getCreatedAtTime(b.createdAt));
                    cardsForRender.forEach(card => {
                        const cardEntry = document.createElement('div');
                        cardEntry.className = 'duplicate-card-entry space-y-4';

                        const matchesFolder =
                            folderFilter === '__all__' ||
                            (folderFilter === '__none__' && !card.folderId) ||
                            (folderFilter !== '__none__' && folderFilter === card.folderId);
                        if (matchesFolder && folderFilter !== '__all__') {
                            cardEntry.classList.add('highlight');
                        }

                        const meta = document.createElement('div');
                        meta.className = 'duplicate-card-meta flex flex-wrap gap-2';
                        const folderName = resolveFolderName(card);
                        const metaSegments = [
                            formatDuplicateTimestamp(card.createdAt),
                            '',
                            folderName,
                            '',
                            `ID: ${card.id}`
                        ];
                        metaSegments.forEach((segment, index) => {
                            const span = document.createElement('span');
                            span.textContent = segment;
                            meta.appendChild(span);
                            if (index === metaSegments.length - 1) return;
                        });
                        cardEntry.appendChild(meta);

                        const primaryGrid = document.createElement('div');
                        primaryGrid.className = 'grid gap-4 md:grid-cols-2';
                        primaryGrid.appendChild(createDuplicateFieldElement('Front', card.front));
                        primaryGrid.appendChild(createDuplicateFieldElement('Back', card.back));
                        primaryGrid.appendChild(createDuplicateFieldElement('Translation', card.translation));
                        primaryGrid.appendChild(createDuplicateFieldElement('Beispiel', card.beispiel));
                        cardEntry.appendChild(primaryGrid);

                        const optionalGrid = document.createElement('div');
                        optionalGrid.className = 'grid gap-4 md:grid-cols-2';
                        let hasOptional = false;
                        const optionalFields = [
                            { label: 'Speech', value: card.speech },
                            { label: 'Beispiel Speech', value: card.beispielSpeech }
                        ];
                        optionalFields.forEach(field => {
                            if (formatDuplicateDisplayValue(field.value) !== '') {
                                optionalGrid.appendChild(createDuplicateFieldElement(field.label, field.value));
                                hasOptional = true;
                            }
                        });
                        if (hasOptional) {
                            cardEntry.appendChild(optionalGrid);
                        }

                        const actionsRow = document.createElement('div');
                        actionsRow.className = 'flex flex-wrap items-center gap-2';

                        const editBtn = document.createElement('button');
                        editBtn.className = 'btn btn-secondary btn-sm duplicate-edit-btn';
                        editBtn.dataset.cardId = card.id;
                        editBtn.innerHTML = '<i class="fas fa-pen"></i> Edit';
                        actionsRow.appendChild(editBtn);

                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'btn btn-danger btn-sm duplicate-delete-btn';
                        deleteBtn.dataset.cardId = card.id;
                        deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i> Delete';
                        actionsRow.appendChild(deleteBtn);

                        const copyBtn = document.createElement('button');
                        copyBtn.className = 'btn btn-secondary btn-sm duplicate-copy-btn';
                        copyBtn.dataset.cardId = card.id;
                        copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy Back';
                        actionsRow.appendChild(copyBtn);

                        cardEntry.appendChild(actionsRow);
                        groupCardsWrapper.appendChild(cardEntry);
                    });

                    groupCard.appendChild(groupCardsWrapper);
                    container.appendChild(groupCard);
                });
        }

        function showMainAppView() {
            const mainApp = document.getElementById('main-app');
            const duplicatesView = document.getElementById('duplicates-view');
            const deletedView = document.getElementById('deleted-view');
            const legacyView = document.getElementById('legacy-view');
            if (mainApp) mainApp.classList.remove('hidden');
            if (duplicatesView) duplicatesView.classList.add('hidden');
            if (deletedView) deletedView.classList.add('hidden');
            if (legacyView) legacyView.classList.add('hidden');
            const duplicatesSearchInput = document.getElementById('duplicates-search-input');
            if (duplicatesSearchInput && !isDuplicatesViewActive()) {
                duplicatesSearchInput.blur();
            }
        }

        function showDuplicatesView() {
            renderDuplicatesView();
            const mainApp = document.getElementById('main-app');
            const duplicatesView = document.getElementById('duplicates-view');
            const deletedView = document.getElementById('deleted-view');
            const legacyView = document.getElementById('legacy-view');
            const reviewModal = document.getElementById('review-modal');
            if (mainApp) mainApp.classList.add('hidden');
            if (deletedView) deletedView.classList.add('hidden');
            if (legacyView) legacyView.classList.add('hidden');
            if (duplicatesView) duplicatesView.classList.remove('hidden');
            if (reviewModal) reviewModal.classList.add('hidden');
            const searchInput = document.getElementById('duplicates-search-input');
            if (searchInput) searchInput.focus();
        }

        function showDeletedView() {
            renderDeletedView();
            const mainApp = document.getElementById('main-app');
            const duplicatesView = document.getElementById('duplicates-view');
            const deletedView = document.getElementById('deleted-view');
            const legacyView = document.getElementById('legacy-view');
            const reviewModal = document.getElementById('review-modal');
            if (mainApp) mainApp.classList.add('hidden');
            if (duplicatesView) duplicatesView.classList.add('hidden');
            if (legacyView) legacyView.classList.add('hidden');
            if (deletedView) deletedView.classList.remove('hidden');
            if (reviewModal) reviewModal.classList.add('hidden');
        }

        function showLegacyFrontsView() {
            renderLegacyFrontsView();
            const mainApp = document.getElementById('main-app');
            const duplicatesView = document.getElementById('duplicates-view');
            const deletedView = document.getElementById('deleted-view');
            const legacyView = document.getElementById('legacy-view');
            const reviewModal = document.getElementById('review-modal');
            if (mainApp) mainApp.classList.add('hidden');
            if (duplicatesView) duplicatesView.classList.add('hidden');
            if (deletedView) deletedView.classList.add('hidden');
            if (legacyView) legacyView.classList.remove('hidden');
            if (reviewModal) reviewModal.classList.add('hidden');
        }

        function isLegacyViewActive() {
            const legacyView = document.getElementById('legacy-view');
            return legacyView ? !legacyView.classList.contains('hidden') : false;
        }

        function exportVisibleDuplicates() {
            const searchInput = document.getElementById('duplicates-search-input');
            const folderFilterSelect = document.getElementById('duplicates-folder-filter');
            const searchTerm = (searchInput ? searchInput.value : '').trim();
            const folderFilter = folderFilterSelect ? folderFilterSelect.value : '__all__';

            const { filteredGroups } = buildDuplicateViewModel({ searchTerm, folderFilter });
            if (filteredGroups.length === 0) {
                showNotification('No duplicates to export.', 'error');
                return;
            }

            const seen = new Set();
            const exportCards = [];
            filteredGroups.forEach(group => {
                group.forEach(card => {
                    if (seen.has(card.id)) return;
                    seen.add(card.id);
                    exportCards.push({
                        id: card.id,
                        front: card.front || '',
                        back: card.back || '',
                        translation: card.translation || '',
                        beispiel: card.beispiel || '',
                        speech: card.speech || '',
                        beispielSpeech: card.beispielSpeech || '',
                        folderId: card.folderId || '',
                        folderName: resolveFolderName(card),
                        createdAt: card.createdAt || ''
                    });
                });
            });

            const payload = {
                generatedAt: new Date().toISOString(),
                duplicateGroupCount: filteredGroups.length,
                cardCount: exportCards.length,
                cards: exportCards
            };

            const today = new Date().toISOString().split('T')[0];
            triggerDownload(JSON.stringify(payload, null, 2), `duplicate-cards-${today}.json`, 'application/json');
            showNotification('Duplicate snapshot exported.', 'success');
        }

        function isDeletedViewActive() {
            const view = document.getElementById('deleted-view');
            return view ? !view.classList.contains('hidden') : false;
        }

        function createDeletedFieldElement(label, value) {
            const wrapper = document.createElement('div');
            wrapper.className = 'space-y-1';
            const labelEl = document.createElement('p');
            labelEl.className = 'field-label';
            labelEl.textContent = label;
            const valueEl = document.createElement('div');
            valueEl.className = 'field-value';
            valueEl.textContent = formatDuplicateDisplayValue(value);
            wrapper.append(labelEl, valueEl);
            return wrapper;
        }

        function renderDeletedView() {
            const container = document.getElementById('deleted-container');
            const summary = document.getElementById('deleted-summary');
            const emptyState = document.getElementById('deleted-empty-state');
            if (!container || !summary || !emptyState) return;

            container.innerHTML = '';

            if (deletedCards.length === 0) {
                summary.textContent = 'No deleted cards in history.';
                emptyState.classList.remove('hidden');
                return;
            }

            summary.textContent = `Showing the last ${deletedCards.length} deleted card${deletedCards.length > 1 ? 's' : ''} (max 20 stored).`;
            emptyState.classList.add('hidden');

            deletedCards
                .slice()
                .sort((a, b) => getCreatedAtTime(b.deletedAt) - getCreatedAtTime(a.deletedAt))
                .forEach(card => {
                    const entry = document.createElement('div');
                    entry.className = 'deleted-card-entry space-y-4';
                    entry.dataset.cardId = card.id;

                    const header = document.createElement('header');
                    const titleFront = document.createElement('p');
                    titleFront.className = 'text-lg font-semibold text-gray-100';
                    titleFront.textContent = formatDuplicateDisplayValue(card.front) !== '' ? formatDuplicateDisplayValue(card.front) : 'No Front';
                    const titleBack = document.createElement('p');
                    titleBack.className = 'text-sm text-gray-400';
                    titleBack.textContent = formatDuplicateDisplayValue(card.back) !== '' ? formatDuplicateDisplayValue(card.back) : 'No Back';
                    header.append(titleFront, titleBack);
                    entry.appendChild(header);

                    const meta = document.createElement('div');
                    meta.className = 'meta';
                    const metaSegments = [
                        `Deleted: ${formatDuplicateTimestamp(card.deletedAt)}`,
                        `Original ID: ${card.originalId || card.id}`,
                        `Folder: ${resolveFolderName(card)}`
                    ];
                    metaSegments.forEach(segment => {
                        const span = document.createElement('span');
                        span.textContent = segment;
                        meta.appendChild(span);
                    });
                    entry.appendChild(meta);

                    const primaryGrid = document.createElement('div');
                    primaryGrid.className = 'grid gap-4 md:grid-cols-2';
                    primaryGrid.appendChild(createDeletedFieldElement('Front', card.front));
                    primaryGrid.appendChild(createDeletedFieldElement('Back', card.back));
                    primaryGrid.appendChild(createDeletedFieldElement('Translation', card.translation));
                    primaryGrid.appendChild(createDeletedFieldElement('Beispiel', card.beispiel));
                    entry.appendChild(primaryGrid);

                    const optionalGrid = document.createElement('div');
                    optionalGrid.className = 'grid gap-4 md:grid-cols-2';
                    let hasOptional = false;
                    [
                        { label: 'Speech', value: card.speech },
                        { label: 'Beispiel Speech', value: card.beispielSpeech }
                    ].forEach(field => {
                        if (formatDuplicateDisplayValue(field.value) !== '') {
                            optionalGrid.appendChild(createDeletedFieldElement(field.label, field.value));
                            hasOptional = true;
                        }
                    });
                    if (hasOptional) entry.appendChild(optionalGrid);

                    const actions = document.createElement('div');
                    actions.className = 'flex flex-wrap gap-2';

                    const restoreBtn = document.createElement('button');
                    restoreBtn.className = 'btn btn-success btn-sm deleted-restore-btn';
                    restoreBtn.dataset.cardId = card.id;
                    restoreBtn.innerHTML = '<i class="fas fa-undo"></i> Restore';
                    actions.appendChild(restoreBtn);

                    const restoreEditBtn = document.createElement('button');
                    restoreEditBtn.className = 'btn btn-secondary btn-sm deleted-restore-edit-btn';
                    restoreEditBtn.dataset.cardId = card.id;
                    restoreEditBtn.innerHTML = '<i class="fas fa-pen"></i> Restore & Edit';
                    actions.appendChild(restoreEditBtn);

                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'btn btn-secondary btn-sm deleted-copy-btn';
                    copyBtn.dataset.cardId = card.id;
                    copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy Back';
                    actions.appendChild(copyBtn);

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'btn btn-danger btn-sm deleted-remove-btn';
                    removeBtn.dataset.cardId = card.id;
                    removeBtn.innerHTML = '<i class="fas fa-trash-alt"></i> Remove';
                    actions.appendChild(removeBtn);

                    entry.appendChild(actions);
                    container.appendChild(entry);
                });
        }

        function buildArchivedCardPayload(cardData) {
            if (!cardData || !cardData.id) return null;
            const { id: originalId, ...rest } = cardData;
            const cleaned = {};
            Object.entries(rest).forEach(([key, value]) => {
                cleaned[key] = value === undefined ? null : value;
            });
            return {
                ...cleaned,
                originalId,
                deletedAt: new Date().toISOString()
            };
        }

        async function archiveCardBeforeDeletion(cardData) {
            if (!deletedCardsCollectionRef || !cardData || !cardData.id) return;
            const archivedCard = buildArchivedCardPayload(cardData);
            if (!archivedCard) return;
            try {
                const archiveDocRef = doc(deletedCardsCollectionRef);
                await setDoc(archiveDocRef, archivedCard);
            } catch (error) {
                console.error('Failed to archive card before deletion:', error);
            }
        }

        async function restoreDeletedCard(card, options = {}) {
            if (!card || !cardsCollectionRef || !deletedCardsCollectionRef) {
                showNotification('Unable to restore this card right now.', 'error');
                return;
            }
            const cardId = card.originalId || card.id;
            const { deletedAt, originalId, ...rest } = card;
            const payload = {
                front: rest.front || '',
                back: rest.back || '',
                speech: rest.speech || '',
                beispiel: rest.beispiel || '',
                beispielSpeech: rest.beispielSpeech || '',
                translation: rest.translation || '',
                folderId: rest.folderId || null,
                folderName: rest.folderName || null,
                createdAt: rest.createdAt || new Date().toISOString()
            };

            try {
                await setDoc(doc(cardsCollectionRef, cardId), payload);
                await deleteDoc(doc(deletedCardsCollectionRef, card.id));
                showNotification('Card restored.', 'success');
                deletedCards = deletedCards.filter(existing => existing.id !== card.id);
                updateDeletedBadge();
                if (options.edit) {
                    showMainAppView();
                    setEditMode(true, { ...payload, id: cardId });
                }
            } catch (error) {
                console.error('Restore failed:', error);
                showNotification('Failed to restore card.', 'error');
            }
        }

        async function permanentlyDeleteArchivedCard(cardId) {
            if (!cardId || !deletedCardsCollectionRef) return;
            try {
                await deleteDoc(doc(deletedCardsCollectionRef, cardId));
                showNotification('Card removed from history.', 'success');
                deletedCards = deletedCards.filter(card => card.id !== cardId);
                updateDeletedBadge();
            } catch (error) {
                console.error('Failed to remove archived card:', error);
                showNotification('Could not remove card from history.', 'error');
            }
        }

        function updateDeletedBadge() {
            const badge = document.getElementById('deleted-count-badge');
            if (!badge) return;
            if (!deletedCards.length) {
                badge.classList.add('hidden');
                badge.textContent = '';
            } else {
                badge.textContent = deletedCards.length.toString();
                badge.classList.remove('hidden');
            }
            if (isDeletedViewActive()) {
                renderDeletedView();
            }
        }

        function updateSpeechFields() { 
            const backInput = document.getElementById('back');
            const beispielInput = document.getElementById('beispiel');
            const speechBox = document.getElementById('speech');
            const beispielSpeechBox = document.getElementById('beispiel-speech');
            if(!backInput || !beispielInput || !speechBox || !beispielSpeechBox) return;

            const backValue = backInput.value; 
            const beispielValue = beispielInput.value;
            const soundTagText = prepareForSoundTag(backValue); 

            const speechValue = soundTagText ? `[sound:${soundTagText}.mp3]` : '';
            speechBox.textContent = speechValue;
            speechBox.dataset.raw = speechValue;

            const rawBeispielSpeech = buildBeispielSpeech(backValue, beispielValue);
            setBeispielSpeechBoxValue(beispielSpeechBox, rawBeispielSpeech);
        }
        
        function clearForm() {
            const ankiForm = document.getElementById('anki-form');
            const front = document.getElementById('front');
            const folderSelect = document.getElementById('folder-select');
            const preservedFolderValue = folderSelect ? folderSelect.value : ((currentFolderId != null ? currentFolderId : NO_FOLDER_VALUE));
            if (ankiForm) ankiForm.reset();
            if (folderSelect) {
                const availableValues = Array.from(folderSelect.options).map(option => option.value);
                const valueToRestore = availableValues.includes(preservedFolderValue) ? preservedFolderValue : NO_FOLDER_VALUE;
                folderSelect.value = valueToRestore;
                const normalizedCurrent = (currentFolderId != null ? currentFolderId : NO_FOLDER_VALUE);
                if (valueToRestore !== normalizedCurrent) {
                    const selectionChanged = updateFolderSelection(valueToRestore, { persist: false, updateSelect: false });
                    if (selectionChanged) {
                        filterAndRenderCards();
                    }
                }
            }
            updateSpeechFields();
            if (front) front.focus();
        }

        function setEditMode(isEditing, cardData = null) {
            const defaultActions = document.getElementById('default-actions');
            const editActions = document.getElementById('edit-actions');
            const front = document.getElementById('front');
            const back = document.getElementById('back');
            const beispiel = document.getElementById('beispiel');
            const translation = document.getElementById('translation');
            const folderSelect = document.getElementById('folder-select');

            if (isEditing) {
                document.getElementById('main-app').scrollIntoView();
                currentEditId = cardData.id;
                front.value = cardData.front || '';
                back.value = cardData.back || '';
                beispiel.value = unformatMultiLine(cardData.beispiel || '');
                translation.value = unformatMultiLine(cardData.translation || '');
                if (folderSelect) {
                    const folderValue = cardData && cardData.folderId ? cardData.folderId : NO_FOLDER_VALUE;
                    const availableValues = Array.from(folderSelect.options).map(option => option.value);
                    const valueToApply = folderValue !== NO_FOLDER_VALUE && !availableValues.includes(folderValue)
                        ? NO_FOLDER_VALUE
                        : folderValue;
                    const selectionChanged = updateFolderSelection(valueToApply);
                    if (selectionChanged) {
                        filterAndRenderCards();
                    }
                }
                updateSpeechFields();
                defaultActions.classList.add('hidden');
                editActions.classList.remove('hidden');
            } else {
                currentEditId = null;
                defaultActions.classList.remove('hidden');
                editActions.classList.add('hidden');
                clearForm();
            }
        }
        
        function renderCards(cardsToRender, { sortByCreatedAt = true } = {}) {
            const cardList = document.getElementById('card-list');
            if (!cardList) return;

            cardList.innerHTML = '';
            
            const searchInput = document.getElementById('search-input');
            const searchTerm = searchInput ? searchInput.value.trim() : '';

            if (cardsToRender.length === 0) {
                if (searchTerm) {
                    cardList.innerHTML = '<p class="text-gray-500 text-center">No cards match your search.</p>';
                } else if (allCards.length > 0) {
                    let folderLabel = 'Selected folder';
                    if (currentViewFolderId === ALL_FOLDERS_VALUE) folderLabel = 'All Folders';
                    else if (currentViewFolderId === NO_FOLDER_VALUE) folderLabel = 'No Folder';
                    else {
                        const viewFolderMeta = folders.find(folder => folder.id === currentViewFolderId);
                        if (viewFolderMeta && viewFolderMeta.name) folderLabel = viewFolderMeta.name;
                    }
                    const sanitizedLabel = folderLabel.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                    cardList.innerHTML = `<p class="text-gray-500 text-center">No cards in "${sanitizedLabel}" yet.</p>`;
                } else {
                    cardList.innerHTML = '<p class="text-gray-500 text-center">No cards saved yet.</p>';
                }
                return;
            }
            
            const docs = [...cardsToRender];
            if (sortByCreatedAt) {
                docs.sort((a, b) => getCreatedAtTime(b.createdAt) - getCreatedAtTime(a.createdAt));
            }
            docs.forEach(cardData => {
                const cardEl = document.createElement('div');
                cardEl.className = 'card-item';
                const frontDisplay = (cardData.front && cardData.front.startsWith('<img')) 
                    ? ' Image Card' 
                    : (cardData.front || '<em>No Front</em>');

                cardEl.innerHTML = `
                    <div class="card-item-content mr-4">
                        <p class="card-item-front">${frontDisplay}</p>
                        <p class="card-item-back">${cardData.back || '<em>No Back</em>'}</p>
                        <p class="card-item-folder text-xs text-gray-500 mt-2"></p>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button class="btn-icon copy-btn" title="Copy Back (C)"><i class="fas fa-copy"></i></button>
                        <button class="btn-icon edit-btn" title="Edit"><i class="fas fa-pencil-alt"></i></button>
                        <button class="btn-icon delete-btn" title="Delete"><i class="fas fa-trash-alt"></i></button>
                    </div>
                `;
                cardList.appendChild(cardEl);
                const folderLabelEl = cardEl.querySelector('.card-item-folder');
                if (folderLabelEl) {
                    const folderMeta = cardData.folderId ? folders.find(folder => folder.id === cardData.folderId) : null;
                    const displayName = folderMeta && folderMeta.name ? folderMeta.name : (cardData.folderName || 'No Folder');
                    folderLabelEl.textContent = `Folder: ${displayName}`;
                }
                cardEl.querySelector('.copy-btn').addEventListener('click', (e) => {
                    const backText = e.target.closest('.card-item').querySelector('.card-item-back').textContent;
                    if (backText) {
                        const tempInput = document.createElement('textarea');
                        tempInput.value = backText;
                        document.body.appendChild(tempInput);
                        tempInput.select();
                        document.execCommand('copy');
                        document.body.removeChild(tempInput);
                        showNotification("Copied to clipboard!", "success", 1500);
                    }
                });
                cardEl.querySelector('.edit-btn').addEventListener('click', () => setEditMode(true, cardData));
                cardEl.querySelector('.delete-btn').addEventListener('click', () => { 
                    cardToDeleteId = cardData.id; 
                    const deleteModal = document.getElementById('delete-modal');
                    if (deleteModal) deleteModal.classList.remove('hidden'); 
                });
            });
        }
        
        function triggerDownload(content, fileName, mimeType = 'text/plain;charset=utf-8') {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function triggerBlobDownload(blob, fileName) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function buildTsvFromCards(cards) {
            const sortedCards = [...cards].sort((a, b) => getCreatedAtTime(a.createdAt) - getCreatedAtTime(b.createdAt));
            return sortedCards.map(data => {
                const soundTagBase = prepareForSoundTag(data.back);
                const speechValue = !isBlank(data.speech) ? data.speech : (soundTagBase ? `[sound:${soundTagBase}.mp3]` : '');
                const sanitizedBack = sanitizeForExport(data.back);
                const resolvedBeispielSpeech = resolveBeispielSpeechValue(data.back, data.beispiel, data.beispielSpeech);
                const fields = [
                    sanitizeForExport(data.front, sanitizedBack),
                    sanitizedBack,
                    sanitizeForExport(speechValue),
                    sanitizeForExport(data.beispiel),
                    sanitizeForExport(resolvedBeispielSpeech, '', {
                        preserveLeadingBr: true,
                        preserveSpacingAroundBr: true,
                        keepOuterWhitespace: true
                    }),
                    sanitizeForExport(data.translation)
                ];
                return fields.join('\t');
            }).join('\n');
        }

        function updateReviewDateSelector() {
            const reviewDateSelector = document.getElementById('review-date-selector');
            const reviewBtn = document.getElementById('review-btn');
            const startSessionBtn = document.getElementById('start-session-btn');
            const missingOnly = isReviewMissingOnly();
            const relevantCards = allCards
                .filter(card => cardMatchesFolder(card, currentReviewFolderId))
                .filter(card => !missingOnly || !cardHasBeispiel(card));
            const dates = new Set();
            relevantCards.forEach(card => {
                if (card.createdAt && typeof card.createdAt === 'string') {
                    const datePart = card.createdAt.split('T')[0];
                    dates.add(datePart);
                }
            });

            const sortedDates = Array.from(dates).sort().reverse();
            if (reviewDateSelector) {
                const preferredValue = (reviewDateSelector.value || currentReviewDate || 'all');
                reviewDateSelector.innerHTML = '<option value="all">All Dates</option>' + sortedDates.map(date => `<option value="${date}">${date}</option>`).join('');
                let valueToApply = preferredValue;
                if (valueToApply !== 'all' && !sortedDates.includes(valueToApply)) {
                    valueToApply = sortedDates.length > 0 ? sortedDates[0] : 'all';
                }
                if (sortedDates.length === 0) {
                    valueToApply = 'all';
                }
                reviewDateSelector.value = valueToApply;
                currentReviewDate = reviewDateSelector.value;
            }

            if (reviewBtn) reviewBtn.disabled = allCards.length === 0;
            if (startSessionBtn) startSessionBtn.disabled = relevantCards.length === 0;
        }

        function updateProgressBar() {
            const bar = document.getElementById('review-progress-bar');
            if(!bar || !reviewSession.cards || reviewSession.cards.length === 0) return;
            const progress = (reviewSession.currentIndex + 1) / reviewSession.cards.length * 100;
            bar.style.width = `${progress}%`;
        }
        
        function renderMultiLineForReview(container, textContent) {
            container.innerHTML = '';
            if (textContent) {
                const lines = textContent.split(/<br\s*\/?>/i);
                lines.forEach(line => {
                    const trimmedLine = line.trim();
                    if (trimmedLine) {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'flex justify-between items-center w-full';

                        const span = document.createElement('span');
                        span.className = 'flex-grow p-1';
                        span.textContent = trimmedLine;

                        const copyBtn = document.createElement('button');
                        copyBtn.className = 'btn-icon text-gray-400 hover:text-white ml-4 flex-shrink-0 copy-line-btn';
                        copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
                        copyBtn.title = `Copy: "${trimmedLine}"`;
                        copyBtn.dataset.text = trimmedLine;

                        wrapper.appendChild(span);
                        wrapper.appendChild(copyBtn);
                        container.appendChild(wrapper);
                    }
                });
            } else {
                container.textContent = '';
            }
        }

        function setBeispielSpeechActive(activeIndex = null) {
            const container = document.getElementById('review-beispiel-speech');
            if (!container) return;
            container.querySelectorAll('.review-sound-pill').forEach(pill => {
                pill.classList.remove('sound-pill-active');
                if (activeIndex !== null && Number(pill.dataset.soundIndex) === Number(activeIndex)) {
                    pill.classList.add('sound-pill-active');
                }
            });
        }

        function renderBeispielSpeechForReview(container, speechText) {
            if (!container) return;
            container.innerHTML = '';
            const raw = speechText == null ? '' : String(speechText);
            const soundTags = extractSoundTagsFromBeispielSpeech(raw);
            const hasText = raw.trim().length > 0;

            if (soundTags.length === 0 && !hasText) {
                container.textContent = '';
                return;
            }

            if (soundTags.length === 0) {
                container.textContent = raw.trim();
                return;
            }

            soundTags.forEach((tag, index) => {
                const pill = document.createElement('span');
                pill.className = 'inline-block bg-gray-800 px-2 py-1 rounded text-sm review-sound-pill';
                pill.dataset.soundIndex = index;
                pill.textContent = tag;
                container.appendChild(pill);
            });
            setBeispielSpeechActive(null);
        }
        
        function renderReviewEmptyState(message = 'No cards available.') {
            const frontEl = document.getElementById('review-front');
            const backEl = document.getElementById('review-back');
            const beispielEl = document.getElementById('review-beispiel');
            const beispielSpeechEl = document.getElementById('review-beispiel-speech');
            const translationEl = document.getElementById('review-translation');
            const progressTextEl = document.getElementById('review-progress-text');
            const editedTextEl = document.getElementById('review-edited-text');
            const prevBtn = document.getElementById('prev-card-btn');
            const nextBtn = document.getElementById('next-card-btn');
            if (frontEl) frontEl.textContent = '';
            if (backEl) backEl.textContent = '';
            if (beispielEl) beispielEl.innerHTML = `<p class="text-center text-gray-500 w-full">${message}</p>`;
            if (beispielSpeechEl) beispielSpeechEl.textContent = '';
            if (translationEl) translationEl.innerHTML = '';
            if (progressTextEl) progressTextEl.textContent = message;
            if (editedTextEl) editedTextEl.textContent = '';
            if (prevBtn) prevBtn.disabled = true;
            if (nextBtn) nextBtn.disabled = true;
            const bar = document.getElementById('review-progress-bar');
            if (bar) bar.style.width = '0%';
        }

        function renderReviewCard() {
            const searchInput = document.getElementById('in-review-search-input');
            const activeSearchTerm = searchInput ? searchInput.value.trim() : '';
            const hasCards = reviewSession.cards && reviewSession.cards.length > 0 && reviewSession.currentIndex > -1;

            if (!hasCards) {
                if (activeSearchTerm && reviewSession.originalCards && reviewSession.originalCards.length > 0) {
                    renderReviewEmptyState('No cards match your search.');
                    return;
                }
                endReviewSession();
                showNotification("Review session finished.", "success");
                return;
            }

            reviewSession.beispielCopyIndex = 0;
            reviewSession.beispielSpeechCopyIndex = 0;

            const card = reviewSession.cards[reviewSession.currentIndex];
            document.getElementById('review-front').textContent = card.front || '';
            document.getElementById('review-back').textContent = card.back || '';

            renderMultiLineForReview(document.getElementById('review-beispiel'), card.beispiel);
            renderBeispielSpeechForReview(document.getElementById('review-beispiel-speech'), card.beispielSpeech);
            renderMultiLineForReview(document.getElementById('review-translation'), card.translation);
            
            // Update counters and marker
            const editedCount = reviewSession.editedCardIds.size;
            const totalCount = reviewSession.cards.length;
            document.getElementById('review-progress-text').textContent = `Card ${reviewSession.currentIndex + 1} of ${totalCount}`;
            document.getElementById('review-edited-text').textContent = `Edited: ${editedCount} / ${totalCount - editedCount} Remaining`;
            
            const markEditedBtn = document.getElementById('mark-edited-btn');
            if (reviewSession.editedCardIds.has(card.id)) {
                markEditedBtn.classList.add('btn-success');
                markEditedBtn.classList.remove('btn-secondary');
            } else {
                markEditedBtn.classList.add('btn-secondary');
                markEditedBtn.classList.remove('btn-success');
            }

            document.getElementById('prev-card-btn').disabled = reviewSession.currentIndex === 0;
            document.getElementById('next-card-btn').disabled = reviewSession.currentIndex === reviewSession.cards.length - 1;
            updateProgressBar();
        }

        async function handleReviewNav(direction, autoEditNext = false) {
            clearAutoSkipTimer();
            
            if (isReviewEditing) {
                const success = await saveReviewEdit();
                if (!success) return; 
                exitReviewEditMode();
            }

            // Mark the card we are leaving as edited
            if (direction > 0 && reviewSession.currentIndex > -1) {
                const currentCard = reviewSession.cards[reviewSession.currentIndex];
                const cardId = currentCard && currentCard.id;
                if (cardId && !reviewSession.editedCardIds.has(cardId)) {
                    setLocalEditedState(cardId, true);
                    await updateEditedCardsInFirestore(cardId, true);
                }
            }
            
            const newIndex = reviewSession.currentIndex + direction;
            if (newIndex >= 0 && newIndex < reviewSession.cards.length) {
                reviewSession.currentIndex = newIndex;
                renderReviewCard();

                if (autoEditNext) {
                    const nextCard = reviewSession.cards[newIndex];
                    if (nextCard && nextCard.back) {
                        try {
                            const tempInput = document.createElement('textarea');
                            tempInput.value = nextCard.back;
                            document.body.appendChild(tempInput);
                            tempInput.select();
                            document.execCommand('copy');
                            document.body.removeChild(tempInput);
                            showNotification("Copied next card's back!", "success", 1500);
                        } catch (err) {
                            showNotification("Failed to copy automatically.");
                        } finally {
                            enterReviewEditMode();
                        }
                    } else {
                        enterReviewEditMode();
                    }
                }
            }
        }

        function copyBeispielSpeechTag() {
            clearAutoSkipTimer();
            if (reviewSession.currentIndex === -1) return;
            const card = reviewSession.cards[reviewSession.currentIndex];
            if (!card) return;

            const rawSpeech = card.beispielSpeech == null ? '' : String(card.beispielSpeech);
            const soundTags = extractSoundTagsFromBeispielSpeech(rawSpeech);
            const container = document.getElementById('review-beispiel-speech');

            if (soundTags.length === 0) {
                const trimmed = rawSpeech.trim();
                if (!trimmed) return;
                copyPlainTextToClipboard(trimmed);
                if (container) {
                    container.classList.add('copy-highlight');
                    setTimeout(() => container.classList.remove('copy-highlight'), 400);
                }
                showNotification('Copied Beispiel speech.', 'success', 1200);
                return;
            }

            const currentIndex = reviewSession.beispielSpeechCopyIndex || 0;
            const normalizedIndex = currentIndex % soundTags.length;
            const tagToCopy = soundTags[normalizedIndex];
            const identifierToCopy = normalizeSoundIdentifier(tagToCopy) || tagToCopy;
            copyPlainTextToClipboard(identifierToCopy);

            if (container) {
                const highlightTarget = container.querySelector(`[data-sound-index="${normalizedIndex}"]`) || container;
                setBeispielSpeechActive(normalizedIndex);
                highlightTarget.classList.add('copy-highlight');
                setTimeout(() => highlightTarget.classList.remove('copy-highlight'), 400);
            }
            const label = normalizeSoundIdentifier(tagToCopy) || `sound ${normalizedIndex + 1}`;
            showNotification(`Copied ${label} (${normalizedIndex + 1} of ${soundTags.length}).`, 'success', 1200);
            reviewSession.beispielSpeechCopyIndex = (normalizedIndex + 1) % soundTags.length;
        }

        function handleReviewKeyboard(e) {
            if (document.activeElement.id === 'in-review-search-input' || (document.activeElement.tagName === 'TEXTAREA' && isReviewEditing)) return;
            
            const deleteModal = document.getElementById('delete-modal');
            const isDeleteModalOpen = deleteModal && !deleteModal.classList.contains('hidden');
            if (isDeleteModalOpen) {
                if (e.key === 'Delete') {
                    e.preventDefault();
                    resetDeleteShortcut();
                    document.getElementById('confirm-delete-btn').click();
                }
                return;
            }
            
            if (e.key === 'ArrowRight') handleReviewNav(1);
            if (e.key === 'ArrowLeft') handleReviewNav(-1);
            if (e.key === 'f' || e.key === 'F') {
                const frontBtn = document.querySelector('[data-target="review-front"]');
                if (frontBtn) {
                    e.preventDefault();
                    frontBtn.click();
                }
            }
            if (e.key === 'b' || e.key === 'B') document.querySelector('[data-target="review-back"]').click();
            if (e.key === 'd' || e.key === 'D') {
                e.preventDefault();
                if (!deleteShortcutState.pending) {
                    deleteShortcutState.pending = true;
                    deleteShortcutState.timeoutId = setTimeout(() => {
                        deleteShortcutState.pending = false;
                        deleteShortcutState.timeoutId = null;
                    }, 2000);
                    showNotification("Press D again to open delete confirmation.", "error", 2000);
                    return;
                }
                resetDeleteShortcut();
                document.getElementById('delete-review-card-btn').click();
                return;
            }
            
            if (e.key === 'e' || e.key === 'E') {
                e.preventDefault();
                const card = reviewSession.cards[reviewSession.currentIndex];
                const beispielText = card.beispiel || '';
                if (!beispielText) return;

                const sentences = beispielText.split(/<br\s*\/?>/i).map(s => s.trim()).filter(Boolean);
                if (sentences.length === 0) return;

                const sentenceToCopy = sentences[reviewSession.beispielCopyIndex];
                const tempInput = document.createElement('textarea');
                tempInput.value = sentenceToCopy;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);

                const sentenceElements = document.querySelectorAll('#review-beispiel > div');
                if (sentenceElements.length > reviewSession.beispielCopyIndex) {
                    const el = sentenceElements[reviewSession.beispielCopyIndex];
                    el.classList.add('copy-highlight');
                    setTimeout(() => el.classList.remove('copy-highlight'), 400);
                }
                showNotification(`Copied: "${sentenceToCopy}"`, "success", 1500);
                reviewSession.beispielCopyIndex = (reviewSession.beispielCopyIndex + 1) % sentences.length;

            }

            if (e.key === 's' || e.key === 'S') {
                e.preventDefault();
                copyBeispielSpeechTag();
                return;
            }

            if (e.key === 'Enter' && !isReviewEditing) enterReviewEditMode();
            if (e.key === 'Delete') {
                resetDeleteShortcut();
                document.getElementById('delete-review-card-btn').click();
            }
            if (e.key === 'm' || e.key === 'M') document.getElementById('mark-edited-btn').click();
        }

        function setLocalEditedState(cardId, isEdited) {
            if (!cardId) return;
            if (isEdited) reviewSession.editedCardIds.add(cardId);
            else reviewSession.editedCardIds.delete(cardId);

            const updateInList = (list) => {
                if (!Array.isArray(list)) return;
                const card = list.find(c => c.id === cardId);
                if (card) card.reviewEdited = isEdited;
            };
            updateInList(reviewSession.cards);
            updateInList(reviewSession.originalCards);
            const allCard = allCards.find(c => c.id === cardId);
            if (allCard) allCard.reviewEdited = isEdited;
        }

        async function updateEditedCardsInFirestore(cardId, isEdited) {
            if (!userId) return;
            const writes = [];
            if (cardId && cardsCollectionRef) {
                const cardRef = doc(cardsCollectionRef, cardId);
                const payload = isEdited
                    ? { reviewEdited: true, reviewEditedAt: new Date().toISOString() }
                    : { reviewEdited: deleteField(), reviewEditedAt: deleteField() };
                writes.push(updateDoc(cardRef, payload).catch(error => {
                    console.error('Failed to update card edited state:', error);
                    showNotification('Could not update card edited state.', 'error');
                }));
            }
            if (currentReviewSessionId) {
                const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/review_sessions`, currentReviewSessionId);
                const idsArray = Array.from(reviewSession.editedCardIds);
                writes.push(setDoc(sessionRef, { editedCardIds: idsArray }, { merge: true }).catch(error => {
                    console.error('Failed to save review progress:', error);
                    showNotification('Could not save review progress.');
                }));
            }
            await Promise.all(writes);
        }

        async function startReviewSession() {
            const reviewDateSelector = document.getElementById('review-date-selector');
            const reviewFolderSelector = document.getElementById('review-folder-selector');
            const selectedDate = reviewDateSelector ? reviewDateSelector.value : 'all';
            const selectedFolder = reviewFolderSelector ? reviewFolderSelector.value : ALL_FOLDERS_VALUE;
            const missingOnly = isReviewMissingOnly();

            currentReviewDate = selectedDate;
            currentReviewFolderId = selectedFolder;

            let cardsForReview = allCards.filter(card => cardMatchesFolder(card, selectedFolder));
            if (selectedDate !== 'all') {
                cardsForReview = cardsForReview.filter(card => card.createdAt && card.createdAt.startsWith(selectedDate));
            }
            if (missingOnly) {
                cardsForReview = cardsForReview.filter(card => !cardHasBeispiel(card));
            }
            cardsForReview.sort((a, b) => getCreatedAtTime(a.createdAt) - getCreatedAtTime(b.createdAt));

            if (cardsForReview.length === 0) {
                const message = missingOnly
                    ? 'No cards without Beispiele for the selected filters.'
                    : 'No cards found for the selected filters.';
                showNotification(message);
                return;
            }

            currentReviewSessionId = buildReviewSessionId(selectedDate, selectedFolder, missingOnly);

            reviewSession.originalCards = [...cardsForReview];
            reviewSession.cards = [...cardsForReview];
            reviewSession.currentIndex = 0;
            reviewSession.editedCardIds = new Set(cardsForReview.filter(card => card.reviewEdited).map(card => card.id));
            resetDeleteShortcut();
            
            // Fetch persisted edited IDs
            if (userId && currentReviewSessionId) {
                try {
                    const docRef = doc(db, `artifacts/${appId}/users/${userId}/review_sessions`, currentReviewSessionId);
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists() && docSnap.data().editedCardIds) {
                        const editedIds = docSnap.data().editedCardIds;
                        editedIds.forEach(id => setLocalEditedState(id, true));
                    }
                } catch (error) {
                    console.error('Error fetching review session:', error);
                }
            }

            document.getElementById('review-setup').classList.add('hidden');
            document.getElementById('review-session').classList.remove('hidden');
            document.addEventListener('keydown', handleReviewKeyboard);
            renderReviewCard();
            exitReviewEditMode();
        }
        
        function endReviewSession() {
            clearAutoSkipTimer();
            resetDeleteShortcut();
            reviewSession = { cards: [], currentIndex: -1, autoSkipTimer: null, beispielCopyIndex: 0, beispielSpeechCopyIndex: 0, editedCardIds: new Set(), originalCards: [] };
            currentReviewSessionId = null;
            document.getElementById('main-app').classList.remove('hidden');
            document.getElementById('review-modal').classList.add('hidden');
            document.getElementById('review-setup').classList.remove('hidden');
            document.getElementById('review-session').classList.add('hidden');
            document.removeEventListener('keydown', handleReviewKeyboard);
            updateReviewDateSelector();
        }
        
        async function handleFormSubmit(e) {
            e.preventDefault();
            if (currentEditId) return;
            if (!userId) { showNotification("Not connected."); return; }
            const front = document.getElementById('front');
            const back = document.getElementById('back');
            const beispiel = document.getElementById('beispiel');
            const translation = document.getElementById('translation');
            const speechBox = document.getElementById('speech');
            const beispielSpeechBox = document.getElementById('beispiel-speech');
            const { id: selectedFolderId, name: selectedFolderName } = getSelectedFolderDetails();

            const cardData = {
                front: front.value.trim(),
                back: back.value.trim(),
                speech: getSpeechRawValue(speechBox),
                beispiel: formatMultiLine(beispiel.value),
                beispielSpeech: getSpeechRawValue(beispielSpeechBox),
                translation: formatMultiLine(translation.value),
                folderId: selectedFolderId,
                folderName: selectedFolderName,
                createdAt: new Date().toISOString()
            };
            if (!cardData.front && !cardData.back) return;
            try {
                await addDoc(cardsCollectionRef, cardData);
                clearForm();
            } catch (error) { showNotification("Failed to save the card."); }
        }

        async function handleUpdateCard() {
             if (!currentEditId || !userId) return;
             const front = document.getElementById('front');
             const back = document.getElementById('back');
             const beispiel = document.getElementById('beispiel');
             const translation = document.getElementById('translation');
             const speechBox = document.getElementById('speech');
             const beispielSpeechBox = document.getElementById('beispiel-speech');
             const { id: selectedFolderId, name: selectedFolderName } = getSelectedFolderDetails();
             const cardData = {
                front: front.value.trim(),
                back: back.value.trim(),
                speech: getSpeechRawValue(speechBox),
                beispiel: formatMultiLine(beispiel.value),
                beispielSpeech: getSpeechRawValue(beispielSpeechBox),
                translation: formatMultiLine(translation.value),
                folderId: selectedFolderId,
                folderName: selectedFolderName,
                createdAt: allCards.find(c => c.id === currentEditId)?.createdAt || new Date().toISOString()
            };
            try {
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/cards`, currentEditId);
                await setDoc(docRef, cardData);
                showNotification("Card updated successfully.", "success");
                setEditMode(false);
            } catch (error) { showNotification("Failed to update card."); }
        }

        async function handleDeleteConfirmed() {
            if (!cardToDeleteId || !userId) return;
            const isReviewDelete = reviewSession.cards.length > 0;
            resetDeleteShortcut();
            
            try {
                let cardData = allCards.find(card => card.id === cardToDeleteId);
                if (!cardData && cardsCollectionRef) {
                    try {
                        const cardDoc = await getDoc(doc(cardsCollectionRef, cardToDeleteId));
                        if (cardDoc.exists()) {
                            cardData = { id: cardDoc.id, ...cardDoc.data() };
                        }
                    } catch (error) {
                        console.error('Failed to fetch card before deletion:', error);
                    }
                }
                if (cardData) {
                    await archiveCardBeforeDeletion(cardData);
                }
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/cards`, cardToDeleteId);
                await deleteDoc(docRef);
                
                if (isReviewDelete) {
                    const deletedIndex = reviewSession.cards.findIndex(c => c.id === cardToDeleteId);
                    if (deletedIndex > -1) {
                         reviewSession.cards.splice(deletedIndex, 1);
                         if (reviewSession.currentIndex >= deletedIndex) {
                             reviewSession.currentIndex = Math.max(0, reviewSession.currentIndex - 1);
                         }
                         if (reviewSession.cards.length === 0) {
                            endReviewSession();
                            showNotification("Last card in review deleted. Session ended.", "success");
                         } else {
                            renderReviewCard();
                         }
                    }
                }
                
                document.getElementById('delete-modal').classList.add('hidden');
                cardToDeleteId = null;
                showNotification("Card deleted.", "success");
            } catch (error) { showNotification("Failed to delete card."); }
        }
        
        async function applyLegacyFrontFixes(candidates, { triggerButton = null, confirmMessage = null, loadingText = 'Fixing...' } = {}) {
            if (!Array.isArray(candidates) || candidates.length === 0) {
                showNotification("No legacy image fronts detected.", "success");
                updateLegacyBadge();
                if (isLegacyViewActive()) {
                    renderLegacyFrontsView();
                }
                return false;
            }
            if (!userId || !cardsCollectionRef) {
                showNotification("You must be logged in to run the fix.");
                return false;
            }
            if (isFixingLegacyFronts) return false;

            if (confirmMessage) {
                const confirmed = window.confirm(confirmMessage);
                if (!confirmed) return false;
            }

            isFixingLegacyFronts = true;
            if (triggerButton) setButtonLoading(triggerButton, true, loadingText);

            const BATCH_LIMIT = 400;
            try {
                for (let index = 0; index < candidates.length; index += BATCH_LIMIT) {
                    const slice = candidates.slice(index, index + BATCH_LIMIT);
                    const batch = writeBatch(db);
                    slice.forEach(({ card, decoded }) => {
                        const docRef = doc(cardsCollectionRef, card.id);
                        batch.update(docRef, { front: decoded });
                    });
                    await batch.commit();
                    slice.forEach(({ card, decoded }) => {
                        card.front = decoded;
                    });
                    await sleep(50);
                }
                showNotification(`Fixed ${candidates.length} legacy image front${candidates.length === 1 ? '' : 's'}.`, "success");
                return true;
            } catch (error) {
                console.error("Failed to fix legacy image fronts:", error);
                showNotification("Failed to fix legacy image fronts.");
                return false;
            } finally {
                if (triggerButton) setButtonLoading(triggerButton, false);
                isFixingLegacyFronts = false;
                updateLegacyBadge();
                if (isLegacyViewActive()) {
                    renderLegacyFrontsView();
                }
            }
        }

        async function handleFixLegacyFronts() {
            const button = document.getElementById('fix-legacy-fronts-btn');
            const candidates = getLegacyFrontCandidates();
            const confirmMessage = candidates.length > 0
                ? `Fix ${candidates.length} legacy image front${candidates.length === 1 ? '' : 's'}? This updates the cards in place.`
                : null;
            await applyLegacyFrontFixes(candidates, { triggerButton: button, confirmMessage, loadingText: 'Fixing...' });
        }

        function triggerExportDownload(cards, format) {
            if (cards.length === 0) {
                showNotification("No cards match the selected criteria.", "success");
                return;
            }
            const today = new Date().toISOString().split('T')[0];
            let content, fileName, mimeType;

            if (format === 'json') {
                const sortedCards = [...cards].sort((a, b) => getCreatedAtTime(a.createdAt) - getCreatedAtTime(b.createdAt));
                const jsonData = sortedCards.map(data => ({ back: data.back || '', beispiel: data.beispiel || '' }));
                content = JSON.stringify(jsonData, null, 2);
                fileName = `${today}.json`;
                mimeType = 'application/json';
            } else { // txt format
                content = buildTsvFromCards(cards);
                fileName = `${today}.txt`;
                mimeType = 'text/plain;charset=utf-8';
            }
            triggerDownload(content, fileName, mimeType);
        }

        async function exportFoldersAsPackages(folderIds) {
            const ids = Array.isArray(folderIds) ? folderIds : [];
            if (ids.length === 0) {
                showNotification("Select at least one folder to export.", 'error');
                return;
            }

            const zip = new JSZip();
            let totalCards = 0;
            let exportedFolders = 0;
            const usedNames = new Set();

            ids.forEach(folderId => {
                const cards = allCards.filter(card => folderId === NO_FOLDER_VALUE ? !card.folderId : card.folderId === folderId);
                if (cards.length === 0) return;

                const folderMeta = folders.find(f => f.id === folderId);
                const fallbackName = folderId === NO_FOLDER_VALUE ? 'No Folder' : (cards[0]?.folderName || 'Untitled Folder');
                const folderName = folderMeta && folderMeta.name ? folderMeta.name : fallbackName;
                const sanitizedFolderName = ensureUniqueName(sanitizeFileName(folderName, 'folder'), usedNames);
                const folderZip = zip.folder(sanitizedFolderName);
                if (!folderZip) return;

                folderZip.file('cards.txt', buildTsvFromCards(cards));
                folderZip.file('metadata.json', JSON.stringify({
                    name: folderName,
                    exportedAt: new Date().toISOString(),
                    cardCount: cards.length
                }, null, 2));

                totalCards += cards.length;
                exportedFolders += 1;
            });

            if (totalCards === 0 || exportedFolders === 0) {
                showNotification("Selected folder(s) have no cards to export.", 'error');
                return;
            }

            const today = new Date().toISOString().split('T')[0];
            const blob = await zip.generateAsync({ type: 'blob' });
            triggerBlobDownload(blob, `deki-categories-${today}.zip`);
            showNotification(`Exported ${totalCards} card${totalCards === 1 ? '' : 's'} from ${exportedFolders} categor${exportedFolders === 1 ? 'y' : 'ies'}.`, 'success');
        }

        function getExportFolderCheckboxes() {
            return Array.from(document.querySelectorAll('#export-folder-selection input[type="checkbox"]'))
                .filter(input => input.id !== EXPORT_SELECT_ALL_ID);
        }

        function toggleAllExportFolders(checked) {
            getExportFolderCheckboxes().forEach(input => {
                input.checked = checked;
            });
        }

        function syncExportFolderSelectAllCheckbox() {
            const selectAllCheckbox = document.getElementById(EXPORT_SELECT_ALL_ID);
            if (!selectAllCheckbox) return;

            const folderCheckboxes = getExportFolderCheckboxes();
            if (folderCheckboxes.length === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
                selectAllCheckbox.disabled = true;
                return;
            }

            const checkedCount = folderCheckboxes.filter(input => input.checked).length;
            selectAllCheckbox.disabled = false;
            selectAllCheckbox.checked = checkedCount === folderCheckboxes.length;
            selectAllCheckbox.indeterminate = checkedCount > 0 && checkedCount < folderCheckboxes.length;
        }

        async function handleConfirmExport() {
            const format = document.querySelector('input[name="export-format"]:checked').value;
            const range = document.querySelector('input[name="export-range"]:checked').value;
            const clipboardOutputContainer = document.getElementById('clipboard-output-container');
            const clipboardOutput = document.getElementById('clipboard-output');
            let cardsToExport = [];
            let selectedFolders = [];

            clipboardOutputContainer.classList.add('hidden');

            if (range === 'all') {
                cardsToExport = [...allCards];
            } else if (range === 'date') { 
                const selectedDateNodes = document.querySelectorAll('#export-date-selection input[type="checkbox"]:checked');
                if (selectedDateNodes.length === 0) {
                    showNotification("Please select at least one date to export.");
                    return;
                }
                const selectedDates = Array.from(selectedDateNodes).map(el => el.value);
                cardsToExport = allCards.filter(card => card.createdAt && card.createdAt.split('T')[0] && selectedDates.includes(card.createdAt.split('T')[0]));
            } else if (range === 'folder') {
                const selectedFolderNodes = document.querySelectorAll('#export-folder-selection input[type="checkbox"]:checked:not(#export-folder-select-all-checkbox)');
                if (selectedFolderNodes.length === 0) {
                    showNotification("Please select at least one folder to export.");
                    return;
                }
                selectedFolders = Array.from(selectedFolderNodes).map(el => el.value);
                cardsToExport = allCards.filter(card => {
                    if (!card.folderId) {
                        return selectedFolders.includes(NO_FOLDER_VALUE);
                    }
                    return selectedFolders.includes(card.folderId);
                });
            }

            if (format === 'category-zip') {
                if (range !== 'folder') {
                    showNotification("Select one or more folders to export as categories.");
                    return;
                }
                await exportFoldersAsPackages(selectedFolders);
                document.getElementById('export-modal').classList.add('hidden');
                return;
            }

            if (cardsToExport.length === 0) {
                showNotification("No cards match the selected criteria.", "success");
                return;
            }
            
            let clipboardText = '';
            if (format === 'clipboard') {
                clipboardText = cardsToExport
                    .sort((a, b) => getCreatedAtTime(a.createdAt) - getCreatedAtTime(b.createdAt))
                    .map(data => {
                        const sanitizedBack = sanitizeForExport(data.back);
                        const sanitizedFront = sanitizeForExport(data.front, sanitizedBack);
                        return `${sanitizedBack}\t${sanitizedFront}`;
                    })
                    .join('\n');
            } else if (format === 'beispiel-speech') {
                clipboardText = cardsToExport
                    .sort((a, b) => getCreatedAtTime(a.createdAt) - getCreatedAtTime(b.createdAt))
                    .map(data => {
                        const resolvedBeispielSpeech = resolveBeispielSpeechValue(data.back, data.beispiel, data.beispielSpeech);
                        return sanitizeForExport(resolvedBeispielSpeech, '', {
                            preserveLeadingBr: true,
                            preserveSpacingAroundBr: true,
                            keepOuterWhitespace: true
                        });
                    })
                    .filter(text => !isBlank(text))
                    .join('\n');
            } else if (format === 'clipboard-back-only') {
                clipboardText = cardsToExport
                    .sort((a, b) => getCreatedAtTime(a.createdAt) - getCreatedAtTime(b.createdAt))
                    .map(data => sanitizeForExport(data.back))
                    .filter(text => !isBlank(text))
                    .join(', ');
            } else {
                triggerExportDownload(cardsToExport, format);
                document.getElementById('export-modal').classList.add('hidden');
                return;
            }

            const tempInput = document.createElement('textarea');
            tempInput.value = clipboardText;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
            
            showNotification("Copied to clipboard!", "success");
            document.getElementById('export-modal').classList.add('hidden');
        }

        function openExportModal() {
            if (allCards.length === 0) {
                showNotification("There are no cards to export.", "success");
                return;
            }
            document.getElementById('export-all-radio').checked = true;
            document.getElementById('export-date-selection').classList.add('hidden');
            document.getElementById('export-folder-selection').classList.add('hidden');
            document.getElementById('clipboard-output-container').classList.add('hidden');
            
            const dates = [...new Set(allCards.map(card => card.createdAt && card.createdAt.split('T')[0]).filter(Boolean))].sort().reverse();
            const exportDateSelection = document.getElementById('export-date-selection');
            exportDateSelection.innerHTML = '';

            if (dates.length > 0) {
                dates.forEach(date => {
                    const label = document.createElement('label');
                    label.className = 'flex items-center space-x-2 text-gray-300 py-1';
                    label.innerHTML = `<input type="checkbox" value="${date}" class="form-checkbox h-4 w-4 text-blue-500 bg-gray-700 border-gray-600 rounded"> <span>${date}</span>`;
                    exportDateSelection.appendChild(label);
                });
                document.getElementById('export-date-radio').disabled = false;
            } else {
                document.getElementById('export-date-radio').disabled = true;
            }
            
            const exportFolderSelection = document.getElementById('export-folder-selection');
            exportFolderSelection.innerHTML = '';
            const selectAllRow = document.createElement('label');
            selectAllRow.className = 'flex items-center space-x-2 text-gray-300 py-1 border-b border-gray-700 mb-1';
            selectAllRow.innerHTML = `<input type="checkbox" id="${EXPORT_SELECT_ALL_ID}" class="form-checkbox h-4 w-4 text-blue-500 bg-gray-700 border-gray-600 rounded"> <span>Select all folders</span>`;
            exportFolderSelection.appendChild(selectAllRow);
            const folderOptions = new Map();
            allCards.forEach(card => {
                const key = card.folderId || NO_FOLDER_VALUE;
                const folderMeta = folders.find(f => f.id === card.folderId);
                const displayName = folderMeta && folderMeta.name ? folderMeta.name : (card.folderName || 'No Folder');
                const label = key === NO_FOLDER_VALUE ? 'No Folder' : displayName;
                folderOptions.set(key, label);
            });
            Array.from(folderOptions.entries())
                .sort((a, b) => a[1].toLowerCase().localeCompare(b[1].toLowerCase()))
                .forEach(([value, label]) => {
                    const checkbox = document.createElement('label');
                    checkbox.className = 'flex items-center space-x-2 text-gray-300 py-1';
                    checkbox.innerHTML = `<input type="checkbox" value="${value}" class="form-checkbox h-4 w-4 text-blue-500 bg-gray-700 border-gray-600 rounded"> <span>${label}</span>`;
                    exportFolderSelection.appendChild(checkbox);
                });

            const defaultFolderValue = currentFolderId != null ? currentFolderId : NO_FOLDER_VALUE;
            getExportFolderCheckboxes().forEach(input => {
                if (input.value === defaultFolderValue) {
                    input.checked = true;
                }
            });
            syncExportFolderSelectAllCheckbox();

            document.getElementById('export-modal').classList.remove('hidden');
        }

        function handleGenerateOrCycleImage() {
            const front = document.getElementById('front');
            let value = front.value.trim();

            if (value.startsWith('<img src="') && value.endsWith('">')) {
                const src = value.substring(10, value.length - 2);
                const lastDot = src.lastIndexOf('.');
                if (lastDot === -1) {
                    showNotification("No extension found in image tag.");
                    return;
                }
                const base = src.substring(0, lastDot);
                const ext = src.substring(lastDot + 1).toLowerCase();
                let newExt = 'jpg';
                if (ext === 'jpg') newExt = 'webp';
                else if (ext === 'webp') newExt = 'png';
                else if (ext === 'png') newExt = 'svg';
                else if (ext === 'svg') newExt = 'jpg';
                front.value = `<img src="${base}.${newExt}">`;
            } else {
                const backValue = document.getElementById('back').value.trim();
                if (backValue) {
                    front.value = `<img src="${backValue}.jpg">`;
                } else {
                    showNotification("Please enter a word in the 'Back' field first.");
                }
            }
        }

        async function handleAuthSubmit(e) {
            e.preventDefault();
            const email = document.getElementById('auth-email').value;
            const password = document.getElementById('auth-password').value;
            if (!email || !password) {
                showNotification("Email and password are required.");
                return;
            }
            try {
                if (isSignUpMode) { await createUserWithEmailAndPassword(auth, email, password); } 
                else { await signInWithEmailAndPassword(auth, email, password); }
            } catch (error) {
                console.error("Authentication error:", error.message);
                showNotification(error.message);
            }
        }

        async function userSignOut() {
            try { await signOut(auth); } catch (error) { console.error("Sign out error", error); }
        }

        function toggleAuthMode() {
            isSignUpMode = !isSignUpMode;
            const authTitle = document.getElementById('auth-title');
            const authSubmitBtn = document.getElementById('auth-submit-btn');
            const authPromptText = document.getElementById('auth-prompt-text');
            const authToggleBtn = document.getElementById('auth-toggle-btn');
            
            if (isSignUpMode) {
                authTitle.textContent = 'Create Account';
                authSubmitBtn.textContent = 'Sign Up';
                authPromptText.textContent = 'Already have an account?';
                authToggleBtn.textContent = 'Sign In';
            } else {
                authTitle.textContent = 'Sign In';
                authSubmitBtn.textContent = 'Sign In';
                authPromptText.textContent = "Don't have an account?";
                authToggleBtn.textContent = 'Create one';
            }
        }
        
        function showLoginUI() {
            document.getElementById('login-view').classList.remove('hidden');
            document.getElementById('main-app').classList.add('hidden');
            if (unsubscribe) unsubscribe();
            if (foldersUnsubscribe) foldersUnsubscribe();
            if (deletedCardsUnsubscribe) deletedCardsUnsubscribe();
            if (exampleLibraryUnsubscribe) exampleLibraryUnsubscribe();
            allCards = [];
            deletedCards = [];
            folders = [];
            foldersCollectionRef = null;
            deletedCardsCollectionRef = null;
            deletedCardsUnsubscribe = null;
            exampleLibraryDocRef = null;
            exampleLibraryUnsubscribe = null;
            exampleLibrarySources = [];
            exampleSourcesLoaded = [];
            exampleWordMap = new Map();
            hasRestoredFolderPreference = false;
            currentReviewFolderId = ALL_FOLDERS_VALUE;
            currentReviewSessionId = null;
            currentReviewDate = 'all';
            currentViewFolderId = ALL_FOLDERS_VALUE;
            currentExampleFolderId = ALL_FOLDERS_VALUE;
            updateFolderSelection(NO_FOLDER_VALUE, { persist: false, updateSelect: false });
            renderFolderOptions();
            const cardListEl = document.getElementById('card-list');
            if(cardListEl) cardListEl.innerHTML = '';
            const sessionCounter = document.getElementById('session-counter');
            if(sessionCounter) sessionCounter.textContent = '0';
            const totalCounter = document.getElementById('total-counter');
            if(totalCounter) totalCounter.textContent = '0';
            const duplicatesView = document.getElementById('duplicates-view');
            if (duplicatesView) duplicatesView.classList.add('hidden');
            const duplicatesContainer = document.getElementById('duplicates-container');
            if (duplicatesContainer) duplicatesContainer.innerHTML = '';
            const duplicatesSummary = document.getElementById('duplicates-summary');
            if (duplicatesSummary) duplicatesSummary.textContent = '';
            const duplicatesEmptyState = document.getElementById('duplicates-empty-state');
            if (duplicatesEmptyState) duplicatesEmptyState.classList.add('hidden');
            const duplicatesSearchInput = document.getElementById('duplicates-search-input');
            if (duplicatesSearchInput) duplicatesSearchInput.value = '';
            updateDuplicateBadge();
            const deletedView = document.getElementById('deleted-view');
            if (deletedView) deletedView.classList.add('hidden');
            const deletedContainer = document.getElementById('deleted-container');
            if (deletedContainer) deletedContainer.innerHTML = '';
            const deletedSummary = document.getElementById('deleted-summary');
            if (deletedSummary) deletedSummary.textContent = '';
            const deletedEmptyState = document.getElementById('deleted-empty-state');
            if (deletedEmptyState) deletedEmptyState.classList.add('hidden');
            const legacyView = document.getElementById('legacy-view');
            if (legacyView) legacyView.classList.add('hidden');
            const legacyContainer = document.getElementById('legacy-container');
            if (legacyContainer) legacyContainer.innerHTML = '';
            const legacySummary = document.getElementById('legacy-summary');
            if (legacySummary) legacySummary.textContent = '';
            const legacyEmptyState = document.getElementById('legacy-empty-state');
            if (legacyEmptyState) legacyEmptyState.classList.add('hidden');
            updateLegacyBadge();
            updateDeletedBadge();
            renderExampleMatches([]);
            setExampleLibraryStatus('Sign in to search matches.');
        }

        function showAppUI(user) {
            document.getElementById('login-view').classList.add('hidden');
            document.getElementById('main-app').classList.remove('hidden');
            document.getElementById('user-email').textContent = user.email;
            document.getElementById('session-counter').textContent = '0';
            showMainAppView();
            updateDuplicateBadge();
            updateLegacyBadge();
            currentReviewFolderId = ALL_FOLDERS_VALUE;
            currentReviewSessionId = null;
            currentReviewDate = 'all';
            currentViewFolderId = ALL_FOLDERS_VALUE;
            currentExampleFolderId = ALL_FOLDERS_VALUE;
            refreshExampleMatches({ forceReloadLibrary: false });
            
            userId = user.uid;
            const collectionPath = `artifacts/${appId}/users/${userId}/cards`;
            const folderPath = `artifacts/${appId}/users/${userId}/folders`;
            cardsCollectionRef = collection(db, collectionPath);
            foldersCollectionRef = collection(db, folderPath);
            deletedCardsCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/deleted_cards`);
            exampleLibraryDocRef = doc(db, `artifacts/${appId}/users/${userId}/exampleLibrary/default`);

            if (exampleLibraryUnsubscribe) exampleLibraryUnsubscribe();
            exampleLibraryUnsubscribe = onSnapshot(exampleLibraryDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    if (data && Array.isArray(data.sources)) {
                        applyRemoteExampleLibrary(data.sources);
                    }
                } else if (exampleLibrarySources.length > 0) {
                    persistExampleLibrary().catch(err => console.warn('Failed to seed example library to Firestore', err));
                } else {
                    setExampleLibraryStatus('Upload A1/A2/B1 JSON to search for Beispiele. Files sync to your account.');
                }
            }, (error) => {
                console.error('Failed to sync example library from Firestore', error);
            });

            if (foldersUnsubscribe) foldersUnsubscribe();
            foldersUnsubscribe = onSnapshot(foldersCollectionRef, (snapshot) => {
                folders = [];
                snapshot.forEach(folderDoc => folders.push({ id: folderDoc.id, ...folderDoc.data() }));
                restoreFolderPreference();
                ensureCurrentFolderIsValid();
                renderFolderOptions();
                filterAndRenderCards();
            });

            if (deletedCardsUnsubscribe) deletedCardsUnsubscribe();
            const deletedQuery = query(deletedCardsCollectionRef, orderBy('deletedAt', 'desc'), limit(20));
            deletedCardsUnsubscribe = onSnapshot(deletedQuery, (snapshot) => {
                deletedCards = [];
                snapshot.forEach(docSnap => deletedCards.push({ id: docSnap.id, ...docSnap.data() }));
                updateDeletedBadge();
                if (isDeletedViewActive()) renderDeletedView();
            });

            if (unsubscribe) unsubscribe();
            unsubscribe = onSnapshot(cardsCollectionRef, (snapshot) => {
                allCards = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    allCards.push({ id: doc.id, ...data, reviewEdited: !!data.reviewEdited });
                });
                document.getElementById('total-counter').textContent = allCards.length;
                
                if (allCards.length > 0) {
                    const dates = allCards.map(c => c.createdAt && c.createdAt.split('T')[0]).filter(Boolean);
                    if (dates.length > 0) {
                        const latestDate = dates.sort().reverse()[0];
                        const cardsFromLatestDate = allCards.filter(c => c.createdAt && c.createdAt.startsWith(latestDate)).length;
                        document.getElementById('session-counter').textContent = cardsFromLatestDate;
                    } else {
                         document.getElementById('session-counter').textContent = 0;
                    }
                } else {
                    document.getElementById('session-counter').textContent = 0;
                }

                renderFolderOptions();
                filterAndRenderCards();
                updateReviewDateSelector();
                updateDuplicateBadge();
                updateLegacyBadge();
                refreshExampleMatches();
                if (isLegacyViewActive()) {
                    renderLegacyFrontsView();
                }
            });
        }

        function buildCardDataFromFields(fields, { createdAt, folderId, folderName }) {
            const frontField = (fields[0] || '').trim();
            const backField = (fields[1] || '').trim();
            const speechField = (fields[2] || '').trim();
            const beispielText = (fields[3] || '').split(/\s{2,}/).join('\n');
            const beispielSpeechField = (fields[4] || '').trim();
            const translationText = (fields[5] || '').split(/\s{2,}/).join('\n');

            const formattedBeispiel = formatMultiLine(beispielText);
            const backTagBase = prepareForSoundTag(backField);
            const computedSpeech = speechField || (backTagBase ? `[sound:${backTagBase}.mp3]` : '');
            const computedBeispielSpeech = resolveBeispielSpeechValue(backField, beispielText, beispielSpeechField);

            return {
                front: frontField,
                back: backField,
                speech: computedSpeech,
                beispiel: formattedBeispiel,
                beispielSpeech: computedBeispielSpeech,
                translation: formatMultiLine(translationText),
                folderId,
                folderName,
                createdAt: createdAt.toISOString()
            };
        }

        function extractBackValuesFromJson(payload) {
            let entries = [];
            if (Array.isArray(payload)) {
                entries = payload;
            } else if (payload && Array.isArray(payload.cards)) {
                entries = payload.cards;
            } else if (payload && Array.isArray(payload.words)) {
                entries = payload.words;
            }

            if (!entries.length) return [];

            return entries
                .map(item => {
                    if (typeof item === 'string') return item;
                    if (item && typeof item === 'object') {
                        return item.word || item.back || item.term || item.value || '';
                    }
                    return '';
                })
                .map(value => (typeof value === 'string' ? value.trim() : String(value || '').trim()))
                .filter(Boolean);
        }

        async function importCardsFromJsonFile(file, { folderId, folderName, importTimestamp, cardCounterRef }) {
            if (!file) return 0;

            let payload;
            try {
                const text = await file.text();
                payload = JSON.parse(text);
            } catch (error) {
                console.error(`Failed to parse JSON import from ${file?.name || 'file'}`, error);
                showNotification(`Could not read ${file?.name || 'JSON file'}.`, 'error');
                return 0;
            }

            const backValues = extractBackValuesFromJson(payload);
            if (!backValues.length) {
                showNotification(`${file?.name || 'JSON file'} contained no words to import.`, 'error');
                return 0;
            }

            const lines = backValues.map(value => `\t${value}`);
            return importCardLines(lines, {
                folderId,
                folderName,
                importTimestamp,
                cardCounterRef
            });
        }

        async function importCardLines(lines, { folderId, folderName, importTimestamp, cardCounterRef }) {
            if (!cardsCollectionRef || !userId) {
                throw new Error('Not connected.');
            }
            const counterRef = cardCounterRef || { value: 0 };
            let batch = writeBatch(db);
            let operationsInBatch = 0;
            let importedCount = 0;

            for (const line of lines) {
                const fields = parseTsvLine(line);
                const cardTimestamp = new Date(importTimestamp.getTime() + counterRef.value);
                counterRef.value += 1;

                const cardData = buildCardDataFromFields(fields, {
                    createdAt: cardTimestamp,
                    folderId,
                    folderName
                });
                const newCardRef = doc(collection(db, `artifacts/${appId}/users/${userId}/cards`));
                batch.set(newCardRef, cardData);
                operationsInBatch++;
                importedCount++;
                if (operationsInBatch === 450) {
                    await batch.commit();
                    batch = writeBatch(db);
                    operationsInBatch = 0;
                }
            }

            if (operationsInBatch > 0) {
                await batch.commit();
            }

            return importedCount;
        }

        function generateUniqueFolderName(baseName, reservedNames) {
            const cleanedBase = (baseName || '').trim() || 'Imported Category';
            const existingNames = reservedNames || new Set(folders.map(folder => (folder.name || '').toLowerCase()));
            let candidate = cleanedBase;
            let counter = 2;
            while (existingNames.has(candidate.toLowerCase())) {
                candidate = `${cleanedBase} (${counter})`;
                counter += 1;
            }
            existingNames.add(candidate.toLowerCase());
            return candidate;
        }

        async function createFolderForImport(baseName, { reservedNames = null } = {}) {
            if (!foldersCollectionRef) {
                throw new Error('Folder collection not ready.');
            }
            const uniqueName = generateUniqueFolderName(baseName, reservedNames);
            const docRef = await addDoc(foldersCollectionRef, {
                name: uniqueName,
                createdAt: new Date().toISOString()
            });
            return { id: docRef.id, name: uniqueName };
        }

        async function importCategoryArchive(file, importTimestamp, cardCounterRef) {
            const defaultFolderName = (file.name || 'Imported Category').replace(/\.zip$/i, '') || 'Imported Category';
            const zip = await JSZip.loadAsync(file);
            const folderGroups = new Map();
            const reservedNames = new Set(folders.map(folder => (folder.name || '').toLowerCase()));

            zip.forEach((relativePath, entry) => {
                if (!relativePath || entry.dir || relativePath.startsWith('__MACOSX/')) return;
                const parts = relativePath.split('/');
                const fileName = parts.pop();
                const folderKey = parts.length ? parts[0] : defaultFolderName;

                if (!folderGroups.has(folderKey)) {
                    folderGroups.set(folderKey, { files: [], metadata: null, rawName: folderKey });
                }
                const group = folderGroups.get(folderKey);
                if (!fileName) return;
                const lowerName = fileName.toLowerCase();
                if (lowerName === 'metadata.json') {
                    group.metadata = entry;
                } else if (lowerName.endsWith('.txt') || lowerName.endsWith('.tsv')) {
                    group.files.push(entry);
                }
            });

            let imported = 0;
            let categoriesCreated = 0;

            for (const [, group] of folderGroups.entries()) {
                if (!group.files.length) continue;

                let desiredName = group.rawName;
                if (group.metadata) {
                    try {
                        const metadataContent = await group.metadata.async('string');
                        const parsed = JSON.parse(metadataContent);
                        if (parsed && parsed.name) desiredName = parsed.name;
                    } catch (error) {
                        console.warn('Failed to read import metadata:', error);
                    }
                }

                let folderInfo;
                try {
                    folderInfo = await createFolderForImport(desiredName, { reservedNames });
                    categoriesCreated += 1;
                } catch (error) {
                    console.error('Could not create folder for import:', error);
                    continue;
                }

                for (const entry of group.files) {
                    const content = await entry.async('string');
                    const lines = content
                        .split(/\r?\n/)
                        .filter(line => {
                            const trimmed = line.trim();
                            return trimmed !== '' && !trimmed.startsWith('#');
                        });
                    if (lines.length === 0) continue;
                    imported += await importCardLines(lines, {
                        folderId: folderInfo.id,
                        folderName: folderInfo.name,
                        importTimestamp,
                        cardCounterRef
                    });
                }
            }

            return { imported, categoriesCreated };
        }

        async function importCardsFromFile(event) {
            const files = Array.from(event.target.files || []);
            if (files.length === 0) return;

            const resetInput = () => { event.target.value = ''; };

            if (!userId) {
                showNotification("You must be logged in to import cards.");
                resetInput();
                return;
            }

            const { id: selectedFolderId, name: selectedFolderName } = getSelectedFolderDetails();
            const importTimestamp = new Date();
            let totalImported = 0;
            let categoriesCreated = 0;
            const cardCounterRef = { value: 0 };

            try {
                for (const file of files) {
                    const lowerName = (file.name || '').toLowerCase();
                    if (lowerName.endsWith('.zip')) {
                        const { imported, categoriesCreated: importedCategories } = await importCategoryArchive(file, importTimestamp, cardCounterRef);
                        totalImported += imported;
                        categoriesCreated += importedCategories;
                        continue;
                    }
                    if (lowerName.endsWith('.json')) {
                        totalImported += await importCardsFromJsonFile(file, {
                            folderId: selectedFolderId,
                            folderName: selectedFolderName,
                            importTimestamp,
                            cardCounterRef
                        });
                        continue;
                    }

                    const content = await file.text();
                    const lines = content
                        .split(/\r?\n/)
                        .filter(line => {
                            const trimmed = line.trim();
                            return trimmed !== '' && !trimmed.startsWith('#');
                        });

                    if (lines.length === 0) {
                        continue;
                    }

                    totalImported += await importCardLines(lines, {
                        folderId: selectedFolderId,
                        folderName: selectedFolderName,
                        importTimestamp,
                        cardCounterRef
                    });
                }

                if (totalImported > 0) {
                    const categorySuffix = categoriesCreated > 0
                        ? ` and created ${categoriesCreated} categor${categoriesCreated === 1 ? 'y' : 'ies'}`
                        : '';
                    showNotification(`Successfully imported ${totalImported} cards${categorySuffix}!`, 'success');
                } else {
                    showNotification("The selected files are empty or contain no valid data.");
                }
            } catch (error) {
                console.error("Import error: ", error);
                showNotification("An error occurred during import.");
            } finally {
                resetInput();
            }
        }

        
        function normalizeSearchField(value) {
            if (value === null || value === undefined) return '';
            const rawString = typeof value === 'string' ? value : String(value);
            const withoutBreaks = unformatMultiLine(rawString);
            return withoutBreaks
                .replace(/<[^>]+>/g, ' ')
                .replace(/\[sound:[^\]]+\]/gi, ' ')
                .replace(/\s+/g, ' ')
                .trim()
                .toLowerCase();
        }

        function computeCardSearchScore(card, tokens) {
            if (!card || !Array.isArray(tokens) || tokens.length === 0) return null;
            const folderMeta = card.folderId ? folders.find(folder => folder.id === card.folderId) : null;
            const fields = {
                front: normalizeSearchField(card.front),
                back: normalizeSearchField(card.back),
                translation: normalizeSearchField(card.translation),
                beispiel: normalizeSearchField(card.beispiel),
                folder: normalizeSearchField((folderMeta && folderMeta.name) || card.folderName || '')
            };

            let score = 0;
            for (const token of tokens) {
                let tokenMatched = false;
                const frontMatch = fields.front.includes(token);
                const backMatch = fields.back.includes(token);
                const translationMatch = fields.translation.includes(token);
                const beispielMatch = fields.beispiel.includes(token);
                const folderMatch = fields.folder.includes(token);

                if (frontMatch || backMatch || translationMatch || beispielMatch || folderMatch) {
                    tokenMatched = true;
                    if (frontMatch) score += 6 + (fields.front.startsWith(token) ? 2 : 0);
                    if (backMatch) score += 6 + (fields.back.startsWith(token) ? 2 : 0);
                    if (translationMatch) score += 4 + (fields.translation.startsWith(token) ? 1 : 0);
                    if (beispielMatch) score += 1;
                    if (folderMatch) score += 0.5;
                }

                if (!tokenMatched) {
                    return null;
                }
            }

            return score;
        }

        function filterAndRenderCards() {
            const searchInput = document.getElementById('search-input');
            const searchTerm = (searchInput ? searchInput.value : '').toLowerCase().trim();
            const filteredByFolder = allCards.filter(card => cardMatchesFolder(card, currentViewFolderId));

            if (!searchTerm) {
                renderCards(filteredByFolder);
                return;
            }

            const tokens = searchTerm.split(/\s+/).filter(Boolean);
            const scoredCards = filteredByFolder
                .map(card => {
                    const score = computeCardSearchScore(card, tokens);
                    return score === null ? null : { card, score };
                })
                .filter(Boolean);

            scoredCards.sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                return getCreatedAtTime(b.card.createdAt) - getCreatedAtTime(a.card.createdAt);
            });

            renderCards(scoredCards.map(entry => entry.card), { sortByCreatedAt: false });
        }

        function populateDeleteDateSelection() {
            const container = document.getElementById('delete-date-selection');
            if (!container) return false;
            container.innerHTML = '';
            const dates = [...new Set(allCards
                .map(card => card.createdAt && card.createdAt.split('T')[0])
                .filter(Boolean))]
                .sort()
                .reverse();
            if (dates.length === 0) {
                const message = document.createElement('p');
                message.className = 'text-sm text-gray-500 py-1';
                message.textContent = 'No dates available.';
                container.appendChild(message);
                return false;
            }
            dates.forEach(date => {
                createSelectionCheckbox(container, date, date);
            });
            return true;
        }

        function populateDeleteFolderSelection() {
            const container = document.getElementById('delete-folder-selection');
            if (!container) return false;
            container.innerHTML = '';
            const counts = getFolderCardCounts();
            const options = [];
            const noFolderCount = counts[NO_FOLDER_VALUE] || 0;
            if (noFolderCount > 0) {
                options.push({ value: NO_FOLDER_VALUE, label: formatFolderLabel('No Folder', noFolderCount) });
            }
            const sortedFolders = [...folders].sort((a, b) => {
                const createdAtDiff = getCreatedAtTime(b.createdAt) - getCreatedAtTime(a.createdAt);
                if (createdAtDiff !== 0) {
                    return createdAtDiff;
                }
                const nameA = (a.name || '').toLowerCase();
                const nameB = (b.name || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });
            sortedFolders.forEach(folder => {
                const count = counts[folder.id] || 0;
                if (count > 0) {
                    const baseName = folder.name || 'Untitled Folder';
                    options.push({ value: folder.id, label: formatFolderLabel(baseName, count) });
                }
            });
            if (options.length === 0) {
                const message = document.createElement('p');
                message.className = 'text-sm text-gray-500 py-1';
                message.textContent = 'No folders with cards available.';
                container.appendChild(message);
                return false;
            }
            options.forEach(option => {
                createSelectionCheckbox(container, option.label, option.value);
            });
            return true;
        }

        function toggleDeleteModeSections(mode) {
            const dateSelection = document.getElementById('delete-date-selection');
            const folderSelection = document.getElementById('delete-folder-selection');
            if (!dateSelection || !folderSelection) return;
            if (mode === 'folder') {
                dateSelection.classList.add('hidden');
                folderSelection.classList.remove('hidden');
            } else {
                folderSelection.classList.add('hidden');
                dateSelection.classList.remove('hidden');
            }
        }

        function openDeleteCardsModal() {
            if (allCards.length === 0) {
                showNotification("There are no cards to delete.", "success");
                return;
            }
            const hasDateOptions = populateDeleteDateSelection();
            const hasFolderOptions = populateDeleteFolderSelection();
            if (!hasDateOptions && !hasFolderOptions) {
                showNotification("No cards available for deletion.", "success");
                return;
            }

            const deleteDateRadio = document.getElementById('delete-date-radio');
            const deleteFolderRadio = document.getElementById('delete-folder-radio');

            if (deleteDateRadio) deleteDateRadio.disabled = !hasDateOptions;
            if (deleteFolderRadio) deleteFolderRadio.disabled = !hasFolderOptions;

            const defaultMode = hasDateOptions ? 'date' : 'folder';
            if (deleteDateRadio) deleteDateRadio.checked = defaultMode === 'date';
            if (deleteFolderRadio) deleteFolderRadio.checked = defaultMode === 'folder';
            toggleDeleteModeSections(defaultMode);

            document.getElementById('delete-cards-modal').classList.remove('hidden');
        }

        async function deleteCardsWithArchive(cardsToDelete, { successMessage } = {}) {
            if (!cardsCollectionRef || !deletedCardsCollectionRef || !userId) {
                showNotification("You must be logged in to delete cards.", "error");
                return false;
            }
            if (!cardsToDelete || cardsToDelete.length === 0) {
                if (successMessage) {
                    showNotification(successMessage, 'success');
                }
                return true;
            }
            const BATCH_LIMIT = 400;
            try {
                for (let index = 0; index < cardsToDelete.length; index += BATCH_LIMIT) {
                    const slice = cardsToDelete.slice(index, index + BATCH_LIMIT);
                    const batch = writeBatch(db);
                    slice.forEach(card => {
                        const archivedPayload = buildArchivedCardPayload(card);
                        if (archivedPayload) {
                            const archiveDocRef = doc(deletedCardsCollectionRef);
                            batch.set(archiveDocRef, archivedPayload);
                        }
                        batch.delete(doc(cardsCollectionRef, card.id));
                    });
                    await batch.commit();
                }
                if (successMessage) {
                    showNotification(successMessage, 'success');
                }
                return true;
            } catch (error) {
                console.error("Delete error: ", error);
                showNotification("An error occurred during deletion.", "error");
                return false;
            }
        }

        async function handleConfirmDeleteCards() {
            const deleteModeInput = document.querySelector('input[name="delete-mode"]:checked');
            const deleteMode = deleteModeInput ? deleteModeInput.value : 'date';

            if (deleteMode === 'folder') {
                const selectedFolderNodes = document.querySelectorAll('#delete-folder-selection input[type="checkbox"]:checked');
                if (selectedFolderNodes.length === 0) {
                    showNotification("Please select at least one folder to delete cards from.");
                    return;
                }
                const selectedFolderIds = Array.from(selectedFolderNodes).map(el => el.value);
                const cardsToDelete = allCards.filter(card => {
                    const folderIdentifier = (card.folderId && String(card.folderId).trim().length > 0) ? card.folderId : NO_FOLDER_VALUE;
                    return selectedFolderIds.includes(folderIdentifier);
                });
                if (cardsToDelete.length === 0) {
                    showNotification("No cards found for the selected folders.", "success");
                    return;
                }
                const message = `Moved ${cardsToDelete.length} card${cardsToDelete.length === 1 ? '' : 's'} to Deleted history.`;
                const success = await deleteCardsWithArchive(cardsToDelete, { successMessage: message });
                if (success) {
                    document.getElementById('delete-cards-modal').classList.add('hidden');
                }
                return;
            }

            const selectedDateNodes = document.querySelectorAll('#delete-date-selection input[type="checkbox"]:checked');
            if (selectedDateNodes.length === 0) {
                showNotification("Please select at least one date to delete cards from.");
                return;
            }
            const selectedDates = Array.from(selectedDateNodes).map(el => el.value);
            const cardsToDelete = allCards.filter(card => card.createdAt && selectedDates.includes(card.createdAt.split('T')[0]));
            if (cardsToDelete.length === 0) {
                showNotification("No cards found for the selected dates.", "success");
                return;
            }
            const message = `Moved ${cardsToDelete.length} card${cardsToDelete.length === 1 ? '' : 's'} to Deleted history.`;
            const success = await deleteCardsWithArchive(cardsToDelete, { successMessage: message });
            if (success) {
                document.getElementById('delete-cards-modal').classList.add('hidden');
            }
        }

        async function handleConfirmDeleteFolder() {
            if (!pendingFolderDeleteId) {
                showNotification('No folder selected to delete.', 'error');
                return;
            }
            if (!foldersCollectionRef || !cardsCollectionRef || !deletedCardsCollectionRef || !userId) {
                showNotification('Not connected.', 'error');
                return;
            }

            const folderId = pendingFolderDeleteId;
            const folderName = pendingFolderDeleteName || 'Untitled Folder';
            const cardsInFolder = allCards.filter(card => card.folderId === folderId);

            const deleted = await deleteCardsWithArchive(cardsInFolder, { successMessage: null });
            if (!deleted) {
                return;
            }

            try {
                await deleteDoc(doc(foldersCollectionRef, folderId));
                if (currentFolderId === folderId) {
                    updateFolderSelection(NO_FOLDER_VALUE);
                }
                if (currentViewFolderId === folderId) {
                    currentViewFolderId = ALL_FOLDERS_VALUE;
                    const viewSelector = document.getElementById('view-folder-selector');
                    if (viewSelector) viewSelector.value = ALL_FOLDERS_VALUE;
                }
                if (currentReviewFolderId === folderId) {
                    currentReviewFolderId = ALL_FOLDERS_VALUE;
                    const reviewSelector = document.getElementById('review-folder-selector');
                    if (reviewSelector) reviewSelector.value = ALL_FOLDERS_VALUE;
                }
                populateDuplicatesFolderFilter();
                filterAndRenderCards();
                updateReviewDateSelector();
                closeDeleteFolderModal();
                const cardSuffix = cardsInFolder.length === 0
                    ? 'No cards were linked to this folder.'
                    : `${cardsInFolder.length === 1 ? '1 card' : `${cardsInFolder.length} cards`} moved to Deleted.`;
                showNotification(`Deleted "${folderName}". ${cardSuffix}`, 'success');
            } catch (error) {
                console.error('Failed to delete folder:', error);
                showNotification('Failed to delete folder.', 'error');
            }
        }

        function enterReviewEditMode() {
            if (reviewSession.currentIndex === -1) return;
            const card = reviewSession.cards[reviewSession.currentIndex];
            clearAutoSkipTimer();
            
            document.getElementById('review-beispiel').classList.add('hidden');
            const editBeispiel = document.getElementById('edit-beispiel');
            editBeispiel.classList.remove('hidden');
            editBeispiel.value = unformatMultiLine(card.beispiel || '');
            
            document.getElementById('review-translation').classList.add('hidden');
            const editTranslation = document.getElementById('edit-translation');
            editTranslation.classList.remove('hidden');
            editTranslation.value = unformatMultiLine(card.translation || '');
            
            document.querySelectorAll('.review-card .review-copy-btn, .review-card .copy-line-btn').forEach(btn => btn.classList.add('hidden'));
            document.getElementById('edit-review-card-btn').classList.add('hidden');
            document.getElementById('save-review-edit-btn').classList.remove('hidden');
            document.getElementById('cancel-review-edit-btn').classList.remove('hidden');
            isReviewEditing = true;
            editBeispiel.focus();
            setTimeout(() => {
                 const len = editBeispiel.value.length;
                 editBeispiel.setSelectionRange(len, len);
            }, 0);
        }

        function exitReviewEditMode() {
            renderReviewCard(); 
            document.getElementById('review-beispiel').classList.remove('hidden');
            document.getElementById('edit-beispiel').classList.add('hidden');

            document.getElementById('review-translation').classList.remove('hidden');
            document.getElementById('edit-translation').classList.add('hidden');
            
            document.querySelectorAll('.review-card .review-copy-btn, .review-card .copy-line-btn').forEach(btn => btn.classList.remove('hidden'));
            document.getElementById('edit-review-card-btn').classList.remove('hidden');
            document.getElementById('save-review-edit-btn').classList.add('hidden');
            document.getElementById('cancel-review-edit-btn').classList.add('hidden');
            isReviewEditing = false;
        }

        async function saveReviewEdit() {
            if (!isReviewEditing || reviewSession.currentIndex === -1) return false;
            
            const newBeispiel = formatMultiLine(document.getElementById('edit-beispiel').value);
            const newTranslation = formatMultiLine(document.getElementById('edit-translation').value);
            const card = reviewSession.cards[reviewSession.currentIndex];
            
            const backValue = card.back;
            const newBeispielSpeech = backValue ? buildBeispielSpeech(backValue, newBeispiel) : '';

            if (newBeispiel === card.beispiel && newTranslation === card.translation) {
                return true;
            }
            
            try {
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/cards`, card.id);
                await updateDoc(docRef, {
                    beispiel: newBeispiel,
                    translation: newTranslation,
                    beispielSpeech: newBeispielSpeech
                });
                card.beispiel = newBeispiel;
                card.translation = newTranslation;
                card.beispielSpeech = newBeispielSpeech;
                
                setLocalEditedState(card.id, true);
                await updateEditedCardsInFirestore(card.id, true);
                showNotification('Card updated successfully.', 'success');
                return true;
            } catch (error) { 
                showNotification('Failed to update card.');
                return false;
            }
        }

        async function afterSaveAction() {
            const isPauseTimerEnabled = document.getElementById('pause-timer-toggle').checked;
            
            exitReviewEditMode();

            if (isPauseTimerEnabled) {
                if (reviewSession.currentIndex < reviewSession.cards.length - 1) {
                    await handleReviewNav(1, true); // Pass true to auto-edit the next card
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
            } catch (error) {
                 console.error("Initialization error:", error);
                 showNotification("Application failed to start. Please refresh.");
                 return;
            }
            
            const backInput = document.getElementById('back');
            const beispielInput = document.getElementById('beispiel');
            const translationInput = document.getElementById('translation');
            const frontInput = document.getElementById('front');
            const folderSelectEl = document.getElementById('folder-select');
            const folderNameInput = document.getElementById('folder-name-input');
            const reviewFolderSelector = document.getElementById('review-folder-selector');
            const viewFolderSelector = document.getElementById('view-folder-selector');
            
            document.getElementById('auth-form').addEventListener('submit', handleAuthSubmit);
            if (folderSelectEl) {
                folderSelectEl.addEventListener('change', (event) => {
                    const selectionChanged = updateFolderSelection(event.target.value);
                    if (selectionChanged) {
                        filterAndRenderCards();
                    }
                });
            }
            if (reviewFolderSelector) {
                reviewFolderSelector.addEventListener('change', (event) => {
                    currentReviewFolderId = event.target.value;
                    updateReviewDateSelector();
                });
            }
            const reviewMissingToggle = document.getElementById('review-missing-only-toggle');
            if (reviewMissingToggle) {
                reviewMissingToggle.addEventListener('change', updateReviewDateSelector);
            }
            if (viewFolderSelector) {
                viewFolderSelector.addEventListener('change', (event) => {
                    currentViewFolderId = event.target.value;
                    filterAndRenderCards();
                });
            }
            document.getElementById('create-folder-btn').addEventListener('click', openFolderModal);
            document.getElementById('cancel-folder-btn').addEventListener('click', () => closeFolderModal());
            document.getElementById('save-folder-btn').addEventListener('click', handleCreateFolder);
            document.getElementById('folder-modal').addEventListener('click', (event) => {
                if (event.target === event.currentTarget) {
                    closeFolderModal();
                }
            });
            const deleteFolderBtn = document.getElementById('delete-folder-btn');
            if (deleteFolderBtn) {
                deleteFolderBtn.addEventListener('click', openDeleteFolderModal);
            }
            const cancelDeleteFolderBtn = document.getElementById('cancel-delete-folder-btn');
            if (cancelDeleteFolderBtn) {
                cancelDeleteFolderBtn.addEventListener('click', closeDeleteFolderModal);
            }
            const confirmDeleteFolderBtn = document.getElementById('confirm-delete-folder-btn');
            if (confirmDeleteFolderBtn) {
                confirmDeleteFolderBtn.addEventListener('click', handleConfirmDeleteFolder);
            }
            const deleteFolderModalEl = document.getElementById('delete-folder-modal');
            if (deleteFolderModalEl) {
                deleteFolderModalEl.addEventListener('click', (event) => {
                    if (event.target === event.currentTarget) {
                        closeDeleteFolderModal();
                    }
                });
            }
            if (folderNameInput) {
                folderNameInput.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        handleCreateFolder();
                    } else if (event.key === 'Escape') {
                        event.preventDefault();
                        closeFolderModal();
                    }
                });
            }
            
            document.getElementById('auth-toggle-btn').addEventListener('click', toggleAuthMode);
            document.getElementById('logout-btn').addEventListener('click', userSignOut);
            document.getElementById('anki-form').addEventListener('submit', handleFormSubmit);
            
            [frontInput, backInput, beispielInput, translationInput].forEach(input => {
                input.addEventListener('input', updateSpeechFields);
                input.addEventListener('blur', (e) => {
                    e.target.value = e.target.value.trim();
                });
            });

            document.getElementById('generate-img-tag-btn').addEventListener('click', handleGenerateOrCycleImage);
            document.getElementById('search-input').addEventListener('input', filterAndRenderCards);
            const exampleFilterInput = document.getElementById('example-match-filter');
            if (exampleFilterInput) exampleFilterInput.addEventListener('input', () => refreshExampleMatches({ forceReloadLibrary: false }));
            const exampleSourceFilter = document.getElementById('example-source-filter');
            if (exampleSourceFilter) exampleSourceFilter.addEventListener('change', () => refreshExampleMatches({ forceReloadLibrary: false }));
            const exampleFolderFilter = document.getElementById('example-folder-filter');
            if (exampleFolderFilter) exampleFolderFilter.addEventListener('change', () => {
                currentExampleFolderId = exampleFolderFilter.value || ALL_FOLDERS_VALUE;
                refreshExampleMatches({ forceReloadLibrary: false });
            });
            EXAMPLE_SOURCE_SLOTS.forEach(slot => {
                const uploadBtn = document.getElementById(`example-upload-btn-${slot.id}`);
                const uploadInput = document.getElementById(`example-upload-input-${slot.id}`);
                if (uploadBtn && uploadInput) {
                    uploadBtn.addEventListener('click', () => uploadInput.click());
                    uploadInput.addEventListener('change', (event) => handleExampleUpload(event, slot.id));
                }
                const downloadBtn = document.getElementById(`example-download-btn-${slot.id}`);
                if (downloadBtn) downloadBtn.addEventListener('click', () => handleDownloadExampleLibrary(slot.id));
            });
            const findExampleMatchesBtn = document.getElementById('find-example-matches-btn');
            if (findExampleMatchesBtn) findExampleMatchesBtn.addEventListener('click', () => refreshExampleMatches({ forceReloadLibrary: false }));
            const reloadExampleLibraryBtn = document.getElementById('refresh-example-library-btn');
            if (reloadExampleLibraryBtn) reloadExampleLibraryBtn.addEventListener('click', () => refreshExampleMatches({ forceReloadLibrary: true }));
            const showMoreExampleMatchesBtn = document.getElementById('example-match-show-more');
            if (showMoreExampleMatchesBtn) showMoreExampleMatchesBtn.addEventListener('click', handleShowMoreExampleMatches);
            document.getElementById('update-btn').addEventListener('click', handleUpdateCard);
            document.getElementById('cancel-btn').addEventListener('click', () => setEditMode(false));
            document.getElementById('confirm-delete-btn').addEventListener('click', handleDeleteConfirmed);
            document.getElementById('cancel-delete-btn').addEventListener('click', () => {
                resetDeleteShortcut();
                document.getElementById('delete-modal').classList.add('hidden');
            });
            document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-file-input').click());
            document.getElementById('import-file-input').addEventListener('change', importCardsFromFile);
            const fixLegacyFrontsBtn = document.getElementById('fix-legacy-fronts-btn');
            if (fixLegacyFrontsBtn) fixLegacyFrontsBtn.addEventListener('click', handleFixLegacyFronts);
            const showLegacyBtn = document.getElementById('show-legacy-btn');
            if (showLegacyBtn) showLegacyBtn.addEventListener('click', showLegacyFrontsView);
            const legacyBackBtn = document.getElementById('legacy-back-btn');
            if (legacyBackBtn) legacyBackBtn.addEventListener('click', showMainAppView);
            const legacyFixAllBtn = document.getElementById('legacy-fix-all-btn');
            if (legacyFixAllBtn) {
                legacyFixAllBtn.addEventListener('click', async () => {
                    if (isFixingLegacyFronts) return;
                    const candidates = getLegacyFrontCandidates();
                    const confirmMessage = candidates.length > 0
                        ? `Fix ${candidates.length} legacy image front${candidates.length === 1 ? '' : 's'}? This updates the cards in place.`
                        : null;
                    await applyLegacyFrontFixes(candidates, { triggerButton: legacyFixAllBtn, confirmMessage, loadingText: 'Fixing...' });
                });
            }
            const legacyContainer = document.getElementById('legacy-container');
            if (legacyContainer) {
                legacyContainer.addEventListener('click', async (event) => {
                    const fixBtn = event.target.closest('.legacy-fix-btn');
                    if (!fixBtn) return;
                    event.preventDefault();
                    if (isFixingLegacyFronts) return;
                    const cardId = fixBtn.dataset.cardId;
                    const candidates = getLegacyFrontCandidates().filter(item => item.card.id === cardId);
                    await applyLegacyFrontFixes(candidates, { triggerButton: fixBtn, loadingText: 'Fixing...' });
                });
            }
            const exampleMatchesContainer = document.getElementById('example-matches-container');
            if (exampleMatchesContainer) {
                exampleMatchesContainer.addEventListener('click', async (event) => {
                    const applyBtn = event.target.closest('.example-apply-btn');
                    if (!applyBtn) return;
                    const cardId = applyBtn.dataset.cardId;
                    const word = applyBtn.dataset.word;
                    const sourceId = applyBtn.dataset.sourceId;
                    const entryId = applyBtn.dataset.entryId;
                    try {
                        setButtonLoading(applyBtn, true, 'Adding...');
                        await handleApplyExamplesToCard(cardId, word, sourceId, entryId);
                    } catch (error) {
                        console.error('Failed to apply Beispiele:', error);
                        showNotification('Could not add Beispiele. Check console for details.', 'error', 3500);
                    } finally {
                        setButtonLoading(applyBtn, false);
                    }
                });
                exampleMatchesContainer.addEventListener('click', (event) => {
                    const copyBtn = event.target.closest('.example-copy-btn');
                    const copyable = copyBtn || event.target.closest('.example-copyable');
                    if (!copyable) return;
                    const text = copyable.dataset.text || '';
                    if (!text.trim()) return;
                    copyPlainTextToClipboard(text);
                    const highlightTarget = copyable.closest('.example-line') || copyable.closest('.example-word-row');
                    if (highlightTarget) {
                        highlightTarget.classList.add('copy-highlight');
                        setTimeout(() => highlightTarget.classList.remove('copy-highlight'), 400);
                    }
                    const copyType = (copyable.dataset.copyType || 'sentence').toLowerCase();
                    const label = copyType === 'word' ? 'Word' : 'Sentence';
                    showNotification(`${label} copied.`, 'success', 1200);
                });
            }
            document.getElementById('review-btn').addEventListener('click', () => {
                document.getElementById('main-app').classList.add('hidden');
                document.getElementById('review-modal').classList.remove('hidden');
            });
            document.getElementById('close-review-setup-btn').addEventListener('click', endReviewSession);
            document.getElementById('start-session-btn').addEventListener('click', startReviewSession);
            document.getElementById('next-card-btn').addEventListener('click', () => handleReviewNav(1));
            document.getElementById('prev-card-btn').addEventListener('click', () => handleReviewNav(-1));
            document.getElementById('end-review-btn').addEventListener('click', endReviewSession);
            document.getElementById('delete-review-card-btn').addEventListener('click', () => {
                resetDeleteShortcut();
                if (reviewSession.cards[reviewSession.currentIndex]) {
                    cardToDeleteId = reviewSession.cards[reviewSession.currentIndex].id;
                    document.getElementById('delete-modal').classList.remove('hidden'); 
                }
            });
            document.getElementById('export-btn').addEventListener('click', openExportModal);
            document.getElementById('confirm-export-btn').addEventListener('click', handleConfirmExport);
            document.getElementById('cancel-export-btn').addEventListener('click', () => {
                document.getElementById('export-modal').classList.add('hidden');
                document.getElementById('clipboard-output-container').classList.add('hidden');
            });
            document.getElementById('copy-clipboard-btn').addEventListener('click', () => {
                const tempInput = document.createElement('textarea');
                tempInput.value = document.getElementById('clipboard-output').value;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);
                showNotification("Copied to clipboard!", "success");
            });
            document.querySelectorAll('input[name="export-format"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    if (!radio.value.startsWith('clipboard')) {
                        document.getElementById('clipboard-output-container').classList.add('hidden');
                    }
                    if (radio.checked && radio.value === 'category-zip') {
                        const folderRadio = document.getElementById('export-folder-radio');
                        if (folderRadio) {
                            folderRadio.checked = true;
                            folderRadio.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    }
                });
            });
            document.getElementById('export-all-radio').addEventListener('change', (e) => {
                if(e.target.checked) {
                    document.getElementById('export-date-selection').classList.add('hidden');
                    document.getElementById('export-folder-selection').classList.add('hidden');
                }
            });
            document.getElementById('export-date-radio').addEventListener('change', (e) => {
                if(e.target.checked) {
                    document.getElementById('export-date-selection').classList.remove('hidden');
                    document.getElementById('export-folder-selection').classList.add('hidden');
                }
            });
            document.getElementById('export-folder-radio').addEventListener('change', (e) => {
                if(e.target.checked) {
                    document.getElementById('export-folder-selection').classList.remove('hidden');
                    document.getElementById('export-date-selection').classList.add('hidden');
                }
            });
            document.getElementById('export-folder-selection').addEventListener('change', (event) => {
                const target = event.target;
                if (!(target instanceof HTMLInputElement) || target.type !== 'checkbox') return;
                if (target.id === EXPORT_SELECT_ALL_ID) {
                    toggleAllExportFolders(target.checked);
                }
                syncExportFolderSelectAllCheckbox();
            });
            const deleteDateRadio = document.getElementById('delete-date-radio');
            if (deleteDateRadio) {
                deleteDateRadio.addEventListener('change', () => {
                    if (deleteDateRadio.checked) toggleDeleteModeSections('date');
                });
            }
            const deleteFolderRadio = document.getElementById('delete-folder-radio');
            if (deleteFolderRadio) {
                deleteFolderRadio.addEventListener('change', () => {
                    if (deleteFolderRadio.checked) toggleDeleteModeSections('folder');
                });
            }
            
            document.getElementById('review-session').addEventListener('click', (e) => {
                const lineCopyBtn = e.target.closest('.copy-line-btn');
                if(lineCopyBtn) {
                    const tempInput = document.createElement('textarea');
                    tempInput.value = lineCopyBtn.dataset.text;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempInput);
                    showNotification("Copied sentence!", "success", 1500);
                    lineCopyBtn.parentElement.classList.add('copy-highlight');
                    setTimeout(() => lineCopyBtn.parentElement.classList.remove('copy-highlight'), 400);
                    return;
                }

                const mainCopyBtn = e.target.closest('.review-copy-btn');
                if (mainCopyBtn) {
                    const copyType = mainCopyBtn.dataset.copyType;
                    if (copyType === 'beispiel-speech') {
                        copyBeispielSpeechTag();
                        return;
                    }
                    clearAutoSkipTimer();
                    const targetId = mainCopyBtn.dataset.target;
                    const contentEl = document.getElementById(targetId);
                    if (!contentEl) return;

                    const textToCopy = unformatMultiLine(contentEl.innerHTML);

                    const tempInput = document.createElement('textarea');
                    tempInput.value = textToCopy;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempInput);
                    
                    showNotification("Copied!", "success", 1500);

                    const isPauseTimerEnabled = document.getElementById('pause-timer-toggle').checked;
                    const isBackButton = mainCopyBtn.dataset.target === 'review-back';

                    if (isPauseTimerEnabled && isBackButton) {
                        if (!isReviewEditing) enterReviewEditMode();
                        return;
                    }
                    
                    const advance = () => { if (reviewSession.currentIndex < reviewSession.cards.length - 1) handleReviewNav(1); };
                    if (!isReviewEditing) {
                        const isDelayedSkip = document.getElementById('auto-skip-toggle').checked;
                        if (isDelayedSkip && !isPauseTimerEnabled) {
                            reviewSession.autoSkipTimer = setTimeout(advance, 55000);
                        } else if (!isDelayedSkip) {
                            advance();
                        }
                    }
                }
            });


            document.addEventListener('keydown', (e) => {
                if (isDuplicatesViewActive()) {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        showMainAppView();
                    }
                    return;
                }
                if (isDeletedViewActive()) {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        showMainAppView();
                    }
                    return;
                }
                if (isLegacyViewActive()) {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        showMainAppView();
                    }
                    return;
                }
                const folderModal = document.getElementById('folder-modal');
                if (e.key === 'Escape' && folderModal && !folderModal.classList.contains('hidden')) {
                    e.preventDefault();
                    closeFolderModal();
                    return;
                }
                const formInputs = ['front', 'back', 'beispiel', 'translation'];
                const reviewInputs = ['edit-beispiel', 'edit-translation'];
                const activeId = document.activeElement.id;

                if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                    let currentList = [];
                    if (formInputs.includes(activeId)) currentList = formInputs;
                    if (reviewInputs.includes(activeId)) currentList = reviewInputs;

                    if (currentList.length > 0) {
                        e.preventDefault();
                        const currentIndex = currentList.indexOf(activeId);
                        const direction = e.key === 'ArrowDown' ? 1 : -1;
                        const nextIndex = (currentIndex + direction + currentList.length) % currentList.length;
                        document.getElementById(currentList[nextIndex]).focus();
                    }
                }

                const otherModalOpen = document.querySelector('.modal-backdrop:not(#review-modal):not(.hidden)');
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || otherModalOpen) return;

                if (e.key === 'n' || e.key === 'N') {
                    const reviewModal = document.getElementById('review-modal');
                    if (folderModal && folderModal.classList.contains('hidden') && reviewModal && reviewModal.classList.contains('hidden')) {
                        e.preventDefault();
                        openFolderModal();
                        return;
                    }
                }
                
                if (document.getElementById('review-session').classList.contains('hidden')) {
                    if (e.key === 't') { 
                        e.preventDefault(); 
                        document.getElementById('generate-img-tag-btn').click(); 
                    } else if (e.key === 'r' || e.key === 'R') {
                        e.preventDefault();
                        document.getElementById('review-btn').click();
                    } else if (e.key === ' ') { 
                        e.preventDefault(); 
                        document.getElementById('review-modal').classList.contains('hidden') ? document.getElementById('review-btn').click() : document.getElementById('start-session-btn').click(); 
                    } else if (e.key === 'Enter' && !document.getElementById('review-modal').classList.contains('hidden') && !document.getElementById('review-setup').classList.contains('hidden')) { 
                        e.preventDefault(); 
                        document.getElementById('start-session-btn').click(); 
                    } else if (e.key === 'c' || e.key === 'C') {
                        e.preventDefault();
                        const firstCard = document.querySelector('#card-list .card-item .copy-btn');
                        if (firstCard) {
                            firstCard.click();
                        }
                    }
                }
            });
            renderFolderOptions();
            filterAndRenderCards();
            updateFolderDeleteButtonState();
            updateLegacyBadge();
            if (!exampleLibrarySources.length) {
                setExampleLibraryStatus('Upload A1/A2/B1 JSON to search for Beispiele. Files sync to your account.');
            }
            onAuthStateChanged(auth, user => { if (user) showAppUI(user); else showLoginUI(); });
            document.getElementById('delete-cards-btn').addEventListener('click', openDeleteCardsModal);
            document.getElementById('confirm-delete-cards-btn').addEventListener('click', handleConfirmDeleteCards);
            document.getElementById('cancel-delete-cards-btn').addEventListener('click', () => document.getElementById('delete-cards-modal').classList.add('hidden'));
            const showDuplicatesBtn = document.getElementById('show-duplicates-btn');
            if (showDuplicatesBtn) {
                showDuplicatesBtn.addEventListener('click', () => {
                    showDuplicatesView();
                });
            }
            const duplicatesBackBtn = document.getElementById('duplicates-back-btn');
            if (duplicatesBackBtn) duplicatesBackBtn.addEventListener('click', showMainAppView);
            const duplicatesSearchInput = document.getElementById('duplicates-search-input');
            if (duplicatesSearchInput) {
                duplicatesSearchInput.addEventListener('input', () => {
                    if (isDuplicatesViewActive()) renderDuplicatesView();
                });
            }
            const duplicatesFolderFilter = document.getElementById('duplicates-folder-filter');
            if (duplicatesFolderFilter) {
                duplicatesFolderFilter.addEventListener('change', () => {
                    if (isDuplicatesViewActive()) renderDuplicatesView();
                });
            }
            const duplicatesRefreshBtn = document.getElementById('duplicates-refresh-btn');
            if (duplicatesRefreshBtn) duplicatesRefreshBtn.addEventListener('click', () => renderDuplicatesView());
            const duplicatesExportBtn = document.getElementById('duplicates-export-btn');
            if (duplicatesExportBtn) duplicatesExportBtn.addEventListener('click', exportVisibleDuplicates);
            const duplicatesContainer = document.getElementById('duplicates-container');
            if (duplicatesContainer) {
                duplicatesContainer.addEventListener('click', (e) => {
                    const editBtn = e.target.closest('.duplicate-edit-btn');
                    if (editBtn) {
                        const card = allCards.find(c => c.id === editBtn.dataset.cardId);
                        if (card) {
                            showMainAppView();
                            setEditMode(true, card);
                        }
                        return;
                    }
                    const deleteBtn = e.target.closest('.duplicate-delete-btn');
                    if (deleteBtn) {
                        const cardId = deleteBtn.dataset.cardId;
                        if (cardId) {
                            cardToDeleteId = cardId;
                            const deleteModal = document.getElementById('delete-modal');
                            if (deleteModal) deleteModal.classList.remove('hidden');
                        }
                        return;
                    }
                    const copyBtn = e.target.closest('.duplicate-copy-btn');
                    if (copyBtn) {
                        const card = allCards.find(c => c.id === copyBtn.dataset.cardId);
                        if (card && card.back) {
                            const tempInput = document.createElement('textarea');
                            tempInput.value = unformatMultiLine(card.back);
                            document.body.appendChild(tempInput);
                            tempInput.select();
                            document.execCommand('copy');
                            document.body.removeChild(tempInput);
                            showNotification('Back copied to clipboard!', 'success', 1500);
                        }
                    }
                });
            }
            const showDeletedBtn = document.getElementById('show-deleted-btn');
            if (showDeletedBtn) showDeletedBtn.addEventListener('click', showDeletedView);
            const deletedBackBtn = document.getElementById('deleted-back-btn');
            if (deletedBackBtn) deletedBackBtn.addEventListener('click', showMainAppView);
            const deletedContainer = document.getElementById('deleted-container');
            if (deletedContainer) {
                deletedContainer.addEventListener('click', (e) => {
                    const restoreBtn = e.target.closest('.deleted-restore-btn');
                    if (restoreBtn) {
                        const card = deletedCards.find(c => c.id === restoreBtn.dataset.cardId);
                        if (card) restoreDeletedCard(card, { edit: false });
                        return;
                    }
                    const restoreEditBtn = e.target.closest('.deleted-restore-edit-btn');
                    if (restoreEditBtn) {
                        const card = deletedCards.find(c => c.id === restoreEditBtn.dataset.cardId);
                        if (card) restoreDeletedCard(card, { edit: true });
                        return;
                    }
                    const copyBtn = e.target.closest('.deleted-copy-btn');
                    if (copyBtn) {
                        const card = deletedCards.find(c => c.id === copyBtn.dataset.cardId);
                        if (card && card.back) {
                            const tempInput = document.createElement('textarea');
                            tempInput.value = unformatMultiLine(card.back);
                            document.body.appendChild(tempInput);
                            tempInput.select();
                            document.execCommand('copy');
                            document.body.removeChild(tempInput);
                            showNotification('Back copied to clipboard!', 'success', 1500);
                        }
                        return;
                    }
                    const removeBtn = e.target.closest('.deleted-remove-btn');
                    if (removeBtn) {
                        const cardId = removeBtn.dataset.cardId;
                        if (cardId) {
                            permanentlyDeleteArchivedCard(cardId);
                        }
                    }
                });
            }
            document.getElementById('edit-review-card-btn').addEventListener('click', enterReviewEditMode);
            
            document.getElementById('save-review-edit-btn').addEventListener('click', async () => {
                const success = await saveReviewEdit();
                if (success) {
                    afterSaveAction();
                }
            });

            document.getElementById('cancel-review-edit-btn').addEventListener('click', exitReviewEditMode);

            [document.getElementById('edit-beispiel'), document.getElementById('edit-translation')].forEach(input => {
                input.addEventListener('keydown', async e => {
                    if (e.key === 'Enter' && !e.shiftKey) { 
                        e.preventDefault(); 
                        const success = await saveReviewEdit();
                        if (success) {
                           afterSaveAction();
                        }
                    }
                    if (e.key === 'Escape') { e.preventDefault(); exitReviewEditMode(); }
                });
                input.addEventListener('paste', (e) => {
                    setTimeout(() => {
                        const textarea = e.target;
                        if (textarea.value.slice(-1) !== '\n') {
                            textarea.value += '\n';
                        }
                        textarea.scrollTop = textarea.scrollHeight;
                        textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
                    }, 1);
                });
            });
            document.getElementById('mark-edited-btn').addEventListener('click', async () => {
                if (reviewSession.currentIndex > -1) {
                    const cardId = reviewSession.cards[reviewSession.currentIndex].id;
                    if (reviewSession.editedCardIds.has(cardId)) {
                        setLocalEditedState(cardId, false);
                        await updateEditedCardsInFirestore(cardId, false);
                    } else {
                        setLocalEditedState(cardId, true);
                        await updateEditedCardsInFirestore(cardId, true);
                    }
                    renderReviewCard();
                }
            });
             document.getElementById('in-review-search-input').addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase().trim();
                if (!searchTerm) {
                    reviewSession.cards = [...reviewSession.originalCards];
                    reviewSession.currentIndex = reviewSession.cards.length > 0 ? 0 : -1;
                } else {
                    const filtered = reviewSession.originalCards.filter(card => {
                        return (card.front || '').toLowerCase().includes(searchTerm) ||
                               (card.back || '').toLowerCase().includes(searchTerm) ||
                               (card.beispiel || '').toLowerCase().includes(searchTerm) ||
                               (card.translation || '').toLowerCase().includes(searchTerm);
                    });
                    reviewSession.cards = filtered;
                    reviewSession.currentIndex = filtered.length > 0 ? 0 : -1;
                }
                renderReviewCard();
            });
        });
    </script>
</body>
</html>
