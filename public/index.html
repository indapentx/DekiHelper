<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deki Helper</title>
    <link rel="icon" href="shortcut.png"/>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        html { scroll-behavior: smooth; }
        body { font-family: 'Inter', sans-serif; background-color: #000; }
        .anki-input, .anki-readonly-box, #clipboard-output, textarea.anki-input { background-color: #1e1e1e; border: 1px solid #444; color: #ecf0f1; border-radius: 8px; padding: 12px; width: 100%; font-size: 16px; margin-top: 4px; transition: border-color 0.2s; }
        .anki-input:focus, #clipboard-output:focus, textarea.anki-input:focus { outline: none; border-color: #007acc; }
        .anki-readonly-box { min-height: 48px; display: flex; align-items: center; word-break: break-all; }
        .anki-label { color: #bdc3c7; font-weight: 600; font-size: 14px; }
        .btn { padding: 8px 16px; font-size: 0.875rem; border-radius: 7px; font-weight: 600; cursor: pointer; transition: all 0.2s; border: none; display: inline-flex; align-items: center; justify-content: center; gap: 6px; }
        .btn-sm { padding: 4px 10px; font-size: 0.8rem; }
        .btn-lg { padding: 10px 20px; font-size: 1.125rem; }
        .btn-primary { background-color: #007acc; color: white; } .btn-primary:hover:not(:disabled) { background-color: #005f9e; }
        .btn-secondary { background-color: #555; color: white; } .btn-secondary:hover:not(:disabled) { background-color: #444; }
        .btn-danger { background-color: #c93c3c; color: white; } .btn-danger:hover:not(:disabled) { background-color: #a52828; }
        .btn-success { background-color: #27ae60; color: white; } .btn-success:hover:not(:disabled) { background-color: #229954; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-icon { background: transparent; border: none; color: #777; padding: 4px; border-radius: 50%; } .btn-icon:hover { background-color: #333; color: #eee; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 50;}
        .modal-content { background-color: #1a1a1a; padding: 30px; border-radius: 12px; width: 90%; max-width: 500px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .card-item { background-color: #1e1e1e; border: 1px solid #333; padding: 16px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
        .card-item-content { flex-grow: 1; overflow: hidden; }
        .card-item-front { font-weight: 600; color: #eee; font-size: 1.1em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        .card-item-back { color: #bbb; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        #review-modal { background-color: #000; }
        .review-card { background-color: #1e1e1e; border-radius: 10px; padding: 14px 16px; min-height: 70px; display: flex; justify-content: space-between; align-items: center; text-align: left; }
        .review-content { font-size: 1.05rem; word-break: break-word; flex-grow: 1; }
        .review-copy-btn { background-color: #333; color: #fff; border: none; border-radius: 8px; padding: 12px 16px; cursor: pointer; align-self: center; margin-left: 16px; }
        .review-copy-btn:hover { background-color: #444; }
        .progress-bar-container { background-color: #333; border-radius: 9999px; height: 8px; width: 100%; overflow: hidden;}
        .progress-bar { background-color: #007acc; height: 100%; width: 0%; transition: width 0.3s ease; }
        .copy-highlight { background-color: rgba(0, 122, 204, 0.3); transition: background-color 0.1s ease-in-out; border-radius: 6px;}
        .toggle-label .dot { transition: transform 0.2s ease-in-out; }
        #auto-skip-toggle:checked ~ .dot { transform: translateX(100%); background-color: #27ae60; }
        #auto-skip-toggle:checked ~ .block { background-color: #2ecc71; }
        #pause-timer-toggle:checked ~ .dot { transform: translateX(100%); background-color: #c0392b; }
        #pause-timer-toggle:checked ~ .block { background-color: #e74c3c; }
        .duplicates-page { min-height: 100vh; }
        .duplicate-group { background-color: #111; border: 1px solid #333; border-radius: 12px; padding: 18px; }
        .duplicate-field-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: #888; }
        .duplicate-field-value { color: #f0f0f0; font-size: 0.95rem; word-break: break-word; white-space: pre-wrap; line-height: 1.5; }
        .duplicate-card-entry { background-color: #151515; border: 1px solid #2a2a2a; border-radius: 10px; padding: 16px; }
        .duplicate-card-meta { font-size: 0.75rem; color: #b0b0b0; word-break: break-word; }
        .duplicate-card-entry.highlight { border-color: #1d72f3; box-shadow: 0 0 0 1px rgba(29, 114, 243, 0.2); }
        .deleted-page { min-height: 100vh; }
        .deleted-card-entry { background-color: #151515; border: 1px solid #333; border-radius: 12px; padding: 16px; }
        .deleted-card-entry header { display: flex; flex-direction: column; gap: 4px; }
        .deleted-card-entry .meta { font-size: 0.75rem; color: #a0a0a0; display: flex; flex-wrap: wrap; gap: 6px; }
        .deleted-card-entry .field-label { font-size: 0.7rem; text-transform: uppercase; color: #888; letter-spacing: 0.04em; }
        .deleted-card-entry .field-value { font-size: 0.95rem; color: #f0f0f0; white-space: pre-wrap; word-break: break-word; line-height: 1.5; }
    </style>
</head>
<body class="text-white">
    <div id="login-view" class="h-screen flex flex-col items-center justify-center text-center p-4 hidden">
        <h1 class="text-4xl font-bold mb-4">Deki Helper</h1>
        <div class="w-full max-w-sm bg-[#1e1e1e] p-8 rounded-lg">
            <h2 id="auth-title" class="text-2xl font-bold mb-6 text-white">Sign In</h2>
            <form id="auth-form" class="space-y-4">
                <input type="email" id="auth-email" placeholder="Email" class="anki-input" required>
                <input type="password" id="auth-password" placeholder="Password" class="anki-input" required>
                <button type="submit" id="auth-submit-btn" class="btn btn-primary btn-lg w-full">Sign In</button>
            </form>
            <p class="text-sm text-gray-400 mt-6">
                <span id="auth-prompt-text">Don't have an account?</span>
                <button id="auth-toggle-btn" class="text-blue-400 hover:underline">Create one</button>
            </p>
        </div>
    </div>

    <div id="main-app" class="container mx-auto max-w-2xl p-4 sm:p-8 hidden">
        <form id="anki-form" class="space-y-6 mb-12">
            <div>
                <label for="folder-select" class="anki-label">Folder</label>
                <div class="flex items-center gap-3">
                    <select id="folder-select" class="anki-input flex-1"></select>
                    <button type="button" id="create-folder-btn" class="btn btn-secondary btn-sm whitespace-nowrap">
                        <i class="fas fa-folder-plus"></i> New Folder
                    </button>
                </div>
            </div>
            <div>
                <div class="flex justify-between items-center">
                    <label for="front" class="anki-label">Front</label>
                    <button type="button" id="generate-img-tag-btn" class="text-sm text-blue-400 hover:text-blue-300 cursor-pointer" title="Generate or Cycle Image Tag (t)">
                        <i class="fa-solid fa-wand-magic-sparkles"></i> Generate/Cycle Image
                    </button>
                </div>
                <input type="text" id="front" class="anki-input" autocomplete="off">
            </div>
            <div><label for="back" class="anki-label">Back</label><input type="text" id="back" class="anki-input" autocomplete="off"></div>
            <div><label class="anki-label">Speech</label><div id="speech" class="anki-readonly-box"></div></div>
            <div>
                <label for="beispiel" class="anki-label">Beispiel</label>
                <textarea id="beispiel" class="anki-input" autocomplete="off" rows="3"></textarea>
            </div>
            <div><label class="anki-label">Beispiel (Speech)</label><div id="beispiel-speech" class="anki-readonly-box"></div></div>
            <div>
                <label for="translation" class="anki-label">Translation</label>
                <textarea id="translation" class="anki-input" autocomplete="off" rows="3"></textarea>
                <div class="flex flex-wrap gap-3 mt-3">
                    <button type="button" id="translate-beispiel-btn" class="btn btn-primary btn-sm">
                        <i class="fas fa-language"></i> Translate Beispiel â†’ TR
                    </button>
                    <button type="button" id="set-deepl-key-btn" class="btn btn-secondary btn-sm">
                        <i class="fas fa-key"></i> Set DeepL Key
                    </button>
                </div>
                <p id="deepl-key-status" class="text-xs text-gray-500 mt-2"></p>
            </div>
            <button type="submit" style="display: none;"></button>
        </form>
        <div id="action-bar" class="mt-8 flex flex-col sm:flex-row sm:flex-wrap sm:items-start gap-4 sm:gap-3">
             <p class="text-base font-semibold text-gray-400 flex items-center gap-2">Cards: <span id="session-counter" title="Cards from latest session" class="text-green-400 font-bold">0</span> / <span id="total-counter" title="Total cards" class="text-blue-400 font-bold">0</span></p>
             <div id="default-actions" class="flex flex-col sm:flex-row sm:flex-wrap gap-3 w-full">
                <button id="import-btn" class="btn btn-secondary w-full sm:w-auto"><i class="fas fa-upload"></i> Import</button>
                <input type="file" id="import-file-input" class="hidden" accept=".txt, .tsv">
                <button id="review-btn" class="btn btn-secondary w-full sm:w-auto"><i class="fas fa-eye"></i> Review</button>
                <button id="bulk-translate-btn" class="btn btn-success w-full sm:w-auto"><i class="fas fa-language"></i> Translate Beispiele</button>
                <button id="export-btn" class="btn btn-primary w-full sm:w-auto"><i class="fas fa-download"></i> Export</button>
                <button id="show-duplicates-btn" class="btn btn-secondary w-full sm:w-auto">
                    <i class="fas fa-clone"></i> Duplicates
                    <span id="duplicate-count-badge" class="hidden text-xs font-semibold bg-red-500 text-white px-2 py-0.5 rounded-full"></span>
                </button>
                <button id="show-deleted-btn" class="btn btn-secondary w-full sm:w-auto">
                    <i class="fas fa-trash-restore"></i> Deleted
                    <span id="deleted-count-badge" class="hidden text-xs font-semibold bg-yellow-500 text-black px-2 py-0.5 rounded-full"></span>
                </button>
                <button id="delete-cards-btn" class="btn btn-danger w-full sm:w-auto"><i class="fas fa-trash-alt"></i> Delete by Date</button>
             </div>
             <div id="edit-actions" class="hidden space-x-4">
                <button id="update-btn" class="btn btn-primary"><i class="fas fa-check"></i> Update</button>
                <button id="cancel-btn" class="btn btn-secondary"><i class="fas fa-times"></i> Cancel</button>
             </div>
        </div>
        <hr class="border-gray-700 my-8">
        <div>
            <h2 class="text-2xl font-bold mb-4 text-gray-300">Saved Cards</h2>
            <div class="mb-4 flex flex-col sm:flex-row gap-3">
                <input type="text" id="search-input" class="anki-input flex-1" placeholder="Search in front, back, beispiel, translation...">
                <select id="view-folder-selector" class="anki-input sm:w-56" title="Filter cards by folder"></select>
            </div>
            <div id="card-list"></div>
        </div>

        <footer class="mt-12 pt-8 border-t border-gray-700 flex justify-between items-center">
            <div id="user-info" class="flex items-center gap-3">
                <span id="user-email" class="font-semibold text-gray-300 text-sm"></span>
            </div>
            <button id="logout-btn" class="btn btn-secondary">Sign Out</button>
        </footer>
    </div>
    <div id="review-modal" class="modal-backdrop hidden fixed inset-0 bg-black p-4 sm:p-8 z-50">
        <div class="w-full max-w-3xl mx-auto flex flex-col h-full">
            <div id="review-setup" class="flex-grow flex flex-col items-center justify-center">
                <h2 class="text-4xl font-bold mb-8">Start Review Session</h2>
                <div class="w-full max-w-xs space-y-4">
                    <div>
                        <label for="review-folder-selector" class="anki-label mb-2 block">Select Folder:</label>
                        <select id="review-folder-selector" class="anki-input"></select>
                    </div>
                    <div>
                        <label for="review-date-selector" class="anki-label mb-2 block">Select Date:</label>
                        <select id="review-date-selector" class="anki-input"></select>
                    </div>
                    <button id="start-session-btn" class="btn btn-primary btn-lg w-full mt-6">Start Session</button>
                    <button id="close-review-setup-btn" class="btn btn-secondary btn-lg w-full">Close</button>
                </div>
            </div>
            <div id="review-session" class="hidden flex-grow flex flex-col">
                <div class="flex flex-col md:flex-row justify-between items-center mb-2 text-gray-400 gap-4">
                    <div class="flex items-center gap-4">
                        <p id="review-progress-text" class="font-semibold"></p>
                        <p id="review-edited-text" class="font-semibold"></p>
                    </div>
                    <div class="flex flex-wrap items-center justify-center gap-x-4 gap-y-2">
                        <button id="edit-review-card-btn" class="btn btn-secondary"><i class="fas fa-pencil-alt"></i> Edit</button>
                        <button id="save-review-edit-btn" class="btn btn-success hidden"><i class="fas fa-check"></i> Save</button>
                        <button id="cancel-review-edit-btn" class="btn btn-secondary hidden"><i class="fas fa-times"></i> Cancel</button>
                        <button id="mark-edited-btn" class="btn btn-secondary" title="Mark as Edited (M)"><i class="fas fa-check"></i></button>
                        <button id="delete-review-card-btn" class="btn btn-danger"><i class="fas fa-trash-alt"></i></button>
                        <label class="toggle-label flex items-center cursor-pointer">
                            <span class="mr-2 text-sm font-medium">Skip Delay</span>
                            <div class="relative">
                                <input type="checkbox" id="auto-skip-toggle" class="sr-only">
                                <div class="block bg-gray-600 w-10 h-6 rounded-full"></div>
                                <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full"></div>
                            </div>
                        </label>
                         <label class="toggle-label flex items-center cursor-pointer">
                            <span class="mr-2 text-sm font-medium">Pause Timer</span>
                            <div class="relative">
                                <input type="checkbox" id="pause-timer-toggle" class="sr-only">
                                <div class="block bg-gray-600 w-10 h-6 rounded-full"></div>
                                <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full"></div>
                            </div>
                        </label>
                    </div>
                </div>
                <div class="progress-bar-container mb-6">
                    <div id="review-progress-bar" class="progress-bar"></div>
                </div>
                <div class="flex-grow flex flex-col justify-center space-y-2">
                     <div class="mb-4">
                        <input type="text" id="in-review-search-input" class="anki-input text-sm" placeholder="Search in current review session...">
                    </div>
                    <div>
                        <label class="anki-label ml-2 flex justify-between"><span>Front</span> <span class="text-gray-500">Shortcut: F</span></label>
                        <div class="review-card">
                            <span id="review-front" class="review-content"></span>
                            <button class="review-copy-btn" data-target="review-front" title="Copy Front (F)"><i class="fas fa-copy fa-lg"></i></button>
                        </div>
                    </div>
                    <div>
                        <label class="anki-label ml-2 flex justify-between"><span>Back</span> <span class="text-gray-500">Shortcut: B</span></label>
                        <div class="review-card">
                            <span id="review-back" class="review-content"></span>
                            <button class="review-copy-btn" data-target="review-back" title="Copy Back (B)"><i class="fas fa-copy fa-lg"></i></button>
                        </div>
                    </div>
                    <div>
                        <label class="anki-label ml-2 flex justify-between"><span>Beispiel</span> <span class="text-gray-500">Shortcut: E</span></label>
                        <div class="review-card">
                            <div id="review-beispiel" class="review-content flex-grow flex flex-col justify-center py-2 space-y-2"></div>
                            <textarea id="edit-beispiel" class="anki-input hidden" rows="4"></textarea>
                        </div>
                    </div>
                    <div>
                        <label class="anki-label ml-2 flex justify-between"><span>Translation</span></label>
                        <div class="review-card">
                            <div id="review-translation" class="review-content flex-grow flex flex-col justify-center py-2 space-y-2"></div>
                            <textarea id="edit-translation" class="anki-input hidden" rows="4"></textarea>
                        </div>
                    </div>
                </div>
                <div class="flex justify-between items-center mt-6">
                    <button id="prev-card-btn" class="btn btn-secondary btn-lg"><i class="fas fa-arrow-left"></i> Previous</button>
                    <button id="end-review-btn" class="btn btn-danger btn-lg">End Review</button>
                    <button id="next-card-btn" class="btn btn-secondary btn-lg">Next <i class="fas fa-arrow-right"></i></button>
                </div>
            </div>
        </div>
    </div>
    <div id="delete-modal" class="modal-backdrop hidden">
         <div class="modal-content text-center">
             <h2 class="text-2xl font-bold mb-4">Confirm Deletion</h2>
             <p class="text-gray-300 mb-6">Are you sure you want to delete this card?</p>
             <div class="flex justify-center items-center space-x-4">
                <button id="confirm-delete-btn" class="btn btn-danger">Yes, Delete</button>
                <button id="cancel-delete-btn" class="btn btn-secondary">Cancel</button>
             </div>
        </div>
    </div>
    <div id="duplicates-view" class="duplicates-page hidden container mx-auto max-w-5xl p-4 sm:p-8">
        <div class="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4 mb-6">
            <div>
                <h1 class="text-3xl font-bold">Duplicate Cards</h1>
                <p id="duplicates-summary" class="text-sm text-gray-400 mt-2"></p>
            </div>
            <div class="flex flex-wrap gap-2">
                <button id="duplicates-export-btn" class="btn btn-secondary btn-sm">
                    <i class="fas fa-download"></i> Export Visible
                </button>
                <button id="duplicates-back-btn" class="btn btn-secondary btn-sm">
                    <i class="fas fa-arrow-left"></i> Back to Cards
                </button>
            </div>
        </div>
        <div class="flex flex-col md:flex-row md:items-center gap-4 mb-6">
            <input id="duplicates-search-input" class="anki-input flex-1" placeholder="Search in front, back, translation, beispiel...">
            <select id="duplicates-folder-filter" class="anki-input md:w-56">
                <option value="__all__">All folders</option>
                <option value="__none__">No folder</option>
            </select>
            <button id="duplicates-refresh-btn" class="btn btn-secondary btn-sm md:whitespace-nowrap">
                <i class="fas fa-arrows-rotate"></i> Refresh
            </button>
        </div>
        <div id="duplicates-empty-state" class="hidden text-gray-500 text-center border border-dashed border-gray-700 rounded-lg p-10">
            No duplicate cards found.
        </div>
        <div id="duplicates-container" class="space-y-6"></div>
    </div>
    <div id="deleted-view" class="deleted-page hidden container mx-auto max-w-4xl p-4 sm:p-8">
        <div class="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4 mb-6">
            <div>
                <h1 class="text-3xl font-bold">Recently Deleted</h1>
                <p id="deleted-summary" class="text-sm text-gray-400 mt-2"></p>
            </div>
            <div class="flex flex-wrap gap-2">
                <button id="deleted-back-btn" class="btn btn-secondary btn-sm">
                    <i class="fas fa-arrow-left"></i> Back to Cards
                </button>
            </div>
        </div>
        <div id="deleted-empty-state" class="hidden text-gray-500 text-center border border-dashed border-gray-700 rounded-lg p-10">
            No deleted cards in history.
        </div>
        <div id="deleted-container" class="space-y-4"></div>
    </div>
    <div id="export-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-6">Export Options</h2>
            <div class="space-y-4">
                <div>
                    <h3 class="anki-label mb-2">Format</h3>
                    <div class="flex flex-col space-y-2">
                        <label class="flex items-center space-x-2">
                            <input type="radio" name="export-format" value="txt" class="form-radio" checked>
                            <span>TXT (for Anki)</span>
                        </label>
                        <label class="flex items-center space-x-2">
                            <input type="radio" name="export-format" value="json" class="form-radio">
                            <span>JSON</span>
                        </label>
                        <label class="flex items-center space-x-2">
                            <input type="radio" name="export-format" value="clipboard" class="form-radio">
                            <span>Copy to Clipboard (Back & Front)</span>
                        </label>
                        <label class="flex items-center space-x-2">
                            <input type="radio" name="export-format" value="clipboard-back-only" class="form-radio">
                            <span>Copy to Clipboard (Back only)</span>
                        </label>
                        <label class="flex items-center space-x-2">
                            <input type="radio" name="export-format" value="beispiel-speech" class="form-radio">
                            <span>Copy to Clipboard (Beispiel Speech)</span>
                        </label>
                    </div>
                </div>
                <hr class="border-gray-700 !my-6">
                <div>
                    <h3 class="anki-label mb-2">Cards to Export</h3>
                    <label class="flex items-center space-x-2">
                        <input type="radio" id="export-all-radio" name="export-range" value="all" class="form-radio" checked>
                        <span>All cards</span>
                    </label>
                    <label class="flex items-center space-x-2 mt-2">
                        <input type="radio" id="export-date-radio" name="export-range" value="date" class="form-radio">
                        <span>Cards from selected dates</span>
                    </label>
                    <div id="export-date-selection" class="hidden pl-6 pt-2 mt-2 max-h-32 overflow-y-auto border-l-2 border-gray-700">
                        <!-- Date checkboxes will be inserted here by JS -->
                    </div>
                </div>
                <div id="clipboard-output-container" class="hidden mt-6">
                    <label for="clipboard-output" class="anki-label mb-2">Formatted Text</label>
                    <div class="flex items-center gap-2">
                        <textarea id="clipboard-output" readonly class="text-sm flex-grow" rows="8"></textarea>
                        <button id="copy-clipboard-btn" class="btn btn-secondary self-start" title="Copy Text"><i class="fas fa-copy"></i></button>
                    </div>
                </div>
            </div>
            <div class="flex justify-end items-center space-x-4 mt-8">
               <button id="cancel-export-btn" class="btn btn-secondary">Cancel</button>
               <button id="confirm-export-btn" class="btn btn-primary">Export</button>
            </div>
       </div>
   </div>
    <div id="notification" class="fixed top-5 right-5 bg-red-600 text-white py-2 px-4 rounded-lg shadow-lg hidden z-50"><p id="notification-message"></p></div>
    <div id="delete-cards-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-6">Delete Cards by Date</h2>
            <div class="space-y-4">
                <div>
                    <h3 class="anki-label mb-2">Select Dates to Delete Cards From</h3>
                    <div id="delete-date-selection" class="pl-6 pt-2 mt-2 max-h-32 overflow-y-auto border-l-2 border-gray-700">
                        <!-- Date checkboxes will be inserted here by JS -->
                    </div>
                </div>
            </div>
            <div class="flex justify-end items-center space-x-4 mt-8">
                <button id="cancel-delete-cards-btn" class="btn btn-secondary">Cancel</button>
                <button id="confirm-delete-cards-btn" class="btn btn-danger">Delete Selected</button>
            </div>
        </div>
    </div>

    <div id="folder-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-4">Create Folder</h2>
            <div class="space-y-4">
                <div>
                    <label for="folder-name-input" class="anki-label mb-2 block">Folder Name</label>
                    <input type="text" id="folder-name-input" class="anki-input" placeholder="e.g. Grammar">
                </div>
            </div>
            <div class="flex justify-end items-center space-x-4 mt-8">
                <button id="cancel-folder-btn" class="btn btn-secondary">Cancel</button>
                <button id="save-folder-btn" class="btn btn-primary">Create</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, getDocs, query, doc, deleteDoc, setDoc, writeBatch, updateDoc, getDoc, orderBy, limit, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = { apiKey: "AIzaSyD6zpZUM_ABNngOX-RKFxwNoTqePDivrGE", authDomain: "deki-helper.firebaseapp.com", projectId: "deki-helper", storageBucket: "deki-helper.appspot.com", messagingSenderId: "612229919023", appId: "1:612229919023:web:c6507af0e5a2ddd84731da" };
        const appId = 'anki-card-generator-default';
        const NO_FOLDER_VALUE = '__none__';
        const ALL_FOLDERS_VALUE = '__all_folders__';
        const FOLDER_STORAGE_KEY = 'deki-helper-current-folder';
        const DEEPL_KEY_STORAGE_KEY = 'deki-helper-deepl-key';
        const DEEPL_SOURCE_LANG = 'DE';
        const DEEPL_TARGET_LANG = 'TR';
        const DEEPL_REQUEST_DELAY_MS = 250;
        const DEFAULT_DEEPL_KEY = '';
        const FIREBASE_FUNCTIONS_REGION = 'us-central1';
        const PRODUCTION_TRANSLATE_ENDPOINT = `https://${FIREBASE_FUNCTIONS_REGION}-${firebaseConfig.projectId}.cloudfunctions.net/translateWithDeepL`;
        const LOCAL_TRANSLATE_ENDPOINT = `http://localhost:5001/${firebaseConfig.projectId}/${FIREBASE_FUNCTIONS_REGION}/translateWithDeepL`;

        
        let app, auth, db, userId, cardsCollectionRef, unsubscribe;
        let foldersCollectionRef, foldersUnsubscribe;
        let deletedCardsCollectionRef, deletedCardsUnsubscribe;
        let currentEditId = null, cardToDeleteId = null, allCards = [];
        let deletedCards = [];
        let folders = [];
        let currentFolderId = null;
        let reviewSession = { cards: [], currentIndex: -1, autoSkipTimer: null, beispielCopyIndex: 0, editedCardIds: new Set(), originalCards: [] };
        let currentReviewFolderId = ALL_FOLDERS_VALUE;
        let currentReviewSessionId = null;
        let currentViewFolderId = ALL_FOLDERS_VALUE;
        let isSignUpMode = false;
        let isReviewEditing = false;
        let currentReviewDate = "all";
        let deleteShortcutState = { pending: false, timeoutId: null };
        let hasRestoredFolderPreference = false;
        let isBulkTranslating = false;
        
        function showNotification(message, level = 'error', duration = 3000) {
            const notification = document.getElementById('notification');
            const notificationMessage = document.getElementById('notification-message');
            notificationMessage.innerHTML = message;
            notification.className = `fixed top-5 right-5 text-white py-2 px-4 rounded-lg shadow-lg ${level === 'error' ? 'bg-red-600' : 'bg-green-600'}`;
            notification.classList.remove('hidden');
            setTimeout(() => { notification.classList.add('hidden'); }, duration);
        }

        function setButtonLoading(button, isLoading, loadingText = 'Processing...') {
            if (!button) return;
            if (isLoading) {
                if (!button.dataset.originalContent) {
                    button.dataset.originalContent = button.innerHTML;
                }
                button.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${loadingText}`;
                button.disabled = true;
            } else {
                if (button.dataset.originalContent) {
                    button.innerHTML = button.dataset.originalContent;
                    delete button.dataset.originalContent;
                }
                button.disabled = false;
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getStoredDeepLKey() {
            try {
                const key = localStorage.getItem(DEEPL_KEY_STORAGE_KEY);
                if (key && key.trim()) return key.trim();
            } catch (error) {
                console.error('Unable to access DeepL key in localStorage.', error);
            }
            return DEFAULT_DEEPL_KEY;
        }

        function updateDeepLKeyStatus() {
            const statusEl = document.getElementById('deepl-key-status');
            if (!statusEl) return;
            let storedKey = '';
            try {
                storedKey = localStorage.getItem(DEEPL_KEY_STORAGE_KEY) || '';
            } catch (error) {
                console.error('Unable to read DeepL key status.', error);
            }
            if (storedKey.trim()) {
                statusEl.textContent = 'DeepL key stored locally in this browser.';
            } else if (DEFAULT_DEEPL_KEY) {
                statusEl.textContent = 'Using embedded DeepL key. Replace it here if you prefer your own.';
            } else {
                statusEl.textContent = 'DeepL key not set. Provide it to enable translations.';
            }
        }

        function preloadDefaultDeepLKey() {
            if (!DEFAULT_DEEPL_KEY) return;
            try {
                const current = localStorage.getItem(DEEPL_KEY_STORAGE_KEY);
                if (!current || !current.trim()) {
                    localStorage.setItem(DEEPL_KEY_STORAGE_KEY, DEFAULT_DEEPL_KEY);
                }
            } catch (error) {
                console.error('Failed to preload DeepL key.', error);
            }
        }

        function normalizeSentencesFromBeispiel(value) {
            if (!value) return [];
            let raw = typeof value === 'string' ? value : String(value ?? '');
            if (raw.includes('<br')) {
                raw = unformatMultiLine(raw);
            }
            raw = raw.replace(/&nbsp;/gi, ' ');
            return raw
                .split(/\r?\n/)
                .map(line => line.trim())
                .filter(line => line.length > 0);
        }

        async function translateSentencesWithDeepL(sentences, apiKey) {
            if (!apiKey) throw new Error('DeepL API key is not set.');
            if (!sentences || sentences.length === 0) return [];

            const translateEndpoint = (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')
                ? LOCAL_TRANSLATE_ENDPOINT
                : PRODUCTION_TRANSLATE_ENDPOINT;

            let response;
            try {
                response = await fetch(translateEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        sentences,
                        apiKey,
                        targetLang: DEEPL_TARGET_LANG,
                        sourceLang: DEEPL_SOURCE_LANG || undefined
                    })
                });
            } catch (networkError) {
                console.error('DeepL proxy network error.', networkError);
                throw new Error('Network error while contacting the translation service.');
            }

            let payload;
            try {
                payload = await response.json();
            } catch (parseError) {
                console.error('DeepL proxy parse error.', parseError);
                throw new Error('Unexpected response from the translation service.');
            }

            if (!response.ok) {
                const errorMessage = payload?.error || `Translation request failed (${response.status}).`;
                throw new Error(errorMessage);
            }

            if (!payload || !Array.isArray(payload.translations)) {
                throw new Error('Unexpected response from the translation service.');
            }

            return payload.translations.map(text => (text || '').trim());
        }

        function promptForDeepLKey() {
            const currentKey = getStoredDeepLKey();
            const newKey = prompt('Enter your DeepL API key (leave blank to clear it):', currentKey);
            if (newKey === null) return;
            const trimmed = newKey.trim();
            try {
                if (trimmed) {
                    localStorage.setItem(DEEPL_KEY_STORAGE_KEY, trimmed);
                    showNotification('DeepL key saved locally.', 'success');
                } else {
                    localStorage.removeItem(DEEPL_KEY_STORAGE_KEY);
                    showNotification('DeepL key cleared.', 'success');
                }
            } catch (storageError) {
                console.error('Failed to persist DeepL key.', storageError);
                showNotification('Unable to store DeepL key in this browser.');
            }
            updateDeepLKeyStatus();
        }

        function clearAutoSkipTimer() {
            if (reviewSession.autoSkipTimer) {
                clearTimeout(reviewSession.autoSkipTimer);
                reviewSession.autoSkipTimer = null;
            }
        }

        function resetDeleteShortcut() {
            if (deleteShortcutState.timeoutId) {
                clearTimeout(deleteShortcutState.timeoutId);
                deleteShortcutState.timeoutId = null;
            }
            deleteShortcutState.pending = false;
        }



        function restoreFolderPreference() {
            if (hasRestoredFolderPreference) return;
            hasRestoredFolderPreference = true;
            try {
                const storedValue = localStorage.getItem(FOLDER_STORAGE_KEY);
                if (!storedValue) return;
                if (storedValue === NO_FOLDER_VALUE) {
                    currentFolderId = null;
                    return;
                }
                const exists = folders.some(folder => folder.id === storedValue);
                currentFolderId = exists ? storedValue : null;
            } catch (error) {
                console.warn('Failed to restore folder preference:', error);
            }
        }

        function persistFolderPreference() {
            try {
                localStorage.setItem(FOLDER_STORAGE_KEY, currentFolderId || NO_FOLDER_VALUE);
            } catch (error) {
                console.warn('Failed to persist folder preference:', error);
            }
        }

        function ensureCurrentFolderIsValid() {
            if (!currentFolderId) return;
            const exists = folders.some(folder => folder.id === currentFolderId);
            if (!exists) {
                currentFolderId = null;
                persistFolderPreference();
            }
        }

        function updateFolderSelection(value, { persist = true, updateSelect = true } = {}) {
            const normalized = value === NO_FOLDER_VALUE ? null : value;
            const previous = currentFolderId;
            currentFolderId = normalized;
            const changed = previous !== currentFolderId;
            if (persist && changed) persistFolderPreference();
            if (updateSelect) {
                const folderSelect = document.getElementById('folder-select');
                if (folderSelect) {
                    const targetValue = normalized != null ? normalized : NO_FOLDER_VALUE;
                    if (folderSelect.value !== targetValue) {
                        folderSelect.value = targetValue;
                    }
                }
            }
            return changed;
        }

        function getCurrentFolderMeta() {
            if (!currentFolderId) return null;
            return folders.find(folder => folder.id === currentFolderId) || null;
        }

        function getSelectedFolderDetails() {
            const meta = getCurrentFolderMeta();
            if (meta) {
                return { id: meta.id, name: meta.name || null };
            }
            if (!currentFolderId) {
                return { id: null, name: null };
            }
            const folderSelect = document.getElementById('folder-select');
            if (folderSelect) {
                const option = Array.from(folderSelect.options).find(opt => opt.value === currentFolderId);
                if (option) {
                    const baseName = option.dataset && option.dataset.folderName
                        ? option.dataset.folderName
                        : (option.textContent || null);
                    return { id: currentFolderId, name: baseName };
                }
            }
            return { id: currentFolderId, name: null };
        }

        function renderFolderOptions() {
            const folderSelect = document.getElementById('folder-select');
            if (!folderSelect) return;

            const selectedValue = (currentFolderId != null ? currentFolderId : NO_FOLDER_VALUE);
            folderSelect.innerHTML = '';
            const counts = getFolderCardCounts();

            const noFolderOption = document.createElement('option');
            noFolderOption.value = NO_FOLDER_VALUE;
            noFolderOption.dataset.folderName = '';
            noFolderOption.textContent = formatFolderLabel('No Folder', counts[NO_FOLDER_VALUE]);
            folderSelect.appendChild(noFolderOption);

            const sortedFolders = [...folders].sort((a, b) => {
                const createdAtDiff = getCreatedAtTime(b.createdAt) - getCreatedAtTime(a.createdAt);
                if (createdAtDiff !== 0) {
                    return createdAtDiff;
                }
                const nameA = (a.name || '').toLowerCase();
                const nameB = (b.name || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });

            sortedFolders.forEach(folder => {
                const option = document.createElement('option');
                option.value = folder.id;
                const baseName = folder.name || 'Untitled Folder';
                option.dataset.folderName = baseName;
                option.textContent = formatFolderLabel(baseName, counts[folder.id]);
                folderSelect.appendChild(option);
            });

            if (currentFolderId && !sortedFolders.some(folder => folder.id === currentFolderId)) {
                updateFolderSelection(NO_FOLDER_VALUE, { updateSelect: false });
            }

            folderSelect.value = (currentFolderId != null ? currentFolderId : NO_FOLDER_VALUE);
            const previousViewFolder = currentViewFolderId;
            renderViewFolderOptions();
            renderReviewFolderOptions();
            if (currentViewFolderId !== previousViewFolder) {
                filterAndRenderCards();
            }
            updateReviewDateSelector();
            populateDuplicatesFolderFilter();
        }

        function openFolderModal() {
            const modal = document.getElementById('folder-modal');
            const input = document.getElementById('folder-name-input');
            if (!modal || !input) return;

            input.value = '';
            modal.classList.remove('hidden');
            setTimeout(() => input.focus(), 0);
        }

        function closeFolderModal() {
            const modal = document.getElementById('folder-modal');
            if (!modal) return;
            modal.classList.add('hidden');
        }

        async function handleCreateFolder() {
            const input = document.getElementById('folder-name-input');
            if (!input) return;

            const name = input.value.trim();
            if (!name) {
                showNotification('Please enter a folder name.');
                return;
            }
            if (!userId || !foldersCollectionRef) {
                showNotification('Not connected.');
                return;
            }

            const duplicate = folders.some(folder => (folder.name || '').toLowerCase() === name.toLowerCase());
            if (duplicate) {
                showNotification('A folder with this name already exists.');
                return;
            }

            try {
                const docRef = await addDoc(foldersCollectionRef, {
                    name,
                    createdAt: new Date().toISOString()
                });
                const selectionChanged = updateFolderSelection(docRef.id, { updateSelect: false });
                const folderSelect = document.getElementById('folder-select');
                if (folderSelect) {
                    let option = Array.from(folderSelect.options).find(opt => opt.value === docRef.id);
                    const optionLabel = formatFolderLabel(name, 0);
                    if (!option) {
                        option = document.createElement('option');
                        option.value = docRef.id;
                        option.dataset.folderName = name;
                        option.textContent = optionLabel;
                        folderSelect.appendChild(option);
                    } else {
                        option.dataset.folderName = name;
                        option.textContent = optionLabel;
                    }
                    folderSelect.value = docRef.id;
                }
                if (selectionChanged) {
                    filterAndRenderCards();
                }
                closeFolderModal();
                showNotification('Folder created successfully.', 'success');
            } catch (error) {
                console.error('Failed to create folder:', error);
                showNotification('Could not create folder.');
            }
        }

        function cardMatchesFolder(card, folderValue) {
            if (folderValue === ALL_FOLDERS_VALUE) return true;
            if (!folderValue || folderValue === NO_FOLDER_VALUE) {
                return !card.folderId;
            }
            return card.folderId === folderValue;
        }

        function formatFolderLabel(baseName, count) {
            const safeName = baseName && baseName.trim().length > 0 ? baseName : 'Untitled Folder';
            const cardCount = Number.isFinite(count) ? count : 0;
            return `${safeName} (${cardCount})`;
        }

        function getFolderCardCounts() {
            const counts = {
                [ALL_FOLDERS_VALUE]: allCards.length,
                [NO_FOLDER_VALUE]: 0
            };
            folders.forEach(folder => {
                counts[folder.id] = 0;
            });
            allCards.forEach(card => {
                const folderKey = card.folderId ? card.folderId : NO_FOLDER_VALUE;
                if (!Number.isFinite(counts[folderKey])) {
                    counts[folderKey] = 0;
                }
                counts[folderKey] += 1;
            });
            return counts;
        }

        function buildFolderSelectOptions() {
            const counts = getFolderCardCounts();
            const options = [
                { value: ALL_FOLDERS_VALUE, label: formatFolderLabel('All Folders', counts[ALL_FOLDERS_VALUE]) },
                { value: NO_FOLDER_VALUE, label: formatFolderLabel('No Folder', counts[NO_FOLDER_VALUE]) }
            ];
            const sortedFolders = [...folders].sort((a, b) => {
                const createdAtDiff = getCreatedAtTime(b.createdAt) - getCreatedAtTime(a.createdAt);
                if (createdAtDiff !== 0) {
                    return createdAtDiff;
                }
                const nameA = (a.name || '').toLowerCase();
                const nameB = (b.name || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });
            sortedFolders.forEach(folder => {
                options.push({ value: folder.id, label: formatFolderLabel(folder.name || 'Untitled Folder', counts[folder.id]) });
            });
            return options;
        }

        function populateFolderSelect(selectElement, currentValue) {
            if (!selectElement) return currentValue || ALL_FOLDERS_VALUE;
            const options = buildFolderSelectOptions();
            const fragment = document.createDocumentFragment();
            let hasCurrentValue = false;
            options.forEach(option => {
                const optionEl = document.createElement('option');
                optionEl.value = option.value;
                optionEl.textContent = option.label;
                fragment.appendChild(optionEl);
                if (option.value === currentValue) {
                    hasCurrentValue = true;
                }
            });
            selectElement.innerHTML = '';
            selectElement.appendChild(fragment);
            const valueToApply = hasCurrentValue ? currentValue : ALL_FOLDERS_VALUE;
            selectElement.value = valueToApply;
            return valueToApply;
        }

        function renderReviewFolderOptions() {
            const selector = document.getElementById('review-folder-selector');
            currentReviewFolderId = populateFolderSelect(selector, currentReviewFolderId);
        }

        function renderViewFolderOptions() {
            const selector = document.getElementById('view-folder-selector');
            currentViewFolderId = populateFolderSelect(selector, currentViewFolderId);
        }

        function buildReviewSessionId(selectedDate, folderValue) {
            const datePart = selectedDate === 'all' ? 'date_all' : `date_${selectedDate}`;
            let folderPart = 'folder_none';
            if (folderValue === ALL_FOLDERS_VALUE) {
                folderPart = 'folder_all';
            } else if (folderValue && folderValue !== NO_FOLDER_VALUE) {
                folderPart = `folder_${folderValue}`;
            }
            return `${datePart}__${folderPart}`;
        }

        function prepareForSoundTag(text) { 
            if (!text) return ''; 
            return text.trim(); 
        }
        
        function formatMultiLine(text) {
            if (!text) return '';
            return text
                .split(/\r?\n/)
                .map(line => line.trim())
                .filter(line => line.length > 0)
                .join('<br>');
        }

        function unformatMultiLine(text) {
            return text.replace(/\s*<br\s*\/?>\s*/gi, '\n').trim();
        }

        function buildBeispielSpeech(backText, beispielText) {
            const tagBase = prepareForSoundTag(backText);
            if (!tagBase) return '';

            const normalizedBeispiel = unformatMultiLine(beispielText || '');
            const sentences = normalizedBeispiel
                ? normalizedBeispiel.split(/\r?\n/).map(line => line.trim()).filter(line => line.length > 0)
                : [];

            if (sentences.length <= 1) {
                return `[sound:s_${tagBase}.mp3]`;
            }

            const soundTags = sentences.map((_, index) => {
                const suffix = index === 0 ? '' : index + 1;
                return `[sound:s_${tagBase}${suffix}.mp3]`;
            });

            return soundTags.join('<br>');
        }

        function isBlank(value) {
            if (value == null) return true;
            if (typeof value === 'string') return value.trim() === '';
            return String(value).trim() === '';
        }

        function sanitizeForExport(value, fallback = '') {
            let text = isBlank(value) ? (fallback != null ? fallback : '') : value;
            if (text == null) text = '';
            return String(text)
                .replace(/[\r\n]+/g, '<br>')
                .replace(/\s*(<br\s*\/?>)\s*/gi, '<br>')
                .replace(/^(<br>)+/, '')
                .replace(/(<br>)+$/, '')
                .replace(/\t/g, ' ')
                .trim();
        }

        function getCreatedAtTime(value) {
            if (!value) return 0;
            if (typeof value === 'object' && typeof value.seconds === 'number') {
                const millis = value.seconds * 1000;
                const extra = value.nanoseconds ? Math.floor(value.nanoseconds / 1e6) : 0;
                return millis + extra;
            }
            const time = new Date(value).getTime();
            return Number.isFinite(time) ? time : 0;
        }

        function normalizeDuplicateValue(value) {
            if (!value) return '';
            return String(value)
                .replace(/<br\s*\/?>/gi, ' ')
                .replace(/\s+/g, ' ')
                .trim()
                .toLowerCase();
        }

        function createDuplicateKey(card) {
            if (!card) return '';
            const frontKey = normalizeDuplicateValue(card.front);
            const backKey = normalizeDuplicateValue(card.back);
            if (!frontKey && !backKey) return '';
            return `${frontKey}|||${backKey}`;
        }

        function findDuplicateGroups(cards) {
            const groups = new Map();
            cards.forEach(card => {
                const key = createDuplicateKey(card);
                if (!key) return;
                if (!groups.has(key)) {
                    groups.set(key, []);
                }
                groups.get(key).push(card);
            });
            return Array.from(groups.values()).filter(group => group.length > 1);
        }

        function formatDuplicateField(value) {
            if (!value) return 'â€”';
            const cleaned = String(value)
                .replace(/<br\s*\/?>/gi, ' ')
                .replace(/\s+/g, ' ')
                .trim();
            return cleaned || 'â€”';
        }

        function formatDuplicateTimestamp(value) {
            const time = getCreatedAtTime(value);
            if (!time) return 'Unknown';
            const date = new Date(time);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day} ${hours}:${minutes}`;
        }

        function resolveFolderName(card) {
            if (!card) return 'No folder';
            if (!card.folderId) return 'No folder';
            const folderMeta = folders.find(folder => folder.id === card.folderId);
            if (folderMeta && folderMeta.name) return folderMeta.name;
            if (card.folderName) return card.folderName;
            return `Folder ID: ${card.folderId}`;
        }

        function formatDuplicateDisplayValue(value) {
            if (!value) return 'â€”';
            const normalized = unformatMultiLine(String(value));
            return normalized && normalized.trim() ? normalized : 'â€”';
        }

        function createDuplicateFieldElement(label, value) {
            const wrapper = document.createElement('div');
            wrapper.className = 'space-y-1';
            const labelEl = document.createElement('p');
            labelEl.className = 'duplicate-field-label';
            labelEl.textContent = label;
            const valueEl = document.createElement('div');
            valueEl.className = 'duplicate-field-value';
            valueEl.textContent = formatDuplicateDisplayValue(value);
            wrapper.append(labelEl, valueEl);
            return wrapper;
        }

        function isDuplicatesViewActive() {
            const view = document.getElementById('duplicates-view');
            return view ? !view.classList.contains('hidden') : false;
        }

        function populateDuplicatesFolderFilter() {
            const filterSelect = document.getElementById('duplicates-folder-filter');
            if (!filterSelect) return;

            const previousValue = filterSelect.value || '__all__';
            filterSelect.innerHTML = '';

            const baseOptions = [
                { value: '__all__', label: 'All folders' },
                { value: '__none__', label: 'No folder' }
            ];
            baseOptions.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.value;
                option.textContent = opt.label;
                filterSelect.appendChild(option);
            });

            const sortedFolders = [...folders].sort((a, b) => {
                const nameA = (a.name || '').toLowerCase();
                const nameB = (b.name || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });
            sortedFolders.forEach(folder => {
                const option = document.createElement('option');
                option.value = folder.id;
                option.textContent = folder.name || 'Untitled Folder';
                filterSelect.appendChild(option);
            });

            const availableValues = Array.from(filterSelect.options).map(opt => opt.value);
            filterSelect.value = availableValues.includes(previousValue) ? previousValue : '__all__';
        }

        function buildDuplicateViewModel({ searchTerm = '', folderFilter = '__all__' } = {}) {
            const baseGroups = findDuplicateGroups(allCards);
            const totalDuplicateCards = baseGroups.reduce((sum, group) => sum + group.length, 0);
            let filteredGroups = baseGroups;

            if (folderFilter === '__none__') {
                filteredGroups = filteredGroups.filter(group => group.some(card => !card.folderId));
            } else if (folderFilter && folderFilter !== '__all__') {
                filteredGroups = filteredGroups.filter(group => group.some(card => card.folderId === folderFilter));
            }

            const normalizedSearch = searchTerm.toLowerCase();
            if (normalizedSearch) {
                filteredGroups = filteredGroups.filter(group => {
                    return group.some(card => {
                        const folderName = resolveFolderName(card).toLowerCase();
                        if (folderName.includes(normalizedSearch)) return true;
                        if ((card.id || '').toLowerCase().includes(normalizedSearch)) return true;
                        return [card.front, card.back, card.translation, card.beispiel, card.speech, card.beispielSpeech]
                            .some(field => (field || '').toLowerCase().includes(normalizedSearch));
                    });
                });
            }

            const filteredCardCount = filteredGroups.reduce((sum, group) => sum + group.length, 0);

            return {
                baseGroups,
                filteredGroups,
                totalDuplicateCards,
                filteredCardCount
            };
        }

        function updateDuplicateBadge() {
            const badge = document.getElementById('duplicate-count-badge');
            if (!badge) return;
            const duplicateGroups = findDuplicateGroups(allCards);
            if (duplicateGroups.length === 0) {
                badge.classList.add('hidden');
                badge.textContent = '';
            } else {
                badge.textContent = duplicateGroups.length.toString();
                badge.classList.remove('hidden');
            }
            if (isDuplicatesViewActive()) {
                renderDuplicatesView();
            }
        }

        function renderDuplicatesView() {
            const container = document.getElementById('duplicates-container');
            const summary = document.getElementById('duplicates-summary');
            const emptyState = document.getElementById('duplicates-empty-state');
            const searchInput = document.getElementById('duplicates-search-input');
            const folderFilterSelect = document.getElementById('duplicates-folder-filter');
            if (!container || !summary || !emptyState) return;

            populateDuplicatesFolderFilter();

            const searchTerm = (searchInput ? searchInput.value : '').trim();
            const folderFilter = folderFilterSelect ? folderFilterSelect.value : '__all__';

            const { baseGroups, filteredGroups, totalDuplicateCards } = buildDuplicateViewModel({ searchTerm, folderFilter });

            if (baseGroups.length === 0) {
                summary.textContent = 'No duplicate cards detected.';
            } else {
                summary.textContent = `${baseGroups.length} duplicate group${baseGroups.length > 1 ? 's' : ''} covering ${totalDuplicateCards} card${totalDuplicateCards > 1 ? 's' : ''}.`;
            }

            container.innerHTML = '';

            if (filteredGroups.length === 0) {
                emptyState.classList.remove('hidden');
                return;
            }
            emptyState.classList.add('hidden');

            filteredGroups
                .slice()
                .sort((a, b) => {
                    if (b.length !== a.length) return b.length - a.length;
                    const newestB = b.reduce((max, card) => Math.max(max, getCreatedAtTime(card.createdAt)), 0);
                    const newestA = a.reduce((max, card) => Math.max(max, getCreatedAtTime(card.createdAt)), 0);
                    if (newestB !== newestA) return newestB - newestA;
                    const frontB = formatDuplicateField(b[0].front);
                    const frontA = formatDuplicateField(a[0].front);
                    return frontA.localeCompare(frontB);
                })
                .forEach(group => {
                    const groupCard = document.createElement('div');
                    groupCard.className = 'duplicate-group space-y-5';

                    const header = document.createElement('div');
                    header.className = 'flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3';

                    const title = document.createElement('div');
                    const groupFront = formatDuplicateField(group[0].front);
                    const groupBack = formatDuplicateField(group[0].back);
                    const titleFront = document.createElement('p');
                    titleFront.className = 'text-lg font-semibold text-gray-100';
                    titleFront.textContent = groupFront !== 'â€”' ? groupFront : 'No Front';
                    const titleBack = document.createElement('p');
                    titleBack.className = 'text-sm text-gray-400';
                    titleBack.textContent = groupBack !== 'â€”' ? groupBack : 'No Back';
                    title.append(titleFront, titleBack);
                    header.appendChild(title);

                    const badgeWrapper = document.createElement('div');
                    badgeWrapper.className = 'flex flex-wrap gap-2 items-center';

                    const countPill = document.createElement('span');
                    countPill.className = 'text-xs font-semibold text-gray-300 bg-gray-800 px-2 py-1 rounded-full';
                    countPill.textContent = `${group.length} card${group.length > 1 ? 's' : ''}`;
                    badgeWrapper.appendChild(countPill);

                    const folderPill = document.createElement('span');
                    folderPill.className = 'text-xs text-gray-400';
                    const uniqueFolders = Array.from(new Set(group.map(card => resolveFolderName(card))));
                    folderPill.textContent = `Folders: ${uniqueFolders.join(', ')}`;
                    badgeWrapper.appendChild(folderPill);

                    header.appendChild(badgeWrapper);
                    groupCard.appendChild(header);

                    const groupCardsWrapper = document.createElement('div');
                    groupCardsWrapper.className = 'space-y-4';

                    const cardsForRender = group.slice().sort((a, b) => getCreatedAtTime(a.createdAt) - getCreatedAtTime(b.createdAt));
                    cardsForRender.forEach(card => {
                        const cardEntry = document.createElement('div');
                        cardEntry.className = 'duplicate-card-entry space-y-4';

                        const matchesFolder =
                            folderFilter === '__all__' ||
                            (folderFilter === '__none__' && !card.folderId) ||
                            (folderFilter !== '__none__' && folderFilter === card.folderId);
                        if (matchesFolder && folderFilter !== '__all__') {
                            cardEntry.classList.add('highlight');
                        }

                        const meta = document.createElement('div');
                        meta.className = 'duplicate-card-meta flex flex-wrap gap-2';
                        const folderName = resolveFolderName(card);
                        const metaSegments = [
                            formatDuplicateTimestamp(card.createdAt),
                            'â€¢',
                            folderName,
                            'â€¢',
                            `ID: ${card.id}`
                        ];
                        metaSegments.forEach((segment, index) => {
                            const span = document.createElement('span');
                            span.textContent = segment;
                            meta.appendChild(span);
                            if (index === metaSegments.length - 1) return;
                        });
                        cardEntry.appendChild(meta);

                        const primaryGrid = document.createElement('div');
                        primaryGrid.className = 'grid gap-4 md:grid-cols-2';
                        primaryGrid.appendChild(createDuplicateFieldElement('Front', card.front));
                        primaryGrid.appendChild(createDuplicateFieldElement('Back', card.back));
                        primaryGrid.appendChild(createDuplicateFieldElement('Translation', card.translation));
                        primaryGrid.appendChild(createDuplicateFieldElement('Beispiel', card.beispiel));
                        cardEntry.appendChild(primaryGrid);

                        const optionalGrid = document.createElement('div');
                        optionalGrid.className = 'grid gap-4 md:grid-cols-2';
                        let hasOptional = false;
                        const optionalFields = [
                            { label: 'Speech', value: card.speech },
                            { label: 'Beispiel Speech', value: card.beispielSpeech }
                        ];
                        optionalFields.forEach(field => {
                            if (formatDuplicateDisplayValue(field.value) !== 'â€”') {
                                optionalGrid.appendChild(createDuplicateFieldElement(field.label, field.value));
                                hasOptional = true;
                            }
                        });
                        if (hasOptional) {
                            cardEntry.appendChild(optionalGrid);
                        }

                        const actionsRow = document.createElement('div');
                        actionsRow.className = 'flex flex-wrap items-center gap-2';

                        const editBtn = document.createElement('button');
                        editBtn.className = 'btn btn-secondary btn-sm duplicate-edit-btn';
                        editBtn.dataset.cardId = card.id;
                        editBtn.innerHTML = '<i class="fas fa-pen"></i> Edit';
                        actionsRow.appendChild(editBtn);

                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'btn btn-danger btn-sm duplicate-delete-btn';
                        deleteBtn.dataset.cardId = card.id;
                        deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i> Delete';
                        actionsRow.appendChild(deleteBtn);

                        const copyBtn = document.createElement('button');
                        copyBtn.className = 'btn btn-secondary btn-sm duplicate-copy-btn';
                        copyBtn.dataset.cardId = card.id;
                        copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy Back';
                        actionsRow.appendChild(copyBtn);

                        cardEntry.appendChild(actionsRow);
                        groupCardsWrapper.appendChild(cardEntry);
                    });

                    groupCard.appendChild(groupCardsWrapper);
                    container.appendChild(groupCard);
                });
        }

        function showMainAppView() {
            const mainApp = document.getElementById('main-app');
            const duplicatesView = document.getElementById('duplicates-view');
            const deletedView = document.getElementById('deleted-view');
            if (mainApp) mainApp.classList.remove('hidden');
            if (duplicatesView) duplicatesView.classList.add('hidden');
            if (deletedView) deletedView.classList.add('hidden');
            const duplicatesSearchInput = document.getElementById('duplicates-search-input');
            if (duplicatesSearchInput && !isDuplicatesViewActive()) {
                duplicatesSearchInput.blur();
            }
        }

        function showDuplicatesView() {
            renderDuplicatesView();
            const mainApp = document.getElementById('main-app');
            const duplicatesView = document.getElementById('duplicates-view');
            const deletedView = document.getElementById('deleted-view');
            const reviewModal = document.getElementById('review-modal');
            if (mainApp) mainApp.classList.add('hidden');
            if (deletedView) deletedView.classList.add('hidden');
            if (duplicatesView) duplicatesView.classList.remove('hidden');
            if (reviewModal) reviewModal.classList.add('hidden');
            const searchInput = document.getElementById('duplicates-search-input');
            if (searchInput) searchInput.focus();
        }

        function showDeletedView() {
            renderDeletedView();
            const mainApp = document.getElementById('main-app');
            const duplicatesView = document.getElementById('duplicates-view');
            const deletedView = document.getElementById('deleted-view');
            const reviewModal = document.getElementById('review-modal');
            if (mainApp) mainApp.classList.add('hidden');
            if (duplicatesView) duplicatesView.classList.add('hidden');
            if (deletedView) deletedView.classList.remove('hidden');
            if (reviewModal) reviewModal.classList.add('hidden');
        }

        function exportVisibleDuplicates() {
            const searchInput = document.getElementById('duplicates-search-input');
            const folderFilterSelect = document.getElementById('duplicates-folder-filter');
            const searchTerm = (searchInput ? searchInput.value : '').trim();
            const folderFilter = folderFilterSelect ? folderFilterSelect.value : '__all__';

            const { filteredGroups } = buildDuplicateViewModel({ searchTerm, folderFilter });
            if (filteredGroups.length === 0) {
                showNotification('No duplicates to export.', 'error');
                return;
            }

            const seen = new Set();
            const exportCards = [];
            filteredGroups.forEach(group => {
                group.forEach(card => {
                    if (seen.has(card.id)) return;
                    seen.add(card.id);
                    exportCards.push({
                        id: card.id,
                        front: card.front || '',
                        back: card.back || '',
                        translation: card.translation || '',
                        beispiel: card.beispiel || '',
                        speech: card.speech || '',
                        beispielSpeech: card.beispielSpeech || '',
                        folderId: card.folderId || '',
                        folderName: resolveFolderName(card),
                        createdAt: card.createdAt || ''
                    });
                });
            });

            const payload = {
                generatedAt: new Date().toISOString(),
                duplicateGroupCount: filteredGroups.length,
                cardCount: exportCards.length,
                cards: exportCards
            };

            const today = new Date().toISOString().split('T')[0];
            triggerDownload(JSON.stringify(payload, null, 2), `duplicate-cards-${today}.json`, 'application/json');
            showNotification('Duplicate snapshot exported.', 'success');
        }

        function isDeletedViewActive() {
            const view = document.getElementById('deleted-view');
            return view ? !view.classList.contains('hidden') : false;
        }

        function createDeletedFieldElement(label, value) {
            const wrapper = document.createElement('div');
            wrapper.className = 'space-y-1';
            const labelEl = document.createElement('p');
            labelEl.className = 'field-label';
            labelEl.textContent = label;
            const valueEl = document.createElement('div');
            valueEl.className = 'field-value';
            valueEl.textContent = formatDuplicateDisplayValue(value);
            wrapper.append(labelEl, valueEl);
            return wrapper;
        }

        function renderDeletedView() {
            const container = document.getElementById('deleted-container');
            const summary = document.getElementById('deleted-summary');
            const emptyState = document.getElementById('deleted-empty-state');
            if (!container || !summary || !emptyState) return;

            container.innerHTML = '';

            if (deletedCards.length === 0) {
                summary.textContent = 'No deleted cards in history.';
                emptyState.classList.remove('hidden');
                return;
            }

            summary.textContent = `Showing the last ${deletedCards.length} deleted card${deletedCards.length > 1 ? 's' : ''} (max 20 stored).`;
            emptyState.classList.add('hidden');

            deletedCards
                .slice()
                .sort((a, b) => getCreatedAtTime(b.deletedAt) - getCreatedAtTime(a.deletedAt))
                .forEach(card => {
                    const entry = document.createElement('div');
                    entry.className = 'deleted-card-entry space-y-4';
                    entry.dataset.cardId = card.id;

                    const header = document.createElement('header');
                    const titleFront = document.createElement('p');
                    titleFront.className = 'text-lg font-semibold text-gray-100';
                    titleFront.textContent = formatDuplicateDisplayValue(card.front) !== 'â€”' ? formatDuplicateDisplayValue(card.front) : 'No Front';
                    const titleBack = document.createElement('p');
                    titleBack.className = 'text-sm text-gray-400';
                    titleBack.textContent = formatDuplicateDisplayValue(card.back) !== 'â€”' ? formatDuplicateDisplayValue(card.back) : 'No Back';
                    header.append(titleFront, titleBack);
                    entry.appendChild(header);

                    const meta = document.createElement('div');
                    meta.className = 'meta';
                    const metaSegments = [
                        `Deleted: ${formatDuplicateTimestamp(card.deletedAt)}`,
                        `Original ID: ${card.originalId || card.id}`,
                        `Folder: ${resolveFolderName(card)}`
                    ];
                    metaSegments.forEach(segment => {
                        const span = document.createElement('span');
                        span.textContent = segment;
                        meta.appendChild(span);
                    });
                    entry.appendChild(meta);

                    const primaryGrid = document.createElement('div');
                    primaryGrid.className = 'grid gap-4 md:grid-cols-2';
                    primaryGrid.appendChild(createDeletedFieldElement('Front', card.front));
                    primaryGrid.appendChild(createDeletedFieldElement('Back', card.back));
                    primaryGrid.appendChild(createDeletedFieldElement('Translation', card.translation));
                    primaryGrid.appendChild(createDeletedFieldElement('Beispiel', card.beispiel));
                    entry.appendChild(primaryGrid);

                    const optionalGrid = document.createElement('div');
                    optionalGrid.className = 'grid gap-4 md:grid-cols-2';
                    let hasOptional = false;
                    [
                        { label: 'Speech', value: card.speech },
                        { label: 'Beispiel Speech', value: card.beispielSpeech }
                    ].forEach(field => {
                        if (formatDuplicateDisplayValue(field.value) !== 'â€”') {
                            optionalGrid.appendChild(createDeletedFieldElement(field.label, field.value));
                            hasOptional = true;
                        }
                    });
                    if (hasOptional) entry.appendChild(optionalGrid);

                    const actions = document.createElement('div');
                    actions.className = 'flex flex-wrap gap-2';

                    const restoreBtn = document.createElement('button');
                    restoreBtn.className = 'btn btn-success btn-sm deleted-restore-btn';
                    restoreBtn.dataset.cardId = card.id;
                    restoreBtn.innerHTML = '<i class="fas fa-undo"></i> Restore';
                    actions.appendChild(restoreBtn);

                    const restoreEditBtn = document.createElement('button');
                    restoreEditBtn.className = 'btn btn-secondary btn-sm deleted-restore-edit-btn';
                    restoreEditBtn.dataset.cardId = card.id;
                    restoreEditBtn.innerHTML = '<i class="fas fa-pen"></i> Restore & Edit';
                    actions.appendChild(restoreEditBtn);

                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'btn btn-secondary btn-sm deleted-copy-btn';
                    copyBtn.dataset.cardId = card.id;
                    copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy Back';
                    actions.appendChild(copyBtn);

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'btn btn-danger btn-sm deleted-remove-btn';
                    removeBtn.dataset.cardId = card.id;
                    removeBtn.innerHTML = '<i class="fas fa-trash-alt"></i> Remove';
                    actions.appendChild(removeBtn);

                    entry.appendChild(actions);
                    container.appendChild(entry);
                });
        }

        function buildArchivedCardPayload(cardData) {
            if (!cardData || !cardData.id) return null;
            const { id: originalId, ...rest } = cardData;
            const cleaned = {};
            Object.entries(rest).forEach(([key, value]) => {
                cleaned[key] = value === undefined ? null : value;
            });
            return {
                ...cleaned,
                originalId,
                deletedAt: new Date().toISOString()
            };
        }

        async function archiveCardBeforeDeletion(cardData) {
            if (!deletedCardsCollectionRef || !cardData || !cardData.id) return;
            const archivedCard = buildArchivedCardPayload(cardData);
            if (!archivedCard) return;
            try {
                const archiveDocRef = doc(deletedCardsCollectionRef);
                await setDoc(archiveDocRef, archivedCard);
            } catch (error) {
                console.error('Failed to archive card before deletion:', error);
            }
        }

        async function restoreDeletedCard(card, options = {}) {
            if (!card || !cardsCollectionRef || !deletedCardsCollectionRef) {
                showNotification('Unable to restore this card right now.', 'error');
                return;
            }
            const cardId = card.originalId || card.id;
            const { deletedAt, originalId, ...rest } = card;
            const payload = {
                front: rest.front || '',
                back: rest.back || '',
                speech: rest.speech || '',
                beispiel: rest.beispiel || '',
                beispielSpeech: rest.beispielSpeech || '',
                translation: rest.translation || '',
                folderId: rest.folderId || null,
                folderName: rest.folderName || null,
                createdAt: rest.createdAt || new Date().toISOString()
            };

            try {
                await setDoc(doc(cardsCollectionRef, cardId), payload);
                await deleteDoc(doc(deletedCardsCollectionRef, card.id));
                showNotification('Card restored.', 'success');
                deletedCards = deletedCards.filter(existing => existing.id !== card.id);
                updateDeletedBadge();
                if (options.edit) {
                    showMainAppView();
                    setEditMode(true, { ...payload, id: cardId });
                }
            } catch (error) {
                console.error('Restore failed:', error);
                showNotification('Failed to restore card.', 'error');
            }
        }

        async function permanentlyDeleteArchivedCard(cardId) {
            if (!cardId || !deletedCardsCollectionRef) return;
            try {
                await deleteDoc(doc(deletedCardsCollectionRef, cardId));
                showNotification('Card removed from history.', 'success');
                deletedCards = deletedCards.filter(card => card.id !== cardId);
                updateDeletedBadge();
            } catch (error) {
                console.error('Failed to remove archived card:', error);
                showNotification('Could not remove card from history.', 'error');
            }
        }

        function updateDeletedBadge() {
            const badge = document.getElementById('deleted-count-badge');
            if (!badge) return;
            if (!deletedCards.length) {
                badge.classList.add('hidden');
                badge.textContent = '';
            } else {
                badge.textContent = deletedCards.length.toString();
                badge.classList.remove('hidden');
            }
            if (isDeletedViewActive()) {
                renderDeletedView();
            }
        }

        function updateSpeechFields() { 
            const backInput = document.getElementById('back');
            const beispielInput = document.getElementById('beispiel');
            const speechBox = document.getElementById('speech');
            const beispielSpeechBox = document.getElementById('beispiel-speech');
            if(!backInput || !beispielInput || !speechBox || !beispielSpeechBox) return;

            const backValue = backInput.value; 
            const beispielValue = beispielInput.value;
            const soundTagText = prepareForSoundTag(backValue); 

            speechBox.textContent = soundTagText ? `[sound:${soundTagText}.mp3]` : ''; 
            beispielSpeechBox.textContent = buildBeispielSpeech(backValue, beispielValue);
        }
        
        function clearForm() {
            const ankiForm = document.getElementById('anki-form');
            const front = document.getElementById('front');
            const folderSelect = document.getElementById('folder-select');
            const preservedFolderValue = folderSelect ? folderSelect.value : ((currentFolderId != null ? currentFolderId : NO_FOLDER_VALUE));
            if (ankiForm) ankiForm.reset();
            if (folderSelect) {
                const availableValues = Array.from(folderSelect.options).map(option => option.value);
                const valueToRestore = availableValues.includes(preservedFolderValue) ? preservedFolderValue : NO_FOLDER_VALUE;
                folderSelect.value = valueToRestore;
                const normalizedCurrent = (currentFolderId != null ? currentFolderId : NO_FOLDER_VALUE);
                if (valueToRestore !== normalizedCurrent) {
                    const selectionChanged = updateFolderSelection(valueToRestore, { persist: false, updateSelect: false });
                    if (selectionChanged) {
                        filterAndRenderCards();
                    }
                }
            }
            updateSpeechFields();
            if (front) front.focus();
        }

        function setEditMode(isEditing, cardData = null) {
            const defaultActions = document.getElementById('default-actions');
            const editActions = document.getElementById('edit-actions');
            const front = document.getElementById('front');
            const back = document.getElementById('back');
            const beispiel = document.getElementById('beispiel');
            const translation = document.getElementById('translation');
            const folderSelect = document.getElementById('folder-select');

            if (isEditing) {
                document.getElementById('main-app').scrollIntoView();
                currentEditId = cardData.id;
                front.value = cardData.front || '';
                back.value = cardData.back || '';
                beispiel.value = unformatMultiLine(cardData.beispiel || '');
                translation.value = unformatMultiLine(cardData.translation || '');
                if (folderSelect) {
                    const folderValue = cardData && cardData.folderId ? cardData.folderId : NO_FOLDER_VALUE;
                    const availableValues = Array.from(folderSelect.options).map(option => option.value);
                    const valueToApply = folderValue !== NO_FOLDER_VALUE && !availableValues.includes(folderValue)
                        ? NO_FOLDER_VALUE
                        : folderValue;
                    const selectionChanged = updateFolderSelection(valueToApply);
                    if (selectionChanged) {
                        filterAndRenderCards();
                    }
                }
                updateSpeechFields();
                defaultActions.classList.add('hidden');
                editActions.classList.remove('hidden');
            } else {
                currentEditId = null;
                defaultActions.classList.remove('hidden');
                editActions.classList.add('hidden');
                clearForm();
            }
        }
        
        function renderCards(cardsToRender) {
            const cardList = document.getElementById('card-list');
            if (!cardList) return;

            cardList.innerHTML = '';
            
            const searchInput = document.getElementById('search-input');
            const searchTerm = searchInput ? searchInput.value.trim() : '';

            if (cardsToRender.length === 0) {
                if (searchTerm) {
                    cardList.innerHTML = '<p class="text-gray-500 text-center">No cards match your search.</p>';
                } else if (allCards.length > 0) {
                    let folderLabel = 'Selected folder';
                    if (currentViewFolderId === ALL_FOLDERS_VALUE) folderLabel = 'All Folders';
                    else if (currentViewFolderId === NO_FOLDER_VALUE) folderLabel = 'No Folder';
                    else {
                        const viewFolderMeta = folders.find(folder => folder.id === currentViewFolderId);
                        if (viewFolderMeta && viewFolderMeta.name) folderLabel = viewFolderMeta.name;
                    }
                    const sanitizedLabel = folderLabel.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                    cardList.innerHTML = `<p class="text-gray-500 text-center">No cards in "${sanitizedLabel}" yet.</p>`;
                } else {
                    cardList.innerHTML = '<p class="text-gray-500 text-center">No cards saved yet.</p>';
                }
                return;
            }
            
            const docs = [...cardsToRender];
            docs.sort((a, b) => getCreatedAtTime(b.createdAt) - getCreatedAtTime(a.createdAt));
            docs.forEach(cardData => {
                const cardEl = document.createElement('div');
                cardEl.className = 'card-item';
                const frontDisplay = (cardData.front && cardData.front.startsWith('<img')) 
                    ? 'ðŸ–¼ï¸ Image Card' 
                    : (cardData.front || '<em>No Front</em>');

                cardEl.innerHTML = `
                    <div class="card-item-content mr-4">
                        <p class="card-item-front">${frontDisplay}</p>
                        <p class="card-item-back">${cardData.back || '<em>No Back</em>'}</p>
                        <p class="card-item-folder text-xs text-gray-500 mt-2"></p>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button class="btn-icon copy-btn" title="Copy Back (C)"><i class="fas fa-copy"></i></button>
                        <button class="btn-icon edit-btn" title="Edit"><i class="fas fa-pencil-alt"></i></button>
                        <button class="btn-icon delete-btn" title="Delete"><i class="fas fa-trash-alt"></i></button>
                    </div>
                `;
                cardList.appendChild(cardEl);
                const folderLabelEl = cardEl.querySelector('.card-item-folder');
                if (folderLabelEl) {
                    const folderMeta = cardData.folderId ? folders.find(folder => folder.id === cardData.folderId) : null;
                    const displayName = folderMeta && folderMeta.name ? folderMeta.name : (cardData.folderName || 'No Folder');
                    folderLabelEl.textContent = `Folder: ${displayName}`;
                }
                cardEl.querySelector('.copy-btn').addEventListener('click', (e) => {
                    const backText = e.target.closest('.card-item').querySelector('.card-item-back').textContent;
                    if (backText) {
                        const tempInput = document.createElement('textarea');
                        tempInput.value = backText;
                        document.body.appendChild(tempInput);
                        tempInput.select();
                        document.execCommand('copy');
                        document.body.removeChild(tempInput);
                        showNotification("Copied to clipboard!", "success", 1500);
                    }
                });
                cardEl.querySelector('.edit-btn').addEventListener('click', () => setEditMode(true, cardData));
                cardEl.querySelector('.delete-btn').addEventListener('click', () => { 
                    cardToDeleteId = cardData.id; 
                    const deleteModal = document.getElementById('delete-modal');
                    if (deleteModal) deleteModal.classList.remove('hidden'); 
                });
            });
        }
        
        function triggerDownload(content, fileName, mimeType = 'text/plain;charset=utf-8') {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function updateReviewDateSelector() {
            const reviewDateSelector = document.getElementById('review-date-selector');
            const reviewBtn = document.getElementById('review-btn');
            const startSessionBtn = document.getElementById('start-session-btn');
            const relevantCards = allCards.filter(card => cardMatchesFolder(card, currentReviewFolderId));
            const dates = new Set();
            relevantCards.forEach(card => {
                if (card.createdAt && typeof card.createdAt === 'string') {
                    const datePart = card.createdAt.split('T')[0];
                    dates.add(datePart);
                }
            });

            const sortedDates = Array.from(dates).sort().reverse();
            if (reviewDateSelector) {
                const preferredValue = (reviewDateSelector.value || currentReviewDate || 'all');
                reviewDateSelector.innerHTML = '<option value="all">All Dates</option>' + sortedDates.map(date => `<option value="${date}">${date}</option>`).join('');
                let valueToApply = preferredValue;
                if (valueToApply !== 'all' && !sortedDates.includes(valueToApply)) {
                    valueToApply = sortedDates.length > 0 ? sortedDates[0] : 'all';
                }
                if (sortedDates.length === 0) {
                    valueToApply = 'all';
                }
                reviewDateSelector.value = valueToApply;
                currentReviewDate = reviewDateSelector.value;
            }

            if (reviewBtn) reviewBtn.disabled = allCards.length === 0;
            if (startSessionBtn) startSessionBtn.disabled = relevantCards.length === 0;
        }

        function updateProgressBar() {
            const bar = document.getElementById('review-progress-bar');
            if(!bar || !reviewSession.cards || reviewSession.cards.length === 0) return;
            const progress = (reviewSession.currentIndex + 1) / reviewSession.cards.length * 100;
            bar.style.width = `${progress}%`;
        }
        
        function renderMultiLineForReview(container, textContent) {
            container.innerHTML = '';
            if (textContent) {
                const lines = textContent.split(/<br\s*\/?>/i);
                lines.forEach(line => {
                    const trimmedLine = line.trim();
                    if (trimmedLine) {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'flex justify-between items-center w-full';

                        const span = document.createElement('span');
                        span.className = 'flex-grow p-1';
                        span.textContent = trimmedLine;

                        const copyBtn = document.createElement('button');
                        copyBtn.className = 'btn-icon text-gray-400 hover:text-white ml-4 flex-shrink-0 copy-line-btn';
                        copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
                        copyBtn.title = `Copy: "${trimmedLine}"`;
                        copyBtn.dataset.text = trimmedLine;

                        wrapper.appendChild(span);
                        wrapper.appendChild(copyBtn);
                        container.appendChild(wrapper);
                    }
                });
            } else {
                container.textContent = 'â€”';
            }
        }
        
        function renderReviewEmptyState(message = 'No cards available.') {
            const frontEl = document.getElementById('review-front');
            const backEl = document.getElementById('review-back');
            const beispielEl = document.getElementById('review-beispiel');
            const translationEl = document.getElementById('review-translation');
            const progressTextEl = document.getElementById('review-progress-text');
            const editedTextEl = document.getElementById('review-edited-text');
            const prevBtn = document.getElementById('prev-card-btn');
            const nextBtn = document.getElementById('next-card-btn');
            if (frontEl) frontEl.textContent = 'â€”';
            if (backEl) backEl.textContent = 'â€”';
            if (beispielEl) beispielEl.innerHTML = `<p class="text-center text-gray-500 w-full">${message}</p>`;
            if (translationEl) translationEl.innerHTML = '';
            if (progressTextEl) progressTextEl.textContent = message;
            if (editedTextEl) editedTextEl.textContent = '';
            if (prevBtn) prevBtn.disabled = true;
            if (nextBtn) nextBtn.disabled = true;
            const bar = document.getElementById('review-progress-bar');
            if (bar) bar.style.width = '0%';
        }

        function renderReviewCard() {
            const searchInput = document.getElementById('in-review-search-input');
            const activeSearchTerm = searchInput ? searchInput.value.trim() : '';
            const hasCards = reviewSession.cards && reviewSession.cards.length > 0 && reviewSession.currentIndex > -1;

            if (!hasCards) {
                if (activeSearchTerm && reviewSession.originalCards && reviewSession.originalCards.length > 0) {
                    renderReviewEmptyState('No cards match your search.');
                    return;
                }
                endReviewSession();
                showNotification("Review session finished.", "success");
                return;
            }

            reviewSession.beispielCopyIndex = 0;

            const card = reviewSession.cards[reviewSession.currentIndex];
            document.getElementById('review-front').textContent = card.front || 'â€”';
            document.getElementById('review-back').textContent = card.back || 'â€”';

            renderMultiLineForReview(document.getElementById('review-beispiel'), card.beispiel);
            renderMultiLineForReview(document.getElementById('review-translation'), card.translation);
            
            // Update counters and marker
            const editedCount = reviewSession.editedCardIds.size;
            const totalCount = reviewSession.cards.length;
            document.getElementById('review-progress-text').textContent = `Card ${reviewSession.currentIndex + 1} of ${totalCount}`;
            document.getElementById('review-edited-text').textContent = `Edited: ${editedCount} / ${totalCount - editedCount} Remaining`;
            
            const markEditedBtn = document.getElementById('mark-edited-btn');
            if (reviewSession.editedCardIds.has(card.id)) {
                markEditedBtn.classList.add('btn-success');
                markEditedBtn.classList.remove('btn-secondary');
            } else {
                markEditedBtn.classList.add('btn-secondary');
                markEditedBtn.classList.remove('btn-success');
            }

            document.getElementById('prev-card-btn').disabled = reviewSession.currentIndex === 0;
            document.getElementById('next-card-btn').disabled = reviewSession.currentIndex === reviewSession.cards.length - 1;
            updateProgressBar();
        }

        async function handleReviewNav(direction, autoEditNext = false) {
            clearAutoSkipTimer();
            
            if (isReviewEditing) {
                const success = await saveReviewEdit();
                if (!success) return; 
                exitReviewEditMode();
            }

            // Mark the card we are leaving as edited
            if (direction > 0 && reviewSession.currentIndex > -1) {
                const currentCard = reviewSession.cards[reviewSession.currentIndex];
                const cardId = currentCard && currentCard.id;
                if (cardId && !reviewSession.editedCardIds.has(cardId)) {
                    setLocalEditedState(cardId, true);
                    await updateEditedCardsInFirestore(cardId, true);
                }
            }
            
            const newIndex = reviewSession.currentIndex + direction;
            if (newIndex >= 0 && newIndex < reviewSession.cards.length) {
                reviewSession.currentIndex = newIndex;
                renderReviewCard();

                if (autoEditNext) {
                    const nextCard = reviewSession.cards[newIndex];
                    if (nextCard && nextCard.back) {
                        try {
                            const tempInput = document.createElement('textarea');
                            tempInput.value = nextCard.back;
                            document.body.appendChild(tempInput);
                            tempInput.select();
                            document.execCommand('copy');
                            document.body.removeChild(tempInput);
                            showNotification("Copied next card's back!", "success", 1500);
                        } catch (err) {
                            showNotification("Failed to copy automatically.");
                        } finally {
                            enterReviewEditMode();
                        }
                    } else {
                        enterReviewEditMode();
                    }
                }
            }
        }
        
        function handleReviewKeyboard(e) {
            if (document.activeElement.id === 'in-review-search-input' || (document.activeElement.tagName === 'TEXTAREA' && isReviewEditing)) return;
            
            const deleteModal = document.getElementById('delete-modal');
            const isDeleteModalOpen = deleteModal && !deleteModal.classList.contains('hidden');
            if (isDeleteModalOpen) {
                if (e.key === 'Delete') {
                    e.preventDefault();
                    resetDeleteShortcut();
                    document.getElementById('confirm-delete-btn').click();
                }
                return;
            }
            
            if (e.key === 'ArrowRight') handleReviewNav(1);
            if (e.key === 'ArrowLeft') handleReviewNav(-1);
            if (e.key === 'f' || e.key === 'F') {
                const frontBtn = document.querySelector('[data-target="review-front"]');
                if (frontBtn) {
                    e.preventDefault();
                    frontBtn.click();
                }
            }
            if (e.key === 'b' || e.key === 'B') document.querySelector('[data-target="review-back"]').click();
            if (e.key === 'd' || e.key === 'D') {
                e.preventDefault();
                if (!deleteShortcutState.pending) {
                    deleteShortcutState.pending = true;
                    deleteShortcutState.timeoutId = setTimeout(() => {
                        deleteShortcutState.pending = false;
                        deleteShortcutState.timeoutId = null;
                    }, 2000);
                    showNotification("Press D again to open delete confirmation.", "error", 2000);
                    return;
                }
                resetDeleteShortcut();
                document.getElementById('delete-review-card-btn').click();
                return;
            }
            
            if (e.key === 'e' || e.key === 'E') {
                e.preventDefault();
                const card = reviewSession.cards[reviewSession.currentIndex];
                const beispielText = card.beispiel || '';
                if (!beispielText) return;

                const sentences = beispielText.split(/<br\s*\/?>/i).map(s => s.trim()).filter(Boolean);
                if (sentences.length === 0) return;

                const sentenceToCopy = sentences[reviewSession.beispielCopyIndex];
                const tempInput = document.createElement('textarea');
                tempInput.value = sentenceToCopy;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);

                const sentenceElements = document.querySelectorAll('#review-beispiel > div');
                if (sentenceElements.length > reviewSession.beispielCopyIndex) {
                    const el = sentenceElements[reviewSession.beispielCopyIndex];
                    el.classList.add('copy-highlight');
                    setTimeout(() => el.classList.remove('copy-highlight'), 400);
                }
                showNotification(`Copied: "${sentenceToCopy}"`, "success", 1500);
                reviewSession.beispielCopyIndex = (reviewSession.beispielCopyIndex + 1) % sentences.length;

            }

            if (e.key === 'Enter' && !isReviewEditing) enterReviewEditMode();
            if (e.key === 'Delete') {
                resetDeleteShortcut();
                document.getElementById('delete-review-card-btn').click();
            }
            if (e.key === 'm' || e.key === 'M') document.getElementById('mark-edited-btn').click();
        }

        function setLocalEditedState(cardId, isEdited) {
            if (!cardId) return;
            if (isEdited) reviewSession.editedCardIds.add(cardId);
            else reviewSession.editedCardIds.delete(cardId);

            const updateInList = (list) => {
                if (!Array.isArray(list)) return;
                const card = list.find(c => c.id === cardId);
                if (card) card.reviewEdited = isEdited;
            };
            updateInList(reviewSession.cards);
            updateInList(reviewSession.originalCards);
            const allCard = allCards.find(c => c.id === cardId);
            if (allCard) allCard.reviewEdited = isEdited;
        }

        async function updateEditedCardsInFirestore(cardId, isEdited) {
            if (!userId) return;
            const writes = [];
            if (cardId && cardsCollectionRef) {
                const cardRef = doc(cardsCollectionRef, cardId);
                const payload = isEdited
                    ? { reviewEdited: true, reviewEditedAt: new Date().toISOString() }
                    : { reviewEdited: deleteField(), reviewEditedAt: deleteField() };
                writes.push(updateDoc(cardRef, payload).catch(error => {
                    console.error('Failed to update card edited state:', error);
                    showNotification('Could not update card edited state.', 'error');
                }));
            }
            if (currentReviewSessionId) {
                const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/review_sessions`, currentReviewSessionId);
                const idsArray = Array.from(reviewSession.editedCardIds);
                writes.push(setDoc(sessionRef, { editedCardIds: idsArray }, { merge: true }).catch(error => {
                    console.error('Failed to save review progress:', error);
                    showNotification('Could not save review progress.');
                }));
            }
            await Promise.all(writes);
        }

        async function startReviewSession() {
            const reviewDateSelector = document.getElementById('review-date-selector');
            const reviewFolderSelector = document.getElementById('review-folder-selector');
            const selectedDate = reviewDateSelector ? reviewDateSelector.value : 'all';
            const selectedFolder = reviewFolderSelector ? reviewFolderSelector.value : ALL_FOLDERS_VALUE;

            currentReviewDate = selectedDate;
            currentReviewFolderId = selectedFolder;

            let cardsForReview = allCards.filter(card => cardMatchesFolder(card, selectedFolder));
            if (selectedDate !== 'all') {
                cardsForReview = cardsForReview.filter(card => card.createdAt && card.createdAt.startsWith(selectedDate));
            }
            cardsForReview.sort((a, b) => getCreatedAtTime(a.createdAt) - getCreatedAtTime(b.createdAt));

            if (cardsForReview.length === 0) {
                showNotification('No cards found for the selected filters.');
                return;
            }

            currentReviewSessionId = buildReviewSessionId(selectedDate, selectedFolder);

            reviewSession.originalCards = [...cardsForReview];
            reviewSession.cards = [...cardsForReview];
            reviewSession.currentIndex = 0;
            reviewSession.editedCardIds = new Set(cardsForReview.filter(card => card.reviewEdited).map(card => card.id));
            resetDeleteShortcut();
            
            // Fetch persisted edited IDs
            if (userId && currentReviewSessionId) {
                try {
                    const docRef = doc(db, `artifacts/${appId}/users/${userId}/review_sessions`, currentReviewSessionId);
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists() && docSnap.data().editedCardIds) {
                        const editedIds = docSnap.data().editedCardIds;
                        editedIds.forEach(id => setLocalEditedState(id, true));
                    }
                } catch (error) {
                    console.error('Error fetching review session:', error);
                }
            }

            document.getElementById('review-setup').classList.add('hidden');
            document.getElementById('review-session').classList.remove('hidden');
            document.addEventListener('keydown', handleReviewKeyboard);
            renderReviewCard();
            exitReviewEditMode();
        }
        
        function endReviewSession() {
            clearAutoSkipTimer();
            resetDeleteShortcut();
            reviewSession = { cards: [], currentIndex: -1, autoSkipTimer: null, beispielCopyIndex: 0, editedCardIds: new Set(), originalCards: [] };
            currentReviewSessionId = null;
            document.getElementById('main-app').classList.remove('hidden');
            document.getElementById('review-modal').classList.add('hidden');
            document.getElementById('review-setup').classList.remove('hidden');
            document.getElementById('review-session').classList.add('hidden');
            document.removeEventListener('keydown', handleReviewKeyboard);
            updateReviewDateSelector();
        }
        
        async function handleFormSubmit(e) {
            e.preventDefault();
            if (currentEditId) return;
            if (!userId) { showNotification("Not connected."); return; }
            const front = document.getElementById('front');
            const back = document.getElementById('back');
            const beispiel = document.getElementById('beispiel');
            const translation = document.getElementById('translation');
            const speechBox = document.getElementById('speech');
            const beispielSpeechBox = document.getElementById('beispiel-speech');
            const { id: selectedFolderId, name: selectedFolderName } = getSelectedFolderDetails();

            const cardData = {
                front: front.value.trim(),
                back: back.value.trim(),
                speech: speechBox.textContent,
                beispiel: formatMultiLine(beispiel.value),
                beispielSpeech: beispielSpeechBox.textContent,
                translation: formatMultiLine(translation.value),
                folderId: selectedFolderId,
                folderName: selectedFolderName,
                createdAt: new Date().toISOString()
            };
            if (!cardData.front && !cardData.back) return;
            try {
                await addDoc(cardsCollectionRef, cardData);
                clearForm();
            } catch (error) { showNotification("Failed to save the card."); }
        }

        async function handleTranslateCurrentBeispiel() {
            const translateBtn = document.getElementById('translate-beispiel-btn');
            const beispielInput = document.getElementById('beispiel');
            const translationInput = document.getElementById('translation');
            if (!beispielInput || !translationInput) return;

            const apiKey = getStoredDeepLKey();
            if (!apiKey) {
                showNotification('Set your DeepL how key first.', 'error');
                return;
            }

            const sentences = normalizeSentencesFromBeispiel(beispielInput.value);
            if (sentences.length === 0) {
                showNotification('Add at least one Beispiel sentence to translate.', 'error');
                return;
            }

            try {
                setButtonLoading(translateBtn, true, 'Translating...');
                const translations = await translateSentencesWithDeepL(sentences, apiKey);
                if (!translations.length) {
                    showNotification('No translation returned by DeepL.');
                    return;
                }
                const textareaValue = translations.join('\n');
                translationInput.value = textareaValue;
                translationInput.dispatchEvent(new Event('input', { bubbles: true }));
                showNotification('Example translated successfully.', 'success');
            } catch (error) {
                console.error('DeepL translation failed.', error);
                showNotification(error && error.message ? error.message : 'Translation failed.');
            } finally {
                setButtonLoading(translateBtn, false);
            }
        }

        async function handleUpdateCard() {
             if (!currentEditId || !userId) return;
             const front = document.getElementById('front');
             const back = document.getElementById('back');
             const beispiel = document.getElementById('beispiel');
             const translation = document.getElementById('translation');
             const speechBox = document.getElementById('speech');
             const beispielSpeechBox = document.getElementById('beispiel-speech');
             const { id: selectedFolderId, name: selectedFolderName } = getSelectedFolderDetails();
             const cardData = {
                front: front.value.trim(),
                back: back.value.trim(),
                speech: speechBox.textContent,
                beispiel: formatMultiLine(beispiel.value),
                beispielSpeech: beispielSpeechBox.textContent,
                translation: formatMultiLine(translation.value),
                folderId: selectedFolderId,
                folderName: selectedFolderName,
                createdAt: allCards.find(c => c.id === currentEditId)?.createdAt || new Date().toISOString()
            };
            try {
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/cards`, currentEditId);
                await setDoc(docRef, cardData);
                showNotification("Card updated successfully.", "success");
                setEditMode(false);
            } catch (error) { showNotification("Failed to update card."); }
        }

        async function handleBulkTranslateBeispiele() {
            if (isBulkTranslating) return;
            if (!userId || !cardsCollectionRef) {
                showNotification('Sign in to translate cards.', 'error');
                return;
            }

            const apiKey = getStoredDeepLKey();
            if (!apiKey) {
                showNotification('Set your DeepL API key first.', 'error');
                return;
            }

            const cardsToTranslate = allCards.filter(card => {
                const sentences = normalizeSentencesFromBeispiel(card.beispiel);
                return sentences.length > 0 && (isBlank(card.translation) || !card.translation);
            });

            if (cardsToTranslate.length === 0) {
                showNotification('All Beispiel sentences already have translations or no Beispiel text found.', 'success');
                return;
            }

            const shouldProceed = confirm(`Translate ${cardsToTranslate.length} cards with DeepL? This will use your DeepL character allowance.`);
            if (!shouldProceed) return;

            isBulkTranslating = true;
            const bulkBtn = document.getElementById('bulk-translate-btn');
            setButtonLoading(bulkBtn, true, 'Translating...');

            let successCount = 0;
            let failureCount = 0;
            const failures = [];

            for (const card of cardsToTranslate) {
                const sentences = normalizeSentencesFromBeispiel(card.beispiel);
                if (sentences.length === 0) continue;
                try {
                    const translations = await translateSentencesWithDeepL(sentences, apiKey);
                    if (!translations.length) {
                        failureCount += 1;
                        failures.push({ id: card.id, reason: 'DeepL returned no translation.' });
                        continue;
                    }
                    const formattedTranslation = formatMultiLine(translations.join('\n'));
                    const docRef = doc(db, `artifacts/${appId}/users/${userId}/cards`, card.id);
                    await updateDoc(docRef, { translation: formattedTranslation });
                    successCount += 1;
                } catch (error) {
                    console.error(`Failed to translate card ${card.id}`, error);
                    failureCount += 1;
                    failures.push({ id: card.id, error: error?.message || error });
                }
                await sleep(DEEPL_REQUEST_DELAY_MS);
            }

            setButtonLoading(bulkBtn, false);
            isBulkTranslating = false;

            const summaryMessage = `DeepL translation finished. ${successCount} card(s) updated${failureCount ? `, ${failureCount} failed` : ''}.`;
            showNotification(summaryMessage, failureCount ? 'error' : 'success', 7000);
            if (failures.length) {
                console.warn('DeepL bulk translation failures:', failures);
            }
        }
        
        async function handleDeleteConfirmed() {
            if (!cardToDeleteId || !userId) return;
            const isReviewDelete = reviewSession.cards.length > 0;
            resetDeleteShortcut();
            
            try {
                let cardData = allCards.find(card => card.id === cardToDeleteId);
                if (!cardData && cardsCollectionRef) {
                    try {
                        const cardDoc = await getDoc(doc(cardsCollectionRef, cardToDeleteId));
                        if (cardDoc.exists()) {
                            cardData = { id: cardDoc.id, ...cardDoc.data() };
                        }
                    } catch (error) {
                        console.error('Failed to fetch card before deletion:', error);
                    }
                }
                if (cardData) {
                    await archiveCardBeforeDeletion(cardData);
                }
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/cards`, cardToDeleteId);
                await deleteDoc(docRef);
                
                if (isReviewDelete) {
                    const deletedIndex = reviewSession.cards.findIndex(c => c.id === cardToDeleteId);
                    if (deletedIndex > -1) {
                         reviewSession.cards.splice(deletedIndex, 1);
                         if (reviewSession.currentIndex >= deletedIndex) {
                             reviewSession.currentIndex = Math.max(0, reviewSession.currentIndex - 1);
                         }
                         if (reviewSession.cards.length === 0) {
                            endReviewSession();
                            showNotification("Last card in review deleted. Session ended.", "success");
                         } else {
                            renderReviewCard();
                         }
                    }
                }
                
                document.getElementById('delete-modal').classList.add('hidden');
                cardToDeleteId = null;
                showNotification("Card deleted.", "success");
            } catch (error) { showNotification("Failed to delete card."); }
        }
        
        function triggerExportDownload(cards, format) {
            if (cards.length === 0) {
                showNotification("No cards match the selected criteria.", "success");
                return;
            }
            cards.sort((a, b) => getCreatedAtTime(a.createdAt) - getCreatedAtTime(b.createdAt));
            const today = new Date().toISOString().split('T')[0];
            let content, fileName, mimeType;

            if (format === 'json') {
                const jsonData = cards.map(data => ({ back: data.back || '', beispiel: data.beispiel || '' }));
                content = JSON.stringify(jsonData, null, 2);
                fileName = `${today}.json`;
                mimeType = 'application/json';
            } else { // txt format
                content = cards.map(data => {
                    const soundTagBase = prepareForSoundTag(data.back);
                    const speechValue = !isBlank(data.speech) ? data.speech : (soundTagBase ? `[sound:${soundTagBase}.mp3]` : '');
                    const fallbackBeispielSpeech = buildBeispielSpeech(data.back, data.beispiel);
                    const beispielSpeechValue = !isBlank(data.beispielSpeech) ? data.beispielSpeech : fallbackBeispielSpeech;
                    const sanitizedBack = sanitizeForExport(data.back);
                    const fields = [
                        sanitizeForExport(data.front, sanitizedBack),
                        sanitizedBack,
                        sanitizeForExport(speechValue),
                        sanitizeForExport(data.beispiel),
                        sanitizeForExport(beispielSpeechValue),
                        sanitizeForExport(data.translation)
                    ];
                    return fields.join('\t');
                }).join('\n');
                
                fileName = `${today}.txt`;
                mimeType = 'text/plain;charset=utf-8';
            }
            triggerDownload(content, fileName, mimeType);
        }

        function handleConfirmExport() {
            const format = document.querySelector('input[name="export-format"]:checked').value;
            const range = document.querySelector('input[name="export-range"]:checked').value;
            const clipboardOutputContainer = document.getElementById('clipboard-output-container');
            const clipboardOutput = document.getElementById('clipboard-output');
            let cardsToExport = [];
        
            clipboardOutputContainer.classList.add('hidden');

            if (range === 'all') {
                cardsToExport = [...allCards];
            } else { 
                const selectedDateNodes = document.querySelectorAll('#export-date-selection input[type="checkbox"]:checked');
                if (selectedDateNodes.length === 0) {
                    showNotification("Please select at least one date to export.");
                    return;
                }
                const selectedDates = Array.from(selectedDateNodes).map(el => el.value);
                cardsToExport = allCards.filter(card => card.createdAt && card.createdAt.split('T')[0] && selectedDates.includes(card.createdAt.split('T')[0]));
            }

            if (cardsToExport.length === 0) {
                showNotification("No cards match the selected criteria.", "success");
                return;
            }
            
            let clipboardText = '';
            if (format === 'clipboard') {
                clipboardText = cardsToExport
                    .sort((a, b) => getCreatedAtTime(a.createdAt) - getCreatedAtTime(b.createdAt))
                    .map(data => {
                        const sanitizedBack = sanitizeForExport(data.back);
                        const sanitizedFront = sanitizeForExport(data.front, sanitizedBack);
                        return `${sanitizedBack}\t${sanitizedFront}`;
                    })
                    .join('\n');
            } else if (format === 'beispiel-speech') {
                clipboardText = cardsToExport
                    .sort((a, b) => getCreatedAtTime(a.createdAt) - getCreatedAtTime(b.createdAt))
                    .map(data => {
                        const fallbackBeispielSpeech = buildBeispielSpeech(data.back, data.beispiel);
                        const beispielSpeechValue = !isBlank(data.beispielSpeech) ? data.beispielSpeech : fallbackBeispielSpeech;
                        return sanitizeForExport(beispielSpeechValue);
                    })
                    .filter(text => !isBlank(text))
                    .join('\n');
            } else if (format === 'clipboard-back-only') {
                clipboardText = cardsToExport
                    .sort((a, b) => getCreatedAtTime(a.createdAt) - getCreatedAtTime(b.createdAt))
                    .map(data => sanitizeForExport(data.back))
                    .filter(text => !isBlank(text))
                    .join(', ');
            } else {
                triggerExportDownload(cardsToExport, format);
                document.getElementById('export-modal').classList.add('hidden');
                return;
            }

            const tempInput = document.createElement('textarea');
            tempInput.value = clipboardText;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
            
            showNotification("Copied to clipboard!", "success");
            document.getElementById('export-modal').classList.add('hidden');
        }

        function openExportModal() {
            if (allCards.length === 0) {
                showNotification("There are no cards to export.", "success");
                return;
            }
            document.getElementById('export-all-radio').checked = true;
            document.getElementById('export-date-selection').classList.add('hidden');
            document.getElementById('clipboard-output-container').classList.add('hidden');
            
            const dates = [...new Set(allCards.map(card => card.createdAt && card.createdAt.split('T')[0]).filter(Boolean))].sort().reverse();
            const exportDateSelection = document.getElementById('export-date-selection');
            exportDateSelection.innerHTML = '';

            if (dates.length > 0) {
                dates.forEach(date => {
                    const label = document.createElement('label');
                    label.className = 'flex items-center space-x-2 text-gray-300 py-1';
                    label.innerHTML = `<input type="checkbox" value="${date}" class="form-checkbox h-4 w-4 text-blue-500 bg-gray-700 border-gray-600 rounded"> <span>${date}</span>`;
                    exportDateSelection.appendChild(label);
                });
                document.getElementById('export-date-radio').disabled = false;
            } else {
                document.getElementById('export-date-radio').disabled = true;
            }
            
            document.getElementById('export-modal').classList.remove('hidden');
        }

        function handleGenerateOrCycleImage() {
            const front = document.getElementById('front');
            let value = front.value.trim();

            if (value.startsWith('<img src="') && value.endsWith('">')) {
                const src = value.substring(10, value.length - 2);
                const lastDot = src.lastIndexOf('.');
                if (lastDot === -1) {
                    showNotification("No extension found in image tag.");
                    return;
                }
                const base = src.substring(0, lastDot);
                const ext = src.substring(lastDot + 1).toLowerCase();
                let newExt = 'jpg';
                if (ext === 'jpg') newExt = 'webp';
                else if (ext === 'webp') newExt = 'png';
                else if (ext === 'png') newExt = 'svg';
                else if (ext === 'svg') newExt = 'jpg';
                front.value = `<img src="${base}.${newExt}">`;
            } else {
                const backValue = document.getElementById('back').value.trim();
                if (backValue) {
                    front.value = `<img src="${backValue}.jpg">`;
                } else {
                    showNotification("Please enter a word in the 'Back' field first.");
                }
            }
        }

        async function handleAuthSubmit(e) {
            e.preventDefault();
            const email = document.getElementById('auth-email').value;
            const password = document.getElementById('auth-password').value;
            if (!email || !password) {
                showNotification("Email and password are required.");
                return;
            }
            try {
                if (isSignUpMode) { await createUserWithEmailAndPassword(auth, email, password); } 
                else { await signInWithEmailAndPassword(auth, email, password); }
            } catch (error) {
                console.error("Authentication error:", error.message);
                showNotification(error.message);
            }
        }

        async function userSignOut() {
            try { await signOut(auth); } catch (error) { console.error("Sign out error", error); }
        }

        function toggleAuthMode() {
            isSignUpMode = !isSignUpMode;
            const authTitle = document.getElementById('auth-title');
            const authSubmitBtn = document.getElementById('auth-submit-btn');
            const authPromptText = document.getElementById('auth-prompt-text');
            const authToggleBtn = document.getElementById('auth-toggle-btn');
            
            if (isSignUpMode) {
                authTitle.textContent = 'Create Account';
                authSubmitBtn.textContent = 'Sign Up';
                authPromptText.textContent = 'Already have an account?';
                authToggleBtn.textContent = 'Sign In';
            } else {
                authTitle.textContent = 'Sign In';
                authSubmitBtn.textContent = 'Sign In';
                authPromptText.textContent = "Don't have an account?";
                authToggleBtn.textContent = 'Create one';
            }
        }
        
        function showLoginUI() {
            document.getElementById('login-view').classList.remove('hidden');
            document.getElementById('main-app').classList.add('hidden');
            if (unsubscribe) unsubscribe();
            if (foldersUnsubscribe) foldersUnsubscribe();
            if (deletedCardsUnsubscribe) deletedCardsUnsubscribe();
            allCards = [];
            deletedCards = [];
            folders = [];
            foldersCollectionRef = null;
            deletedCardsCollectionRef = null;
            deletedCardsUnsubscribe = null;
            hasRestoredFolderPreference = false;
            currentReviewFolderId = ALL_FOLDERS_VALUE;
            currentReviewSessionId = null;
            currentReviewDate = 'all';
            currentViewFolderId = ALL_FOLDERS_VALUE;
            updateFolderSelection(NO_FOLDER_VALUE, { persist: false, updateSelect: false });
            renderFolderOptions();
            const cardListEl = document.getElementById('card-list');
            if(cardListEl) cardListEl.innerHTML = '';
            const sessionCounter = document.getElementById('session-counter');
            if(sessionCounter) sessionCounter.textContent = '0';
            const totalCounter = document.getElementById('total-counter');
            if(totalCounter) totalCounter.textContent = '0';
            const duplicatesView = document.getElementById('duplicates-view');
            if (duplicatesView) duplicatesView.classList.add('hidden');
            const duplicatesContainer = document.getElementById('duplicates-container');
            if (duplicatesContainer) duplicatesContainer.innerHTML = '';
            const duplicatesSummary = document.getElementById('duplicates-summary');
            if (duplicatesSummary) duplicatesSummary.textContent = '';
            const duplicatesEmptyState = document.getElementById('duplicates-empty-state');
            if (duplicatesEmptyState) duplicatesEmptyState.classList.add('hidden');
            const duplicatesSearchInput = document.getElementById('duplicates-search-input');
            if (duplicatesSearchInput) duplicatesSearchInput.value = '';
            updateDuplicateBadge();
            const deletedView = document.getElementById('deleted-view');
            if (deletedView) deletedView.classList.add('hidden');
            const deletedContainer = document.getElementById('deleted-container');
            if (deletedContainer) deletedContainer.innerHTML = '';
            const deletedSummary = document.getElementById('deleted-summary');
            if (deletedSummary) deletedSummary.textContent = '';
            const deletedEmptyState = document.getElementById('deleted-empty-state');
            if (deletedEmptyState) deletedEmptyState.classList.add('hidden');
            updateDeletedBadge();
        }

        function showAppUI(user) {
            document.getElementById('login-view').classList.add('hidden');
            document.getElementById('main-app').classList.remove('hidden');
            document.getElementById('user-email').textContent = user.email;
            document.getElementById('session-counter').textContent = '0';
            showMainAppView();
            updateDuplicateBadge();
            currentReviewFolderId = ALL_FOLDERS_VALUE;
            currentReviewSessionId = null;
            currentReviewDate = 'all';
            currentViewFolderId = ALL_FOLDERS_VALUE;
            
            userId = user.uid;
            const collectionPath = `artifacts/${appId}/users/${userId}/cards`;
            const folderPath = `artifacts/${appId}/users/${userId}/folders`;
            cardsCollectionRef = collection(db, collectionPath);
            foldersCollectionRef = collection(db, folderPath);
            deletedCardsCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/deleted_cards`);

            if (foldersUnsubscribe) foldersUnsubscribe();
            foldersUnsubscribe = onSnapshot(foldersCollectionRef, (snapshot) => {
                folders = [];
                snapshot.forEach(folderDoc => folders.push({ id: folderDoc.id, ...folderDoc.data() }));
                restoreFolderPreference();
                ensureCurrentFolderIsValid();
                renderFolderOptions();
                filterAndRenderCards();
            });

            if (deletedCardsUnsubscribe) deletedCardsUnsubscribe();
            const deletedQuery = query(deletedCardsCollectionRef, orderBy('deletedAt', 'desc'), limit(20));
            deletedCardsUnsubscribe = onSnapshot(deletedQuery, (snapshot) => {
                deletedCards = [];
                snapshot.forEach(docSnap => deletedCards.push({ id: docSnap.id, ...docSnap.data() }));
                updateDeletedBadge();
                if (isDeletedViewActive()) renderDeletedView();
            });

            if (unsubscribe) unsubscribe();
            unsubscribe = onSnapshot(cardsCollectionRef, (snapshot) => {
                allCards = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    allCards.push({ id: doc.id, ...data, reviewEdited: !!data.reviewEdited });
                });
                document.getElementById('total-counter').textContent = allCards.length;
                
                if (allCards.length > 0) {
                    const dates = allCards.map(c => c.createdAt && c.createdAt.split('T')[0]).filter(Boolean);
                    if (dates.length > 0) {
                        const latestDate = dates.sort().reverse()[0];
                        const cardsFromLatestDate = allCards.filter(c => c.createdAt && c.createdAt.startsWith(latestDate)).length;
                        document.getElementById('session-counter').textContent = cardsFromLatestDate;
                    } else {
                         document.getElementById('session-counter').textContent = 0;
                    }
                } else {
                    document.getElementById('session-counter').textContent = 0;
                }

                renderFolderOptions();
                filterAndRenderCards();
                updateReviewDateSelector();
                updateDuplicateBadge();
            });
        }

        async function importCardsFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const content = e.target.result;
                const lines = content.split('\n').filter(line => line.trim() !== '' && !line.trim().startsWith('#'));
                if (lines.length === 0) {
                    showNotification("The selected file is empty or contains no valid data.");
                    return;
                }
                if (!userId) {
                    showNotification("You must be logged in to import cards.");
                    return;
                }
                const { id: selectedFolderId, name: selectedFolderName } = getSelectedFolderDetails();
                try {
                    const batch = writeBatch(db);
                    const importTimestamp = new Date();
                    lines.forEach((line, index) => {
                        const fields = line.split('\t');
                        const cardTimestamp = new Date(importTimestamp.getTime() + index);

                        const frontField = (fields[0] || '').trim();
                        const backField = (fields[1] || '').trim();
                        const speechField = (fields[2] || '').trim();
                        const beispielText = (fields[3] || '').split(/\s{2,}/).join('\n');
                        const beispielSpeechField = (fields[4] || '').trim();
                        const translationText = (fields[5] || '').split(/\s{2,}/).join('\n');

                        const formattedBeispiel = formatMultiLine(beispielText);
                        const backTagBase = prepareForSoundTag(backField);
                        const computedSpeech = speechField || (backTagBase ? `[sound:${backTagBase}.mp3]` : '');
                        const computedBeispielSpeech = beispielSpeechField || buildBeispielSpeech(backField, beispielText);

                        const cardData = {
                            front: frontField,
                            back: backField,
                            speech: computedSpeech,
                            beispiel: formattedBeispiel,
                            beispielSpeech: computedBeispielSpeech,
                            translation: formatMultiLine(translationText),
                            folderId: selectedFolderId,
                            folderName: selectedFolderName,
                            createdAt: cardTimestamp.toISOString()
                        };
                        const newCardRef = doc(collection(db, `artifacts/${appId}/users/${userId}/cards`));
                        batch.set(newCardRef, cardData);
                    });
                    await batch.commit();
                    showNotification(`Successfully imported ${lines.length} cards!`, 'success');
                } catch (error) {
                    console.error("Import error: ", error);
                    showNotification("An error occurred during import.");
                } finally {
                    event.target.value = '';
                }
            };
            reader.readAsText(file);
        }
        
        function filterAndRenderCards() {
            const searchInput = document.getElementById('search-input');
            const searchTerm = (searchInput ? searchInput.value : '').toLowerCase().trim();
            let filteredCards = [...allCards];

            if (searchTerm) {
                filteredCards = filteredCards.filter(card => {
                    const folderMeta = card.folderId ? folders.find(folder => folder.id === card.folderId) : null;
                    const folderNameToMatch = ((folderMeta && folderMeta.name) || card.folderName || '').toLowerCase();
                    return (card.front || '').toLowerCase().includes(searchTerm) ||
                           (card.back || '').toLowerCase().includes(searchTerm) ||
                           (card.beispiel || '').toLowerCase().includes(searchTerm) ||
                           (card.translation || '').toLowerCase().includes(searchTerm) ||
                           folderNameToMatch.includes(searchTerm);
                });
            }

            filteredCards = filteredCards.filter(card => cardMatchesFolder(card, currentViewFolderId));

            renderCards(filteredCards);
        }

        function openDeleteCardsModal() {
            if (allCards.length === 0) {
                showNotification("There are no cards to delete.", "success");
                return;
            }
            const dates = [...new Set(allCards.map(card => card.createdAt && card.createdAt.split('T')[0]).filter(Boolean))].sort().reverse();
            const deleteDateSelection = document.getElementById('delete-date-selection');
            deleteDateSelection.innerHTML = '';
            if (dates.length > 0) {
                dates.forEach(date => {
                    const label = document.createElement('label');
                    label.className = 'flex items-center space-x-2 text-gray-300 py-1';
                    label.innerHTML = `<input type="checkbox" value="${date}" class="form-checkbox h-4 w-4 text-blue-500 bg-gray-700 border-gray-600 rounded"> <span>${date}</span>`;
                    deleteDateSelection.appendChild(label);
                });
            } else {
                showNotification("No dates available for deletion.", "success");
                return;
            }
            document.getElementById('delete-cards-modal').classList.remove('hidden');
        }

        async function handleConfirmDeleteCards() {
            const selectedDateNodes = document.querySelectorAll('#delete-date-selection input[type="checkbox"]:checked');
            if (selectedDateNodes.length === 0) {
                showNotification("Please select at least one date to delete cards from.");
                return;
            }
            const selectedDates = Array.from(selectedDateNodes).map(el => el.value);
            const cardsToDelete = allCards.filter(card => card.createdAt && selectedDates.includes(card.createdAt.split('T')[0]));
            if (cardsToDelete.length === 0) {
                showNotification("No cards found for the selected dates.", "success");
                return;
            }
            // Use a custom modal instead of a native confirm dialog
            // if (!confirm(`Are you sure you want to delete ${cardsToDelete.length} card(s)? This action cannot be undone.`)) return;
            try {
                const batch = writeBatch(db);
                cardsToDelete.forEach(card => {
                    const archivedPayload = buildArchivedCardPayload(card);
                    if (archivedPayload && deletedCardsCollectionRef) {
                        const archiveDocRef = doc(deletedCardsCollectionRef);
                        batch.set(archiveDocRef, archivedPayload);
                    }
                    batch.delete(doc(db, `artifacts/${appId}/users/${userId}/cards`, card.id));
                });
                await batch.commit();
                showNotification(`Successfully deleted ${cardsToDelete.length} cards!`, 'success');
                document.getElementById('delete-cards-modal').classList.add('hidden');
            } catch (error) {
                console.error("Delete error: ", error);
                showNotification("An error occurred during deletion.");
            }
        }

        function enterReviewEditMode() {
            if (reviewSession.currentIndex === -1) return;
            const card = reviewSession.cards[reviewSession.currentIndex];
            clearAutoSkipTimer();
            
            document.getElementById('review-beispiel').classList.add('hidden');
            const editBeispiel = document.getElementById('edit-beispiel');
            editBeispiel.classList.remove('hidden');
            editBeispiel.value = unformatMultiLine(card.beispiel || '');
            
            document.getElementById('review-translation').classList.add('hidden');
            const editTranslation = document.getElementById('edit-translation');
            editTranslation.classList.remove('hidden');
            editTranslation.value = unformatMultiLine(card.translation || '');
            
            document.querySelectorAll('.review-card .review-copy-btn, .review-card .copy-line-btn').forEach(btn => btn.classList.add('hidden'));
            document.getElementById('edit-review-card-btn').classList.add('hidden');
            document.getElementById('save-review-edit-btn').classList.remove('hidden');
            document.getElementById('cancel-review-edit-btn').classList.remove('hidden');
            isReviewEditing = true;
            editBeispiel.focus();
            setTimeout(() => {
                 const len = editBeispiel.value.length;
                 editBeispiel.setSelectionRange(len, len);
            }, 0);
        }

        function exitReviewEditMode() {
            renderReviewCard(); 
            document.getElementById('review-beispiel').classList.remove('hidden');
            document.getElementById('edit-beispiel').classList.add('hidden');

            document.getElementById('review-translation').classList.remove('hidden');
            document.getElementById('edit-translation').classList.add('hidden');
            
            document.querySelectorAll('.review-card .review-copy-btn, .review-card .copy-line-btn').forEach(btn => btn.classList.remove('hidden'));
            document.getElementById('edit-review-card-btn').classList.remove('hidden');
            document.getElementById('save-review-edit-btn').classList.add('hidden');
            document.getElementById('cancel-review-edit-btn').classList.add('hidden');
            isReviewEditing = false;
        }

        async function saveReviewEdit() {
            if (!isReviewEditing || reviewSession.currentIndex === -1) return false;
            
            const newBeispiel = formatMultiLine(document.getElementById('edit-beispiel').value);
            const newTranslation = formatMultiLine(document.getElementById('edit-translation').value);
            const card = reviewSession.cards[reviewSession.currentIndex];
            
            const backValue = card.back;
            let newBeispielSpeech = '';
            if (backValue) {
                const sentences = newBeispiel.split(/<br\s*\/?>/i).filter(s => s.trim() !== '');
                 if (sentences.length <= 1) {
                    newBeispielSpeech = `[sound:s_${backValue}.mp3]`;
                } else {
                    const soundTags = sentences.map((_, index) => {
                        const suffix = index === 0 ? '' : index + 1;
                        return `[sound:s_${backValue}${suffix}.mp3]`;
                    }).join('');
                    newBeispielSpeech = `<br> ${soundTags}`;
                }
            }

            if (newBeispiel === card.beispiel && newTranslation === card.translation) {
                return true;
            }
            
            try {
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/cards`, card.id);
                await updateDoc(docRef, {
                    beispiel: newBeispiel,
                    translation: newTranslation,
                    beispielSpeech: newBeispielSpeech
                });
                card.beispiel = newBeispiel;
                card.translation = newTranslation;
                card.beispielSpeech = newBeispielSpeech;
                
                setLocalEditedState(card.id, true);
                await updateEditedCardsInFirestore(card.id, true);
                showNotification('Card updated successfully.', 'success');
                return true;
            } catch (error) { 
                showNotification('Failed to update card.');
                return false;
            }
        }

        async function afterSaveAction() {
            const isPauseTimerEnabled = document.getElementById('pause-timer-toggle').checked;
            
            exitReviewEditMode();

            if (isPauseTimerEnabled) {
                if (reviewSession.currentIndex < reviewSession.cards.length - 1) {
                    await handleReviewNav(1, true); // Pass true to auto-edit the next card
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
            } catch (error) {
                 console.error("Initialization error:", error);
                 showNotification("Application failed to start. Please refresh.");
                 return;
            }
            
            const backInput = document.getElementById('back');
            const beispielInput = document.getElementById('beispiel');
            const translationInput = document.getElementById('translation');
            const frontInput = document.getElementById('front');
            const folderSelectEl = document.getElementById('folder-select');
            const folderNameInput = document.getElementById('folder-name-input');
            const reviewFolderSelector = document.getElementById('review-folder-selector');
            const viewFolderSelector = document.getElementById('view-folder-selector');
            
            document.getElementById('auth-form').addEventListener('submit', handleAuthSubmit);
            if (folderSelectEl) {
                folderSelectEl.addEventListener('change', (event) => {
                    const selectionChanged = updateFolderSelection(event.target.value);
                    if (selectionChanged) {
                        filterAndRenderCards();
                    }
                });
            }
            if (reviewFolderSelector) {
                reviewFolderSelector.addEventListener('change', (event) => {
                    currentReviewFolderId = event.target.value;
                    updateReviewDateSelector();
                });
            }
            if (viewFolderSelector) {
                viewFolderSelector.addEventListener('change', (event) => {
                    currentViewFolderId = event.target.value;
                    filterAndRenderCards();
                });
            }
            document.getElementById('create-folder-btn').addEventListener('click', openFolderModal);
            document.getElementById('cancel-folder-btn').addEventListener('click', () => closeFolderModal());
            document.getElementById('save-folder-btn').addEventListener('click', handleCreateFolder);
            document.getElementById('folder-modal').addEventListener('click', (event) => {
                if (event.target === event.currentTarget) {
                    closeFolderModal();
                }
            });
            if (folderNameInput) {
                folderNameInput.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        handleCreateFolder();
                    } else if (event.key === 'Escape') {
                        event.preventDefault();
                        closeFolderModal();
                    }
                });
            }
            
            document.getElementById('auth-toggle-btn').addEventListener('click', toggleAuthMode);
            document.getElementById('logout-btn').addEventListener('click', userSignOut);
            document.getElementById('anki-form').addEventListener('submit', handleFormSubmit);
            
            [frontInput, backInput, beispielInput, translationInput].forEach(input => {
                input.addEventListener('input', updateSpeechFields);
                input.addEventListener('blur', (e) => {
                    e.target.value = e.target.value.trim();
                });
            });

            document.getElementById('generate-img-tag-btn').addEventListener('click', handleGenerateOrCycleImage);
            document.getElementById('search-input').addEventListener('input', filterAndRenderCards);
            document.getElementById('update-btn').addEventListener('click', handleUpdateCard);
            document.getElementById('cancel-btn').addEventListener('click', () => setEditMode(false));
            document.getElementById('confirm-delete-btn').addEventListener('click', handleDeleteConfirmed);
            document.getElementById('cancel-delete-btn').addEventListener('click', () => {
                resetDeleteShortcut();
                document.getElementById('delete-modal').classList.add('hidden');
            });
            document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-file-input').click());
            document.getElementById('import-file-input').addEventListener('change', importCardsFromFile);
            const translateBeispielBtn = document.getElementById('translate-beispiel-btn');
            if (translateBeispielBtn) translateBeispielBtn.addEventListener('click', handleTranslateCurrentBeispiel);
            const setDeepLKeyBtn = document.getElementById('set-deepl-key-btn');
            if (setDeepLKeyBtn) setDeepLKeyBtn.addEventListener('click', promptForDeepLKey);
            const bulkTranslateBtn = document.getElementById('bulk-translate-btn');
            if (bulkTranslateBtn) bulkTranslateBtn.addEventListener('click', handleBulkTranslateBeispiele);
            document.getElementById('review-btn').addEventListener('click', () => {
                document.getElementById('main-app').classList.add('hidden');
                document.getElementById('review-modal').classList.remove('hidden');
            });
            document.getElementById('close-review-setup-btn').addEventListener('click', endReviewSession);
            document.getElementById('start-session-btn').addEventListener('click', startReviewSession);
            document.getElementById('next-card-btn').addEventListener('click', () => handleReviewNav(1));
            document.getElementById('prev-card-btn').addEventListener('click', () => handleReviewNav(-1));
            document.getElementById('end-review-btn').addEventListener('click', endReviewSession);
            document.getElementById('delete-review-card-btn').addEventListener('click', () => {
                resetDeleteShortcut();
                if (reviewSession.cards[reviewSession.currentIndex]) {
                    cardToDeleteId = reviewSession.cards[reviewSession.currentIndex].id;
                    document.getElementById('delete-modal').classList.remove('hidden'); 
                }
            });
            document.getElementById('export-btn').addEventListener('click', openExportModal);
            document.getElementById('confirm-export-btn').addEventListener('click', handleConfirmExport);
            document.getElementById('cancel-export-btn').addEventListener('click', () => {
                document.getElementById('export-modal').classList.add('hidden');
                document.getElementById('clipboard-output-container').classList.add('hidden');
            });
            document.getElementById('copy-clipboard-btn').addEventListener('click', () => {
                const tempInput = document.createElement('textarea');
                tempInput.value = document.getElementById('clipboard-output').value;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);
                showNotification("Copied to clipboard!", "success");
            });
            preloadDefaultDeepLKey();
            updateDeepLKeyStatus();
            document.querySelectorAll('input[name="export-format"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    if (!radio.value.startsWith('clipboard')) {
                        document.getElementById('clipboard-output-container').classList.add('hidden');
                    }
                });
            });
            document.getElementById('export-all-radio').addEventListener('change', (e) => { if(e.target.checked) document.getElementById('export-date-selection').classList.add('hidden'); });
            document.getElementById('export-date-radio').addEventListener('change', (e) => { if(e.target.checked) document.getElementById('export-date-selection').classList.remove('hidden'); });
            
            document.getElementById('review-session').addEventListener('click', (e) => {
                const lineCopyBtn = e.target.closest('.copy-line-btn');
                if(lineCopyBtn) {
                    const tempInput = document.createElement('textarea');
                    tempInput.value = lineCopyBtn.dataset.text;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempInput);
                    showNotification("Copied sentence!", "success", 1500);
                    lineCopyBtn.parentElement.classList.add('copy-highlight');
                    setTimeout(() => lineCopyBtn.parentElement.classList.remove('copy-highlight'), 400);
                    return;
                }

                const mainCopyBtn = e.target.closest('.review-copy-btn');
                if (mainCopyBtn) {
                    clearAutoSkipTimer();
                    const targetId = mainCopyBtn.dataset.target;
                    const contentEl = document.getElementById(targetId);
                    if (!contentEl) return;

                    const textToCopy = unformatMultiLine(contentEl.innerHTML);

                    const tempInput = document.createElement('textarea');
                    tempInput.value = textToCopy;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempInput);
                    
                    showNotification("Copied!", "success", 1500);

                    const isPauseTimerEnabled = document.getElementById('pause-timer-toggle').checked;
                    const isBackButton = mainCopyBtn.dataset.target === 'review-back';

                    if (isPauseTimerEnabled && isBackButton) {
                        if (!isReviewEditing) enterReviewEditMode();
                        return;
                    }
                    
                    const advance = () => { if (reviewSession.currentIndex < reviewSession.cards.length - 1) handleReviewNav(1); };
                    if (!isReviewEditing) {
                        const isDelayedSkip = document.getElementById('auto-skip-toggle').checked;
                        if (isDelayedSkip && !isPauseTimerEnabled) {
                            reviewSession.autoSkipTimer = setTimeout(advance, 55000);
                        } else if (!isDelayedSkip) {
                            advance();
                        }
                    }
                }
            });


            document.addEventListener('keydown', (e) => {
                if (isDuplicatesViewActive()) {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        showMainAppView();
                    }
                    return;
                }
                if (isDeletedViewActive()) {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        showMainAppView();
                    }
                    return;
                }
                const folderModal = document.getElementById('folder-modal');
                if (e.key === 'Escape' && folderModal && !folderModal.classList.contains('hidden')) {
                    e.preventDefault();
                    closeFolderModal();
                    return;
                }
                const formInputs = ['front', 'back', 'beispiel', 'translation'];
                const reviewInputs = ['edit-beispiel', 'edit-translation'];
                const activeId = document.activeElement.id;

                if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                    let currentList = [];
                    if (formInputs.includes(activeId)) currentList = formInputs;
                    if (reviewInputs.includes(activeId)) currentList = reviewInputs;

                    if (currentList.length > 0) {
                        e.preventDefault();
                        const currentIndex = currentList.indexOf(activeId);
                        const direction = e.key === 'ArrowDown' ? 1 : -1;
                        const nextIndex = (currentIndex + direction + currentList.length) % currentList.length;
                        document.getElementById(currentList[nextIndex]).focus();
                    }
                }

                const otherModalOpen = document.querySelector('.modal-backdrop:not(#review-modal):not(.hidden)');
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || otherModalOpen) return;

                if (e.key === 'n' || e.key === 'N') {
                    const reviewModal = document.getElementById('review-modal');
                    if (folderModal && folderModal.classList.contains('hidden') && reviewModal && reviewModal.classList.contains('hidden')) {
                        e.preventDefault();
                        openFolderModal();
                        return;
                    }
                }
                
                if (document.getElementById('review-session').classList.contains('hidden')) {
                    if (e.key === 't') { 
                        e.preventDefault(); 
                        document.getElementById('generate-img-tag-btn').click(); 
                    } else if (e.key === 'r' || e.key === 'R') {
                        e.preventDefault();
                        document.getElementById('review-btn').click();
                    } else if (e.key === ' ') { 
                        e.preventDefault(); 
                        document.getElementById('review-modal').classList.contains('hidden') ? document.getElementById('review-btn').click() : document.getElementById('start-session-btn').click(); 
                    } else if (e.key === 'Enter' && !document.getElementById('review-modal').classList.contains('hidden') && !document.getElementById('review-setup').classList.contains('hidden')) { 
                        e.preventDefault(); 
                        document.getElementById('start-session-btn').click(); 
                    } else if (e.key === 'c' || e.key === 'C') {
                        e.preventDefault();
                        const firstCard = document.querySelector('#card-list .card-item .copy-btn');
                        if (firstCard) {
                            firstCard.click();
                        }
                    }
                }
            });
            renderFolderOptions();
            filterAndRenderCards();
            onAuthStateChanged(auth, user => { if (user) showAppUI(user); else showLoginUI(); });
            document.getElementById('delete-cards-btn').addEventListener('click', openDeleteCardsModal);
            document.getElementById('confirm-delete-cards-btn').addEventListener('click', handleConfirmDeleteCards);
            document.getElementById('cancel-delete-cards-btn').addEventListener('click', () => document.getElementById('delete-cards-modal').classList.add('hidden'));
            const showDuplicatesBtn = document.getElementById('show-duplicates-btn');
            if (showDuplicatesBtn) {
                showDuplicatesBtn.addEventListener('click', () => {
                    showDuplicatesView();
                });
            }
            const duplicatesBackBtn = document.getElementById('duplicates-back-btn');
            if (duplicatesBackBtn) duplicatesBackBtn.addEventListener('click', showMainAppView);
            const duplicatesSearchInput = document.getElementById('duplicates-search-input');
            if (duplicatesSearchInput) {
                duplicatesSearchInput.addEventListener('input', () => {
                    if (isDuplicatesViewActive()) renderDuplicatesView();
                });
            }
            const duplicatesFolderFilter = document.getElementById('duplicates-folder-filter');
            if (duplicatesFolderFilter) {
                duplicatesFolderFilter.addEventListener('change', () => {
                    if (isDuplicatesViewActive()) renderDuplicatesView();
                });
            }
            const duplicatesRefreshBtn = document.getElementById('duplicates-refresh-btn');
            if (duplicatesRefreshBtn) duplicatesRefreshBtn.addEventListener('click', () => renderDuplicatesView());
            const duplicatesExportBtn = document.getElementById('duplicates-export-btn');
            if (duplicatesExportBtn) duplicatesExportBtn.addEventListener('click', exportVisibleDuplicates);
            const duplicatesContainer = document.getElementById('duplicates-container');
            if (duplicatesContainer) {
                duplicatesContainer.addEventListener('click', (e) => {
                    const editBtn = e.target.closest('.duplicate-edit-btn');
                    if (editBtn) {
                        const card = allCards.find(c => c.id === editBtn.dataset.cardId);
                        if (card) {
                            showMainAppView();
                            setEditMode(true, card);
                        }
                        return;
                    }
                    const deleteBtn = e.target.closest('.duplicate-delete-btn');
                    if (deleteBtn) {
                        const cardId = deleteBtn.dataset.cardId;
                        if (cardId) {
                            cardToDeleteId = cardId;
                            const deleteModal = document.getElementById('delete-modal');
                            if (deleteModal) deleteModal.classList.remove('hidden');
                        }
                        return;
                    }
                    const copyBtn = e.target.closest('.duplicate-copy-btn');
                    if (copyBtn) {
                        const card = allCards.find(c => c.id === copyBtn.dataset.cardId);
                        if (card && card.back) {
                            const tempInput = document.createElement('textarea');
                            tempInput.value = unformatMultiLine(card.back);
                            document.body.appendChild(tempInput);
                            tempInput.select();
                            document.execCommand('copy');
                            document.body.removeChild(tempInput);
                            showNotification('Back copied to clipboard!', 'success', 1500);
                        }
                    }
                });
            }
            const showDeletedBtn = document.getElementById('show-deleted-btn');
            if (showDeletedBtn) showDeletedBtn.addEventListener('click', showDeletedView);
            const deletedBackBtn = document.getElementById('deleted-back-btn');
            if (deletedBackBtn) deletedBackBtn.addEventListener('click', showMainAppView);
            const deletedContainer = document.getElementById('deleted-container');
            if (deletedContainer) {
                deletedContainer.addEventListener('click', (e) => {
                    const restoreBtn = e.target.closest('.deleted-restore-btn');
                    if (restoreBtn) {
                        const card = deletedCards.find(c => c.id === restoreBtn.dataset.cardId);
                        if (card) restoreDeletedCard(card, { edit: false });
                        return;
                    }
                    const restoreEditBtn = e.target.closest('.deleted-restore-edit-btn');
                    if (restoreEditBtn) {
                        const card = deletedCards.find(c => c.id === restoreEditBtn.dataset.cardId);
                        if (card) restoreDeletedCard(card, { edit: true });
                        return;
                    }
                    const copyBtn = e.target.closest('.deleted-copy-btn');
                    if (copyBtn) {
                        const card = deletedCards.find(c => c.id === copyBtn.dataset.cardId);
                        if (card && card.back) {
                            const tempInput = document.createElement('textarea');
                            tempInput.value = unformatMultiLine(card.back);
                            document.body.appendChild(tempInput);
                            tempInput.select();
                            document.execCommand('copy');
                            document.body.removeChild(tempInput);
                            showNotification('Back copied to clipboard!', 'success', 1500);
                        }
                        return;
                    }
                    const removeBtn = e.target.closest('.deleted-remove-btn');
                    if (removeBtn) {
                        const cardId = removeBtn.dataset.cardId;
                        if (cardId) {
                            permanentlyDeleteArchivedCard(cardId);
                        }
                    }
                });
            }
            document.getElementById('edit-review-card-btn').addEventListener('click', enterReviewEditMode);
            
            document.getElementById('save-review-edit-btn').addEventListener('click', async () => {
                const success = await saveReviewEdit();
                if (success) {
                    afterSaveAction();
                }
            });

            document.getElementById('cancel-review-edit-btn').addEventListener('click', exitReviewEditMode);

            [document.getElementById('edit-beispiel'), document.getElementById('edit-translation')].forEach(input => {
                input.addEventListener('keydown', async e => {
                    if (e.key === 'Enter' && !e.shiftKey) { 
                        e.preventDefault(); 
                        const success = await saveReviewEdit();
                        if (success) {
                           afterSaveAction();
                        }
                    }
                    if (e.key === 'Escape') { e.preventDefault(); exitReviewEditMode(); }
                });
                input.addEventListener('paste', (e) => {
                    setTimeout(() => {
                        const textarea = e.target;
                        if (textarea.value.slice(-1) !== '\n') {
                            textarea.value += '\n';
                        }
                        textarea.scrollTop = textarea.scrollHeight;
                        textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
                    }, 1);
                });
            });
            document.getElementById('mark-edited-btn').addEventListener('click', async () => {
                if (reviewSession.currentIndex > -1) {
                    const cardId = reviewSession.cards[reviewSession.currentIndex].id;
                    if (reviewSession.editedCardIds.has(cardId)) {
                        setLocalEditedState(cardId, false);
                        await updateEditedCardsInFirestore(cardId, false);
                    } else {
                        setLocalEditedState(cardId, true);
                        await updateEditedCardsInFirestore(cardId, true);
                    }
                    renderReviewCard();
                }
            });
             document.getElementById('in-review-search-input').addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase().trim();
                if (!searchTerm) {
                    reviewSession.cards = [...reviewSession.originalCards];
                    reviewSession.currentIndex = reviewSession.cards.length > 0 ? 0 : -1;
                } else {
                    const filtered = reviewSession.originalCards.filter(card => {
                        return (card.front || '').toLowerCase().includes(searchTerm) ||
                               (card.back || '').toLowerCase().includes(searchTerm) ||
                               (card.beispiel || '').toLowerCase().includes(searchTerm) ||
                               (card.translation || '').toLowerCase().includes(searchTerm);
                    });
                    reviewSession.cards = filtered;
                    reviewSession.currentIndex = filtered.length > 0 ? 0 : -1;
                }
                renderReviewCard();
            });
        });
    </script>
</body>
</html>
